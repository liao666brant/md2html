import 'path';
import url from 'url';
import bash from 'highlight.js/lib/languages/bash';
import c from 'highlight.js/lib/languages/c';
import cpp from 'highlight.js/lib/languages/cpp';
import csharp from 'highlight.js/lib/languages/csharp';
import css from 'highlight.js/lib/languages/css';
import diff from 'highlight.js/lib/languages/diff';
import go from 'highlight.js/lib/languages/go';
import graphql from 'highlight.js/lib/languages/graphql';
import ini from 'highlight.js/lib/languages/ini';
import java from 'highlight.js/lib/languages/java';
import javascript from 'highlight.js/lib/languages/javascript';
import json from 'highlight.js/lib/languages/json';
import kotlin from 'highlight.js/lib/languages/kotlin';
import less from 'highlight.js/lib/languages/less';
import lua from 'highlight.js/lib/languages/lua';
import makefile from 'highlight.js/lib/languages/makefile';
import markdown from 'highlight.js/lib/languages/markdown';
import objectivec from 'highlight.js/lib/languages/objectivec';
import perl from 'highlight.js/lib/languages/perl';
import php from 'highlight.js/lib/languages/php';
import phpTemplate from 'highlight.js/lib/languages/php-template';
import plaintext from 'highlight.js/lib/languages/plaintext';
import python from 'highlight.js/lib/languages/python';
import pythonRepl from 'highlight.js/lib/languages/python-repl';
import r from 'highlight.js/lib/languages/r';
import ruby from 'highlight.js/lib/languages/ruby';
import rust from 'highlight.js/lib/languages/rust';
import scss from 'highlight.js/lib/languages/scss';
import shell from 'highlight.js/lib/languages/shell';
import sql from 'highlight.js/lib/languages/sql';
import swift from 'highlight.js/lib/languages/swift';
import typescript from 'highlight.js/lib/languages/typescript';
import vbnet from 'highlight.js/lib/languages/vbnet';
import wasm from 'highlight.js/lib/languages/wasm';
import xml from 'highlight.js/lib/languages/xml';
import yaml from 'highlight.js/lib/languages/yaml';
import DOMPurify from 'isomorphic-dompurify';
import { marked } from 'marked';
import { deflateSync } from 'fflate';
import { toMerged, cloneDeep } from 'es-toolkit';
import frontMatter from 'front-matter';
import hljs from 'highlight.js/lib/core';
import readingTime from 'reading-time';
import crypto from 'crypto';
import http from 'http';
import https from 'https';
import util from 'util';
import zlib from 'zlib';
import stream3, { Readable } from 'stream';
import { EventEmitter } from 'events';

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }) ,
  mod
));
var init_esm_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.5.0_jiti@2.6.1_postcss@8.5.6_typescript@5.9.3_yaml@2.8.1/node_modules/tsup/assets/esm_shims.js"() {
  }
});

// ../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports, module) {
    init_esm_shims();
    var Stream = __require("stream").Stream;
    var util3 = __require("util");
    module.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util3.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r2 = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r2;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// ../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports, module) {
    init_esm_shims();
    var util3 = __require("util");
    var Stream = __require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util3.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream4) {
      return typeof stream4 !== "function" && typeof stream4 !== "string" && typeof stream4 !== "boolean" && typeof stream4 !== "number" && !Buffer.isBuffer(stream4);
    };
    CombinedStream.prototype.append = function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream4.on("data", this._checkDataSize.bind(this));
          stream4 = newStream;
        }
        this._handleErrors(stream4);
        if (this.pauseStreams) {
          stream4.pause();
        }
      }
      this._streams.push(stream4);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream4 = this._streams.shift();
      if (typeof stream4 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream4 !== "function") {
        this._pipeNext(stream4);
        return;
      }
      var getStream = stream4;
      getStream(function(stream5) {
        var isStreamLike = CombinedStream.isStreamLike(stream5);
        if (isStreamLike) {
          stream5.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream5);
        }
        this._pipeNext(stream5);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("end", this._getNext.bind(this));
        stream4.pipe(this, { end: false });
        return;
      }
      var value = stream4;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream4) {
      var self2 = this;
      stream4.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream4) {
        if (!stream4.dataSize) {
          return;
        }
        self2.dataSize += stream4.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports, module) {
    module.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports, module) {
    init_esm_shims();
    module.exports = require_db();
  }
});

// ../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports) {
    init_esm_shims();
    var db = require_mime_db();
    var extname = __require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports, module) {
    init_esm_shims();
    module.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports, module) {
    init_esm_shims();
    var defer = require_defer();
    module.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports, module) {
    init_esm_shims();
    module.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports, module) {
    init_esm_shims();
    var async = require_async();
    var abort = require_abort();
    module.exports = iterate;
    function iterate(list, iterator2, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator2, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator2, key, item, callback) {
      var aborter;
      if (iterator2.length == 2) {
        aborter = iterator2(item, async(callback));
      } else {
        aborter = iterator2(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports, module) {
    init_esm_shims();
    module.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports, module) {
    init_esm_shims();
    var abort = require_abort();
    var async = require_async();
    module.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports, module) {
    init_esm_shims();
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = parallel;
    function parallel(list, iterator2, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator2, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports, module) {
    init_esm_shims();
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = serialOrdered;
    module.exports.ascending = ascending;
    module.exports.descending = descending;
    function serialOrdered(list, iterator2, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator2, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator2, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports, module) {
    init_esm_shims();
    var serialOrdered = require_serialOrdered();
    module.exports = serial;
    function serial(list, iterator2, callback) {
      return serialOrdered(list, iterator2, null, callback);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports, module) {
    init_esm_shims();
    module.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// ../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports, module) {
    init_esm_shims();
    module.exports = Object;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports, module) {
    init_esm_shims();
    module.exports = Error;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports, module) {
    init_esm_shims();
    module.exports = EvalError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports, module) {
    init_esm_shims();
    module.exports = RangeError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports, module) {
    init_esm_shims();
    module.exports = ReferenceError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module) {
    init_esm_shims();
    module.exports = SyntaxError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module) {
    init_esm_shims();
    module.exports = TypeError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports, module) {
    init_esm_shims();
    module.exports = URIError;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports, module) {
    init_esm_shims();
    module.exports = Math.abs;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports, module) {
    init_esm_shims();
    module.exports = Math.floor;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports, module) {
    init_esm_shims();
    module.exports = Math.max;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports, module) {
    init_esm_shims();
    module.exports = Math.min;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports, module) {
    init_esm_shims();
    module.exports = Math.pow;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports, module) {
    init_esm_shims();
    module.exports = Math.round;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports, module) {
    init_esm_shims();
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports, module) {
    init_esm_shims();
    var $isNaN = require_isNaN();
    module.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports, module) {
    init_esm_shims();
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports, module) {
    init_esm_shims();
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// ../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports, module) {
    init_esm_shims();
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports, module) {
    init_esm_shims();
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports, module) {
    init_esm_shims();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    init_esm_shims();
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    init_esm_shims();
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module) {
    init_esm_shims();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module) {
    init_esm_shims();
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    init_esm_shims();
    module.exports = Function.prototype.call;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    init_esm_shims();
    module.exports = Function.prototype.apply;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    init_esm_shims();
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    init_esm_shims();
    var bind2 = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind2.call($call, $apply);
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    init_esm_shims();
    var bind2 = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind2, $call, args);
    };
  }
});

// ../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports, module) {
    init_esm_shims();
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports, module) {
    init_esm_shims();
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// ../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module) {
    init_esm_shims();
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind2 = require_function_bind();
    module.exports = bind2.call(call, $hasOwn);
  }
});

// ../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports, module) {
    init_esm_shims();
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind2.call($call, Array.prototype.concat);
    var $spliceApply = bind2.call($apply, Array.prototype.splice);
    var $replace = bind2.call($call, String.prototype.replace);
    var $strSlice = bind2.call($call, String.prototype.slice);
    var $exec = bind2.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports, module) {
    init_esm_shims();
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// ../../node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "../../node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js"(exports, module) {
    init_esm_shims();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
    module.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag2 && (overrideIfSet || !hasOwn(object, toStringTag2))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag2, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag2] = value;
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/populate.js"(exports, module) {
    init_esm_shims();
    module.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// ../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/form_data.js"(exports, module) {
    init_esm_shims();
    var CombinedStream = require_combined_stream();
    var util3 = __require("util");
    var path2 = __require("path");
    var http2 = __require("http");
    var https2 = __require("https");
    var parseUrl = __require("url").parse;
    var fs = __require("fs");
    var Stream = __require("stream").Stream;
    var crypto2 = __require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData3(options) {
      if (!(this instanceof FormData3)) {
        return new FormData3(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    util3.inherits(FormData3, CombinedStream);
    FormData3.LINE_BREAK = "\r\n";
    FormData3.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData3.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append2(header);
      append2(value);
      append2(footer);
      this._trackLength(header, value, options);
    };
    FormData3.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData3.prototype._lengthRetriever = function(value, callback) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData3.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData3.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
    };
    FormData3.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path2.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path2.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path2.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData3.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData3.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData3.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData3.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData3.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData3.LINE_BREAK;
    };
    FormData3.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData3.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData3.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData3.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData3.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto2.randomBytes(12).toString("hex");
    };
    FormData3.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData3.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData3.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData3.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults2 = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2);
      } else {
        options = populate(params, defaults2);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https2.request(options);
      } else {
        request = http2.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData3.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData3.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData3, "FormData");
    module.exports = FormData3;
  }
});

// ../../node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "../../node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js"(exports) {
    init_esm_shims();
    var parseUrl = __require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports.getProxyForUrl = getProxyForUrl;
  }
});

// ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
    init_esm_shims();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js"(exports, module) {
    init_esm_shims();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js"(exports, module) {
    init_esm_shims();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js"(exports, module) {
    init_esm_shims();
    module.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// ../../node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js"(exports, module) {
    init_esm_shims();
    var os = __require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream4) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream4 && !stream4.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream4) {
      const level = supportsColor(stream4);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js"(exports, module) {
    init_esm_shims();
    var tty = __require("tty");
    var util3 = __require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util3.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util3.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js"(exports, module) {
    init_esm_shims();
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// ../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.1/node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.1/node_modules/follow-redirects/debug.js"(exports, module) {
    init_esm_shims();
    var debug;
    module.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.1/node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.1/node_modules/follow-redirects/index.js"(exports, module) {
    init_esm_shims();
    var url2 = __require("url");
    var URL2 = url2.URL;
    var http2 = __require("http");
    var https2 = __require("https");
    var Writable = __require("stream").Writable;
    var assert = __require("assert");
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction3(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop2;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer2(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction3(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction3(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction3(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction3(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString2(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction3(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop2() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url2.parse(input));
        if (!isString2(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL2(relative, base) : parseUrl(url2.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread3 = target || {};
      for (var key of preservedUrlFields) {
        spread3[key] = urlObject[key];
      }
      if (spread3.hostname.startsWith("[")) {
        spread3.hostname = spread3.hostname.slice(1, -1);
      }
      if (spread3.port !== "") {
        spread3.port = Number(spread3.port);
      }
      spread3.path = spread3.search ? spread3.pathname + spread3.search : spread3.pathname;
      return spread3;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction3(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop2);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction3(value) {
      return typeof value === "function";
    }
    function isBuffer2(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module.exports = wrap({ http: http2, https: https2 });
    module.exports.wrap = wrap;
  }
});

// ../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/parser-babel.js
var require_parser_babel = __commonJS({
  "../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/parser-babel.js"(exports, module) {
    init_esm_shims();
    (function(e) {
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.babel = e();
      }
    })(function() {
      var E = (l, h) => () => (h || l((h = { exports: {} }).exports, h), h.exports);
      var re = E((xd, Zr) => {
        var Ct = function(l) {
          return l && l.Math == Math && l;
        };
        Zr.exports = Ct(typeof globalThis == "object" && globalThis) || Ct(typeof window == "object" && window) || Ct(typeof self == "object" && self) || Ct(typeof global == "object" && global) || /* @__PURE__ */ (function() {
          return this;
        })() || Function("return this")();
      });
      var ie = E((gd, ei) => {
        ei.exports = function(l) {
          try {
            return !!l();
          } catch {
            return true;
          }
        };
      });
      var ye = E((Pd, ti) => {
        var kh = ie();
        ti.exports = !kh(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var bt = E((Ad, si) => {
        var Dh = ie();
        si.exports = !Dh(function() {
          var l = function() {
          }.bind();
          return typeof l != "function" || l.hasOwnProperty("prototype");
        });
      });
      var wt = E((Td, ri) => {
        var Fh = bt(), St = Function.prototype.call;
        ri.exports = Fh ? St.bind(St) : function() {
          return St.apply(St, arguments);
        };
      });
      var oi = E((ni) => {
        var ii = {}.propertyIsEnumerable, ai = Object.getOwnPropertyDescriptor, Lh = ai && !ii.call({ 1: 2 }, 1);
        ni.f = Lh ? function(h) {
          var p = ai(this, h);
          return !!p && p.enumerable;
        } : ii;
      });
      var fs = E((Ed, li) => {
        li.exports = function(l, h) {
          return { enumerable: !(l & 1), configurable: !(l & 2), writable: !(l & 4), value: h };
        };
      });
      var ae = E((Cd, ci) => {
        var hi = bt(), ui = Function.prototype, ds = ui.call, Oh = hi && ui.bind.bind(ds, ds);
        ci.exports = hi ? Oh : function(l) {
          return function() {
            return ds.apply(l, arguments);
          };
        };
      });
      var Ye = E((bd, fi) => {
        var pi = ae(), Bh = pi({}.toString), Mh = pi("".slice);
        fi.exports = function(l) {
          return Mh(Bh(l), 8, -1);
        };
      });
      var mi = E((Sd, di) => {
        var _h = ae(), Rh = ie(), jh = Ye(), ms = Object, qh = _h("".split);
        di.exports = Rh(function() {
          return !ms("z").propertyIsEnumerable(0);
        }) ? function(l) {
          return jh(l) == "String" ? qh(l, "") : ms(l);
        } : ms;
      });
      var ys = E((wd, yi) => {
        yi.exports = function(l) {
          return l == null;
        };
      });
      var xs = E((Id, xi) => {
        var Uh = ys(), $h = TypeError;
        xi.exports = function(l) {
          if (Uh(l)) throw $h("Can't call method on " + l);
          return l;
        };
      });
      var It = E((Nd, gi) => {
        var Hh = mi(), zh = xs();
        gi.exports = function(l) {
          return Hh(zh(l));
        };
      });
      var Ps = E((kd, Pi) => {
        var gs = typeof document == "object" && document.all, Vh = typeof gs > "u" && gs !== void 0;
        Pi.exports = { all: gs, IS_HTMLDDA: Vh };
      });
      var ee = E((Dd, Ti) => {
        var Ai = Ps(), Kh = Ai.all;
        Ti.exports = Ai.IS_HTMLDDA ? function(l) {
          return typeof l == "function" || l === Kh;
        } : function(l) {
          return typeof l == "function";
        };
      });
      var Ie = E((Fd, Ci) => {
        var vi = ee(), Ei = Ps(), Wh = Ei.all;
        Ci.exports = Ei.IS_HTMLDDA ? function(l) {
          return typeof l == "object" ? l !== null : vi(l) || l === Wh;
        } : function(l) {
          return typeof l == "object" ? l !== null : vi(l);
        };
      });
      var Qe = E((Ld, bi) => {
        var As = re(), Gh = ee(), Jh = function(l) {
          return Gh(l) ? l : void 0;
        };
        bi.exports = function(l, h) {
          return arguments.length < 2 ? Jh(As[l]) : As[l] && As[l][h];
        };
      });
      var wi = E((Od, Si) => {
        var Xh = ae();
        Si.exports = Xh({}.isPrototypeOf);
      });
      var Ni = E((Bd, Ii) => {
        var Yh = Qe();
        Ii.exports = Yh("navigator", "userAgent") || "";
      });
      var Mi = E((Md, Bi) => {
        var Oi = re(), Ts = Ni(), ki = Oi.process, Di = Oi.Deno, Fi = ki && ki.versions || Di && Di.version, Li = Fi && Fi.v8, ne, Nt;
        Li && (ne = Li.split("."), Nt = ne[0] > 0 && ne[0] < 4 ? 1 : +(ne[0] + ne[1]));
        !Nt && Ts && (ne = Ts.match(/Edge\/(\d+)/), (!ne || ne[1] >= 74) && (ne = Ts.match(/Chrome\/(\d+)/), ne && (Nt = +ne[1])));
        Bi.exports = Nt;
      });
      var vs = E((_d, Ri) => {
        var _i = Mi(), Qh = ie();
        Ri.exports = !!Object.getOwnPropertySymbols && !Qh(function() {
          var l = Symbol();
          return !String(l) || !(Object(l) instanceof Symbol) || !Symbol.sham && _i && _i < 41;
        });
      });
      var Es = E((Rd, ji) => {
        var Zh = vs();
        ji.exports = Zh && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Cs = E((jd, qi) => {
        var eu = Qe(), tu = ee(), su = wi(), ru = Es(), iu = Object;
        qi.exports = ru ? function(l) {
          return typeof l == "symbol";
        } : function(l) {
          var h = eu("Symbol");
          return tu(h) && su(h.prototype, iu(l));
        };
      });
      var $i = E((qd, Ui) => {
        var au = String;
        Ui.exports = function(l) {
          try {
            return au(l);
          } catch {
            return "Object";
          }
        };
      });
      var kt = E((Ud, Hi) => {
        var nu = ee(), ou = $i(), lu = TypeError;
        Hi.exports = function(l) {
          if (nu(l)) return l;
          throw lu(ou(l) + " is not a function");
        };
      });
      var Vi = E(($d, zi) => {
        var hu = kt(), uu = ys();
        zi.exports = function(l, h) {
          var p = l[h];
          return uu(p) ? void 0 : hu(p);
        };
      });
      var Wi = E((Hd, Ki) => {
        var bs = wt(), Ss = ee(), ws = Ie(), cu = TypeError;
        Ki.exports = function(l, h) {
          var p, d;
          if (h === "string" && Ss(p = l.toString) && !ws(d = bs(p, l)) || Ss(p = l.valueOf) && !ws(d = bs(p, l)) || h !== "string" && Ss(p = l.toString) && !ws(d = bs(p, l))) return d;
          throw cu("Can't convert object to primitive value");
        };
      });
      var Ji = E((zd, Gi) => {
        Gi.exports = false;
      });
      var Dt = E((Vd, Yi) => {
        var Xi = re(), pu = Object.defineProperty;
        Yi.exports = function(l, h) {
          try {
            pu(Xi, l, { value: h, configurable: true, writable: true });
          } catch {
            Xi[l] = h;
          }
          return h;
        };
      });
      var Ft = E((Kd, Zi) => {
        var fu = re(), du = Dt(), Qi = "__core-js_shared__", mu = fu[Qi] || du(Qi, {});
        Zi.exports = mu;
      });
      var Is = E((Wd, ta) => {
        var yu = Ji(), ea = Ft();
        (ta.exports = function(l, h) {
          return ea[l] || (ea[l] = h !== void 0 ? h : {});
        })("versions", []).push({ version: "3.26.1", mode: yu ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var Ns = E((Gd, sa) => {
        var xu = xs(), gu = Object;
        sa.exports = function(l) {
          return gu(xu(l));
        };
      });
      var ve = E((Jd, ra) => {
        var Pu = ae(), Au = Ns(), Tu = Pu({}.hasOwnProperty);
        ra.exports = Object.hasOwn || function(h, p) {
          return Tu(Au(h), p);
        };
      });
      var ks = E((Xd, ia) => {
        var vu = ae(), Eu = 0, Cu = Math.random(), bu = vu(1 .toString);
        ia.exports = function(l) {
          return "Symbol(" + (l === void 0 ? "" : l) + ")_" + bu(++Eu + Cu, 36);
        };
      });
      var Ze = E((Yd, ha) => {
        var Su = re(), wu = Is(), aa = ve(), Iu = ks(), na = vs(), la = Es(), qe = wu("wks"), Ne = Su.Symbol, oa = Ne && Ne.for, Nu = la ? Ne : Ne && Ne.withoutSetter || Iu;
        ha.exports = function(l) {
          if (!aa(qe, l) || !(na || typeof qe[l] == "string")) {
            var h = "Symbol." + l;
            na && aa(Ne, l) ? qe[l] = Ne[l] : la && oa ? qe[l] = oa(h) : qe[l] = Nu(h);
          }
          return qe[l];
        };
      });
      var fa = E((Qd, pa) => {
        var ku = wt(), ua = Ie(), ca = Cs(), Du = Vi(), Fu = Wi(), Lu = Ze(), Ou = TypeError, Bu = Lu("toPrimitive");
        pa.exports = function(l, h) {
          if (!ua(l) || ca(l)) return l;
          var p = Du(l, Bu), d;
          if (p) {
            if (h === void 0 && (h = "default"), d = ku(p, l, h), !ua(d) || ca(d)) return d;
            throw Ou("Can't convert object to primitive value");
          }
          return h === void 0 && (h = "number"), Fu(l, h);
        };
      });
      var Ds = E((Zd, da) => {
        var Mu = fa(), _u = Cs();
        da.exports = function(l) {
          var h = Mu(l, "string");
          return _u(h) ? h : h + "";
        };
      });
      var xa = E((em, ya) => {
        var Ru = re(), ma = Ie(), Fs = Ru.document, ju = ma(Fs) && ma(Fs.createElement);
        ya.exports = function(l) {
          return ju ? Fs.createElement(l) : {};
        };
      });
      var Ls = E((tm, ga) => {
        var qu = ye(), Uu = ie(), $u = xa();
        ga.exports = !qu && !Uu(function() {
          return Object.defineProperty($u("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Os = E((Aa) => {
        var Hu = ye(), zu = wt(), Vu = oi(), Ku = fs(), Wu = It(), Gu = Ds(), Ju = ve(), Xu = Ls(), Pa = Object.getOwnPropertyDescriptor;
        Aa.f = Hu ? Pa : function(h, p) {
          if (h = Wu(h), p = Gu(p), Xu) try {
            return Pa(h, p);
          } catch {
          }
          if (Ju(h, p)) return Ku(!zu(Vu.f, h, p), h[p]);
        };
      });
      var va = E((rm, Ta) => {
        var Yu = ye(), Qu = ie();
        Ta.exports = Yu && Qu(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Lt = E((im, Ea) => {
        var Zu = Ie(), ec = String, tc = TypeError;
        Ea.exports = function(l) {
          if (Zu(l)) return l;
          throw tc(ec(l) + " is not an object");
        };
      });
      var et = E((ba) => {
        var sc = ye(), rc = Ls(), ic = va(), Ot = Lt(), Ca = Ds(), ac = TypeError, Bs = Object.defineProperty, nc = Object.getOwnPropertyDescriptor, Ms = "enumerable", _s = "configurable", Rs = "writable";
        ba.f = sc ? ic ? function(h, p, d) {
          if (Ot(h), p = Ca(p), Ot(d), typeof h == "function" && p === "prototype" && "value" in d && Rs in d && !d[Rs]) {
            var x = nc(h, p);
            x && x[Rs] && (h[p] = d.value, d = { configurable: _s in d ? d[_s] : x[_s], enumerable: Ms in d ? d[Ms] : x[Ms], writable: false });
          }
          return Bs(h, p, d);
        } : Bs : function(h, p, d) {
          if (Ot(h), p = Ca(p), Ot(d), rc) try {
            return Bs(h, p, d);
          } catch {
          }
          if ("get" in d || "set" in d) throw ac("Accessors not supported");
          return "value" in d && (h[p] = d.value), h;
        };
      });
      var js = E((nm, Sa) => {
        var oc = ye(), lc = et(), hc = fs();
        Sa.exports = oc ? function(l, h, p) {
          return lc.f(l, h, hc(1, p));
        } : function(l, h, p) {
          return l[h] = p, l;
        };
      });
      var Na = E((om, Ia) => {
        var qs = ye(), uc = ve(), wa = Function.prototype, cc = qs && Object.getOwnPropertyDescriptor, Us = uc(wa, "name"), pc = Us && function() {
        }.name === "something", fc = Us && (!qs || qs && cc(wa, "name").configurable);
        Ia.exports = { EXISTS: Us, PROPER: pc, CONFIGURABLE: fc };
      });
      var Hs = E((lm, ka) => {
        var dc = ae(), mc = ee(), $s = Ft(), yc = dc(Function.toString);
        mc($s.inspectSource) || ($s.inspectSource = function(l) {
          return yc(l);
        });
        ka.exports = $s.inspectSource;
      });
      var La = E((hm, Fa) => {
        var xc = re(), gc = ee(), Da = xc.WeakMap;
        Fa.exports = gc(Da) && /native code/.test(String(Da));
      });
      var Ma = E((um, Ba) => {
        var Pc = Is(), Ac = ks(), Oa = Pc("keys");
        Ba.exports = function(l) {
          return Oa[l] || (Oa[l] = Ac(l));
        };
      });
      var zs = E((cm, _a) => {
        _a.exports = {};
      });
      var Ua = E((pm, qa) => {
        var Tc = La(), ja = re(), vc = Ie(), Ec = js(), Vs = ve(), Ks = Ft(), Cc = Ma(), bc = zs(), Ra = "Object already initialized", Ws = ja.TypeError, Sc = ja.WeakMap, Bt, tt, Mt, wc = function(l) {
          return Mt(l) ? tt(l) : Bt(l, {});
        }, Ic = function(l) {
          return function(h) {
            var p;
            if (!vc(h) || (p = tt(h)).type !== l) throw Ws("Incompatible receiver, " + l + " required");
            return p;
          };
        };
        Tc || Ks.state ? (oe = Ks.state || (Ks.state = new Sc()), oe.get = oe.get, oe.has = oe.has, oe.set = oe.set, Bt = function(l, h) {
          if (oe.has(l)) throw Ws(Ra);
          return h.facade = l, oe.set(l, h), h;
        }, tt = function(l) {
          return oe.get(l) || {};
        }, Mt = function(l) {
          return oe.has(l);
        }) : (ke = Cc("state"), bc[ke] = true, Bt = function(l, h) {
          if (Vs(l, ke)) throw Ws(Ra);
          return h.facade = l, Ec(l, ke, h), h;
        }, tt = function(l) {
          return Vs(l, ke) ? l[ke] : {};
        }, Mt = function(l) {
          return Vs(l, ke);
        });
        var oe, ke;
        qa.exports = { set: Bt, get: tt, has: Mt, enforce: wc, getterFor: Ic };
      });
      var Js = E((fm, Ha) => {
        var Nc = ie(), kc = ee(), _t = ve(), Gs = ye(), Dc = Na().CONFIGURABLE, Fc = Hs(), $a = Ua(), Lc = $a.enforce, Oc = $a.get, Rt = Object.defineProperty, Bc = Gs && !Nc(function() {
          return Rt(function() {
          }, "length", { value: 8 }).length !== 8;
        }), Mc = String(String).split("String"), _c = Ha.exports = function(l, h, p) {
          String(h).slice(0, 7) === "Symbol(" && (h = "[" + String(h).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), p && p.getter && (h = "get " + h), p && p.setter && (h = "set " + h), (!_t(l, "name") || Dc && l.name !== h) && (Gs ? Rt(l, "name", { value: h, configurable: true }) : l.name = h), Bc && p && _t(p, "arity") && l.length !== p.arity && Rt(l, "length", { value: p.arity });
          try {
            p && _t(p, "constructor") && p.constructor ? Gs && Rt(l, "prototype", { writable: false }) : l.prototype && (l.prototype = void 0);
          } catch {
          }
          var d = Lc(l);
          return _t(d, "source") || (d.source = Mc.join(typeof h == "string" ? h : "")), l;
        };
        Function.prototype.toString = _c(function() {
          return kc(this) && Oc(this).source || Fc(this);
        }, "toString");
      });
      var Va = E((dm, za) => {
        var Rc = ee(), jc = et(), qc = Js(), Uc = Dt();
        za.exports = function(l, h, p, d) {
          d || (d = {});
          var x = d.enumerable, P = d.name !== void 0 ? d.name : h;
          if (Rc(p) && qc(p, P, d), d.global) x ? l[h] = p : Uc(h, p);
          else {
            try {
              d.unsafe ? l[h] && (x = true) : delete l[h];
            } catch {
            }
            x ? l[h] = p : jc.f(l, h, { value: p, enumerable: false, configurable: !d.nonConfigurable, writable: !d.nonWritable });
          }
          return l;
        };
      });
      var Wa = E((mm, Ka) => {
        var $c = Math.ceil, Hc = Math.floor;
        Ka.exports = Math.trunc || function(h) {
          var p = +h;
          return (p > 0 ? Hc : $c)(p);
        };
      });
      var Xs = E((ym, Ga) => {
        var zc = Wa();
        Ga.exports = function(l) {
          var h = +l;
          return h !== h || h === 0 ? 0 : zc(h);
        };
      });
      var Xa = E((xm, Ja) => {
        var Vc = Xs(), Kc = Math.max, Wc = Math.min;
        Ja.exports = function(l, h) {
          var p = Vc(l);
          return p < 0 ? Kc(p + h, 0) : Wc(p, h);
        };
      });
      var Qa = E((gm, Ya) => {
        var Gc = Xs(), Jc = Math.min;
        Ya.exports = function(l) {
          return l > 0 ? Jc(Gc(l), 9007199254740991) : 0;
        };
      });
      var jt = E((Pm, Za) => {
        var Xc = Qa();
        Za.exports = function(l) {
          return Xc(l.length);
        };
      });
      var sn = E((Am, tn) => {
        var Yc = It(), Qc = Xa(), Zc = jt(), en = function(l) {
          return function(h, p, d) {
            var x = Yc(h), P = Zc(x), m = Qc(d, P), v;
            if (l && p != p) {
              for (; P > m; ) if (v = x[m++], v != v) return true;
            } else for (; P > m; m++) if ((l || m in x) && x[m] === p) return l || m || 0;
            return !l && -1;
          };
        };
        tn.exports = { includes: en(true), indexOf: en(false) };
      });
      var nn = E((Tm, an) => {
        var ep = ae(), Ys = ve(), tp = It(), sp = sn().indexOf, rp = zs(), rn = ep([].push);
        an.exports = function(l, h) {
          var p = tp(l), d = 0, x = [], P;
          for (P in p) !Ys(rp, P) && Ys(p, P) && rn(x, P);
          for (; h.length > d; ) Ys(p, P = h[d++]) && (~sp(x, P) || rn(x, P));
          return x;
        };
      });
      var ln = E((vm, on) => {
        on.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var un = E((hn) => {
        var ip = nn(), ap = ln(), np = ap.concat("length", "prototype");
        hn.f = Object.getOwnPropertyNames || function(h) {
          return ip(h, np);
        };
      });
      var pn = E((cn) => {
        cn.f = Object.getOwnPropertySymbols;
      });
      var dn = E((bm, fn) => {
        var op = Qe(), lp = ae(), hp = un(), up = pn(), cp = Lt(), pp = lp([].concat);
        fn.exports = op("Reflect", "ownKeys") || function(h) {
          var p = hp.f(cp(h)), d = up.f;
          return d ? pp(p, d(h)) : p;
        };
      });
      var xn = E((Sm, yn) => {
        var mn = ve(), fp = dn(), dp = Os(), mp = et();
        yn.exports = function(l, h, p) {
          for (var d = fp(h), x = mp.f, P = dp.f, m = 0; m < d.length; m++) {
            var v = d[m];
            !mn(l, v) && !(p && mn(p, v)) && x(l, v, P(h, v));
          }
        };
      });
      var Pn = E((wm, gn) => {
        var yp = ie(), xp = ee(), gp = /#|\.prototype\./, st = function(l, h) {
          var p = Ap[Pp(l)];
          return p == vp ? true : p == Tp ? false : xp(h) ? yp(h) : !!h;
        }, Pp = st.normalize = function(l) {
          return String(l).replace(gp, ".").toLowerCase();
        }, Ap = st.data = {}, Tp = st.NATIVE = "N", vp = st.POLYFILL = "P";
        gn.exports = st;
      });
      var Zs = E((Im, An) => {
        var Qs = re(), Ep = Os().f, Cp = js(), bp = Va(), Sp = Dt(), wp = xn(), Ip = Pn();
        An.exports = function(l, h) {
          var p = l.target, d = l.global, x = l.stat, P, m, v, S, k, F;
          if (d ? m = Qs : x ? m = Qs[p] || Sp(p, {}) : m = (Qs[p] || {}).prototype, m) for (v in h) {
            if (k = h[v], l.dontCallGetSet ? (F = Ep(m, v), S = F && F.value) : S = m[v], P = Ip(d ? v : p + (x ? "." : "#") + v, l.forced), !P && S !== void 0) {
              if (typeof k == typeof S) continue;
              wp(k, S);
            }
            (l.sham || S && S.sham) && Cp(k, "sham", true), bp(m, v, k, l);
          }
        };
      });
      var Tn = E(() => {
        var Np = Zs(), er = re();
        Np({ global: true, forced: er.globalThis !== er }, { globalThis: er });
      });
      var vn = E(() => {
        Tn();
      });
      var bn = E((Lm, Cn) => {
        var En = Js(), kp = et();
        Cn.exports = function(l, h, p) {
          return p.get && En(p.get, h, { getter: true }), p.set && En(p.set, h, { setter: true }), kp.f(l, h, p);
        };
      });
      var wn = E((Om, Sn) => {
        var Dp = Lt();
        Sn.exports = function() {
          var l = Dp(this), h = "";
          return l.hasIndices && (h += "d"), l.global && (h += "g"), l.ignoreCase && (h += "i"), l.multiline && (h += "m"), l.dotAll && (h += "s"), l.unicode && (h += "u"), l.unicodeSets && (h += "v"), l.sticky && (h += "y"), h;
        };
      });
      var kn = E(() => {
        var Fp = re(), Lp = ye(), Op = bn(), Bp = wn(), Mp = ie(), In = Fp.RegExp, Nn = In.prototype, _p = Lp && Mp(function() {
          var l = true;
          try {
            In(".", "d");
          } catch {
            l = false;
          }
          var h = {}, p = "", d = l ? "dgimsy" : "gimsy", x = function(S, k) {
            Object.defineProperty(h, S, { get: function() {
              return p += k, true;
            } });
          }, P = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
          l && (P.hasIndices = "d");
          for (var m in P) x(m, P[m]);
          var v = Object.getOwnPropertyDescriptor(Nn, "flags").get.call(h);
          return v !== d || p !== d;
        });
        _p && Op(Nn, "flags", { configurable: true, get: Bp });
      });
      var tr = E((_m, Dn) => {
        var Rp = Ye();
        Dn.exports = Array.isArray || function(h) {
          return Rp(h) == "Array";
        };
      });
      var Ln = E((Rm, Fn) => {
        var jp = TypeError, qp = 9007199254740991;
        Fn.exports = function(l) {
          if (l > qp) throw jp("Maximum allowed index exceeded");
          return l;
        };
      });
      var Bn = E((jm, On) => {
        var Up = Ye(), $p = ae();
        On.exports = function(l) {
          if (Up(l) === "Function") return $p(l);
        };
      });
      var Rn = E((qm, _n) => {
        var Mn = Bn(), Hp = kt(), zp = bt(), Vp = Mn(Mn.bind);
        _n.exports = function(l, h) {
          return Hp(l), h === void 0 ? l : zp ? Vp(l, h) : function() {
            return l.apply(h, arguments);
          };
        };
      });
      var Un = E((Um, qn) => {
        var Kp = tr(), Wp = jt(), Gp = Ln(), Jp = Rn(), jn = function(l, h, p, d, x, P, m, v) {
          for (var S = x, k = 0, F = m ? Jp(m, v) : false, w, L; k < d; ) k in p && (w = F ? F(p[k], k, h) : p[k], P > 0 && Kp(w) ? (L = Wp(w), S = jn(l, h, w, L, S, P - 1) - 1) : (Gp(S + 1), l[S] = w), S++), k++;
          return S;
        };
        qn.exports = jn;
      });
      var zn = E(($m, Hn) => {
        var Xp = Ze(), Yp = Xp("toStringTag"), $n = {};
        $n[Yp] = "z";
        Hn.exports = String($n) === "[object z]";
      });
      var Kn = E((Hm, Vn) => {
        var Qp = zn(), Zp = ee(), qt = Ye(), ef = Ze(), tf = ef("toStringTag"), sf = Object, rf = qt(/* @__PURE__ */ (function() {
          return arguments;
        })()) == "Arguments", af = function(l, h) {
          try {
            return l[h];
          } catch {
          }
        };
        Vn.exports = Qp ? qt : function(l) {
          var h, p, d;
          return l === void 0 ? "Undefined" : l === null ? "Null" : typeof (p = af(h = sf(l), tf)) == "string" ? p : rf ? qt(h) : (d = qt(h)) == "Object" && Zp(h.callee) ? "Arguments" : d;
        };
      });
      var Qn = E((zm, Yn) => {
        var nf = ae(), of = ie(), Wn = ee(), lf = Kn(), hf = Qe(), uf = Hs(), Gn = function() {
        }, cf = [], Jn = hf("Reflect", "construct"), sr = /^\s*(?:class|function)\b/, pf = nf(sr.exec), ff = !sr.exec(Gn), rt = function(h) {
          if (!Wn(h)) return false;
          try {
            return Jn(Gn, cf, h), true;
          } catch {
            return false;
          }
        }, Xn = function(h) {
          if (!Wn(h)) return false;
          switch (lf(h)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return ff || !!pf(sr, uf(h));
          } catch {
            return true;
          }
        };
        Xn.sham = true;
        Yn.exports = !Jn || of(function() {
          var l;
          return rt(rt.call) || !rt(Object) || !rt(function() {
            l = true;
          }) || l;
        }) ? Xn : rt;
      });
      var so = E((Vm, to) => {
        var Zn = tr(), df = Qn(), mf = Ie(), yf = Ze(), xf = yf("species"), eo = Array;
        to.exports = function(l) {
          var h;
          return Zn(l) && (h = l.constructor, df(h) && (h === eo || Zn(h.prototype)) ? h = void 0 : mf(h) && (h = h[xf], h === null && (h = void 0))), h === void 0 ? eo : h;
        };
      });
      var io = E((Km, ro) => {
        var gf = so();
        ro.exports = function(l, h) {
          return new (gf(l))(h === 0 ? 0 : h);
        };
      });
      var ao = E(() => {
        var Pf = Zs(), Af = Un(), Tf = kt(), vf = Ns(), Ef = jt(), Cf = io();
        Pf({ target: "Array", proto: true }, { flatMap: function(h) {
          var p = vf(this), d = Ef(p), x;
          return Tf(h), x = Cf(p, 0), x.length = Af(x, p, p, d, 0, 1, h, arguments.length > 1 ? arguments[1] : void 0), x;
        } });
      });
      var md = E((ty, Oo) => {
        vn();
        kn();
        ao();
        var nr = Object.defineProperty, bf = Object.getOwnPropertyDescriptor, or = Object.getOwnPropertyNames, Sf = Object.prototype.hasOwnProperty, co = (l, h) => function() {
          return l && (h = (0, l[or(l)[0]])(l = 0)), h;
        }, $ = (l, h) => function() {
          return h || (0, l[or(l)[0]])((h = { exports: {} }).exports, h), h.exports;
        }, wf = (l, h) => {
          for (var p in h) nr(l, p, { get: h[p], enumerable: true });
        }, If = (l, h, p, d) => {
          if (h && typeof h == "object" || typeof h == "function") for (let x of or(h)) !Sf.call(l, x) && x !== p && nr(l, x, { get: () => h[x], enumerable: !(d = bf(h, x)) || d.enumerable });
          return l;
        }, Nf = (l) => If(nr({}, "__esModule", { value: true }), l), U = co({ "<define:process>"() {
        } }), kf = $({ "src/utils/try-combinations.js"(l, h) {
          U();
          function p() {
            let d;
            for (var x = arguments.length, P = new Array(x), m = 0; m < x; m++) P[m] = arguments[m];
            for (let [v, S] of P.entries()) try {
              return { result: S() };
            } catch (k) {
              v === 0 && (d = k);
            }
            return { error: d };
          }
          h.exports = p;
        } }), po = $({ "src/language-js/utils/get-shebang.js"(l, h) {
          U();
          function p(d) {
            if (!d.startsWith("#!")) return "";
            let x = d.indexOf(`
`);
            return x === -1 ? d : d.slice(0, x);
          }
          h.exports = p;
        } }), Df = $({ "src/utils/text/skip-inline-comment.js"(l, h) {
          U();
          function p(d, x) {
            if (x === false) return false;
            if (d.charAt(x) === "/" && d.charAt(x + 1) === "*") {
              for (let P = x + 2; P < d.length; ++P) if (d.charAt(P) === "*" && d.charAt(P + 1) === "/") return P + 2;
            }
            return x;
          }
          h.exports = p;
        } }), Ff = $({ "src/utils/text/skip-newline.js"(l, h) {
          U();
          function p(d, x, P) {
            let m = P && P.backwards;
            if (x === false) return false;
            let v = d.charAt(x);
            if (m) {
              if (d.charAt(x - 1) === "\r" && v === `
`) return x - 2;
              if (v === `
` || v === "\r" || v === "\u2028" || v === "\u2029") return x - 1;
            } else {
              if (v === "\r" && d.charAt(x + 1) === `
`) return x + 2;
              if (v === `
` || v === "\r" || v === "\u2028" || v === "\u2029") return x + 1;
            }
            return x;
          }
          h.exports = p;
        } }), fo = $({ "src/utils/text/skip.js"(l, h) {
          U();
          function p(v) {
            return (S, k, F) => {
              let w = F && F.backwards;
              if (k === false) return false;
              let { length: L } = S, A = k;
              for (; A >= 0 && A < L; ) {
                let _ = S.charAt(A);
                if (v instanceof RegExp) {
                  if (!v.test(_)) return A;
                } else if (!v.includes(_)) return A;
                w ? A-- : A++;
              }
              return A === -1 || A === L ? A : false;
            };
          }
          var d = p(/\s/), x = p(" 	"), P = p(",; 	"), m = p(/[^\n\r]/);
          h.exports = { skipWhitespace: d, skipSpaces: x, skipToLineEnd: P, skipEverythingButNewLine: m };
        } }), Lf = $({ "src/utils/text/skip-trailing-comment.js"(l, h) {
          U();
          var { skipEverythingButNewLine: p } = fo();
          function d(x, P) {
            return P === false ? false : x.charAt(P) === "/" && x.charAt(P + 1) === "/" ? p(x, P) : P;
          }
          h.exports = d;
        } }), Of = $({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(l, h) {
          U();
          var p = Df(), d = Ff(), x = Lf(), { skipSpaces: P } = fo();
          function m(v, S) {
            let k = null, F = S;
            for (; F !== k; ) k = F, F = P(v, F), F = p(v, F), F = x(v, F), F = d(v, F);
            return F;
          }
          h.exports = m;
        } }), mo = {};
        wf(mo, { EOL: () => ar, arch: () => Bf, cpus: () => vo, default: () => wo, endianness: () => yo, freemem: () => Ao, getNetworkInterfaces: () => So, hostname: () => xo, loadavg: () => go2, networkInterfaces: () => bo, platform: () => Mf, release: () => Co, tmpDir: () => rr, tmpdir: () => ir, totalmem: () => To, type: () => Eo, uptime: () => Po });
        function yo() {
          if (typeof Ut > "u") {
            var l = new ArrayBuffer(2), h = new Uint8Array(l), p = new Uint16Array(l);
            if (h[0] = 1, h[1] = 2, p[0] === 258) Ut = "BE";
            else if (p[0] === 513) Ut = "LE";
            else throw new Error("unable to figure out endianess");
          }
          return Ut;
        }
        function xo() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function go2() {
          return [];
        }
        function Po() {
          return 0;
        }
        function Ao() {
          return Number.MAX_VALUE;
        }
        function To() {
          return Number.MAX_VALUE;
        }
        function vo() {
          return [];
        }
        function Eo() {
          return "Browser";
        }
        function Co() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function bo() {
        }
        function So() {
        }
        function Bf() {
          return "javascript";
        }
        function Mf() {
          return "browser";
        }
        function rr() {
          return "/tmp";
        }
        var Ut, ir, ar, wo, _f = co({ "node-modules-polyfills:os"() {
          U(), ir = rr, ar = `
`, wo = { EOL: ar, tmpdir: ir, tmpDir: rr, networkInterfaces: bo, getNetworkInterfaces: So, release: Co, type: Eo, cpus: vo, totalmem: To, freemem: Ao, uptime: Po, loadavg: go2, hostname: xo, endianness: yo };
        } }), Rf = $({ "node-modules-polyfills-commonjs:os"(l, h) {
          U();
          var p = (_f(), Nf(mo));
          if (p && p.default) {
            h.exports = p.default;
            for (let d in p) h.exports[d] = p[d];
          } else p && (h.exports = p);
        } }), jf = $({ "node_modules/detect-newline/index.js"(l, h) {
          U();
          var p = (d) => {
            if (typeof d != "string") throw new TypeError("Expected a string");
            let x = d.match(/(?:\r?\n)/g) || [];
            if (x.length === 0) return;
            let P = x.filter((v) => v === `\r
`).length, m = x.length - P;
            return P > m ? `\r
` : `
`;
          };
          h.exports = p, h.exports.graceful = (d) => typeof d == "string" && p(d) || `
`;
        } }), qf = $({ "node_modules/jest-docblock/build/index.js"(l) {
          U(), Object.defineProperty(l, "__esModule", { value: true }), l.extract = A, l.parse = G, l.parseWithComments = N, l.print = O, l.strip = _;
          function h() {
            let R = Rf();
            return h = function() {
              return R;
            }, R;
          }
          function p() {
            let R = d(jf());
            return p = function() {
              return R;
            }, R;
          }
          function d(R) {
            return R && R.__esModule ? R : { default: R };
          }
          var x = /\*\/$/, P = /^\/\*\*?/, m = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, v = /(^|\s+)\/\/([^\r\n]*)/g, S = /^(\r?\n)+/, k = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, F = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, w = /(\r?\n|^) *\* ?/g, L = [];
          function A(R) {
            let z = R.match(m);
            return z ? z[0].trimLeft() : "";
          }
          function _(R) {
            let z = R.match(m);
            return z && z[0] ? R.substring(z[0].length) : R;
          }
          function G(R) {
            return N(R).pragmas;
          }
          function N(R) {
            let z = (0, p().default)(R) || h().EOL;
            R = R.replace(P, "").replace(x, "").replace(w, "$1");
            let Q = "";
            for (; Q !== R; ) Q = R, R = R.replace(k, `${z}$1 $2${z}`);
            R = R.replace(S, "").trimRight();
            let b = /* @__PURE__ */ Object.create(null), B = R.replace(F, "").replace(S, "").trimRight(), Z;
            for (; Z = F.exec(R); ) {
              let q = Z[2].replace(v, "");
              typeof b[Z[1]] == "string" || Array.isArray(b[Z[1]]) ? b[Z[1]] = L.concat(b[Z[1]], q) : b[Z[1]] = q;
            }
            return { comments: B, pragmas: b };
          }
          function O(R) {
            let { comments: z = "", pragmas: Q = {} } = R, b = (0, p().default)(z) || h().EOL, B = "/**", Z = " *", q = " */", ue = Object.keys(Q), te = ue.map((se) => H(se, Q[se])).reduce((se, He) => se.concat(He), []).map((se) => `${Z} ${se}${b}`).join("");
            if (!z) {
              if (ue.length === 0) return "";
              if (ue.length === 1 && !Array.isArray(Q[ue[0]])) {
                let se = Q[ue[0]];
                return `${B} ${H(ue[0], se)[0]}${q}`;
              }
            }
            let it = z.split(b).map((se) => `${Z} ${se}`).join(b) + b;
            return B + b + (z ? it : "") + (z && ue.length ? Z + b : "") + te + q;
          }
          function H(R, z) {
            return L.concat(z).map((Q) => `@${R} ${Q}`.trim());
          }
        } }), Uf = $({ "src/common/end-of-line.js"(l, h) {
          U();
          function p(m) {
            let v = m.indexOf("\r");
            return v >= 0 ? m.charAt(v + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function d(m) {
            switch (m) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function x(m, v) {
            let S;
            switch (v) {
              case `
`:
                S = /\n/g;
                break;
              case "\r":
                S = /\r/g;
                break;
              case `\r
`:
                S = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(v)}.`);
            }
            let k = m.match(S);
            return k ? k.length : 0;
          }
          function P(m) {
            return m.replace(/\r\n?/g, `
`);
          }
          h.exports = { guessEndOfLine: p, convertEndOfLineToChars: d, countEndOfLineChars: x, normalizeEndOfLine: P };
        } }), $f = $({ "src/language-js/pragma.js"(l, h) {
          U();
          var { parseWithComments: p, strip: d, extract: x, print: P } = qf(), { normalizeEndOfLine: m } = Uf(), v = po();
          function S(w) {
            let L = v(w);
            L && (w = w.slice(L.length + 1));
            let A = x(w), { pragmas: _, comments: G } = p(A);
            return { shebang: L, text: w, pragmas: _, comments: G };
          }
          function k(w) {
            let L = Object.keys(S(w).pragmas);
            return L.includes("prettier") || L.includes("format");
          }
          function F(w) {
            let { shebang: L, text: A, pragmas: _, comments: G } = S(w), N = d(A), O = P({ pragmas: Object.assign({ format: "" }, _), comments: G.trimStart() });
            return (L ? `${L}
` : "") + m(O) + (N.startsWith(`
`) ? `
` : `

`) + N;
          }
          h.exports = { hasPragma: k, insertPragma: F };
        } }), Io = $({ "src/utils/is-non-empty-array.js"(l, h) {
          U();
          function p(d) {
            return Array.isArray(d) && d.length > 0;
          }
          h.exports = p;
        } }), No = $({ "src/language-js/loc.js"(l, h) {
          U();
          var p = Io();
          function d(S) {
            var k, F;
            let w = S.range ? S.range[0] : S.start, L = (k = (F = S.declaration) === null || F === void 0 ? void 0 : F.decorators) !== null && k !== void 0 ? k : S.decorators;
            return p(L) ? Math.min(d(L[0]), w) : w;
          }
          function x(S) {
            return S.range ? S.range[1] : S.end;
          }
          function P(S, k) {
            let F = d(S);
            return Number.isInteger(F) && F === d(k);
          }
          function m(S, k) {
            let F = x(S);
            return Number.isInteger(F) && F === x(k);
          }
          function v(S, k) {
            return P(S, k) && m(S, k);
          }
          h.exports = { locStart: d, locEnd: x, hasSameLocStart: P, hasSameLoc: v };
        } }), ko = $({ "src/language-js/parse/utils/create-parser.js"(l, h) {
          U();
          var { hasPragma: p } = $f(), { locStart: d, locEnd: x } = No();
          function P(m) {
            return m = typeof m == "function" ? { parse: m } : m, Object.assign({ astFormat: "estree", hasPragma: p, locStart: d, locEnd: x }, m);
          }
          h.exports = P;
        } }), lr = $({ "src/common/parser-create-error.js"(l, h) {
          U();
          function p(d, x) {
            let P = new SyntaxError(d + " (" + x.start.line + ":" + x.start.column + ")");
            return P.loc = x, P;
          }
          h.exports = p;
        } }), Do = $({ "src/language-js/parse/utils/create-babel-parse-error.js"(l, h) {
          U();
          var p = lr();
          function d(x) {
            let { message: P, loc: m } = x;
            return p(P.replace(/ \(.*\)/, ""), { start: { line: m ? m.line : 0, column: m ? m.column + 1 : 0 } });
          }
          h.exports = d;
        } }), Hf = $({ "src/language-js/utils/is-ts-keyword-type.js"(l, h) {
          U();
          function p(d) {
            let { type: x } = d;
            return x.startsWith("TS") && x.endsWith("Keyword");
          }
          h.exports = p;
        } }), zf = $({ "src/language-js/utils/is-block-comment.js"(l, h) {
          U();
          var p = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), d = (x) => p.has(x == null ? void 0 : x.type);
          h.exports = d;
        } }), Vf = $({ "src/language-js/utils/is-type-cast-comment.js"(l, h) {
          U();
          var p = zf();
          function d(x) {
            return p(x) && x.value[0] === "*" && /@(?:type|satisfies)\b/.test(x.value);
          }
          h.exports = d;
        } }), Kf = $({ "src/utils/get-last.js"(l, h) {
          U();
          var p = (d) => d[d.length - 1];
          h.exports = p;
        } }), Wf = $({ "src/language-js/parse/postprocess/visit-node.js"(l, h) {
          U();
          function p(d, x) {
            if (Array.isArray(d)) {
              for (let P = 0; P < d.length; P++) d[P] = p(d[P], x);
              return d;
            }
            if (d && typeof d == "object" && typeof d.type == "string") {
              let P = Object.keys(d);
              for (let m = 0; m < P.length; m++) d[P[m]] = p(d[P[m]], x);
              return x(d) || d;
            }
            return d;
          }
          h.exports = p;
        } }), Gf = $({ "src/language-js/parse/postprocess/throw-syntax-error.js"(l, h) {
          U();
          var p = lr();
          function d(x, P) {
            let { start: m, end: v } = x.loc;
            throw p(P, { start: { line: m.line, column: m.column + 1 }, end: { line: v.line, column: v.column + 1 } });
          }
          h.exports = d;
        } }), Jf = $({ "src/language-js/parse/postprocess/index.js"(l, h) {
          U();
          var { locStart: p, locEnd: d } = No(), x = Hf(), P = Vf(), m = Kf(), v = Wf(), S = Gf();
          function k(A, _) {
            if (_.parser !== "typescript" && _.parser !== "flow" && _.parser !== "acorn" && _.parser !== "espree" && _.parser !== "meriyah") {
              let N = /* @__PURE__ */ new Set();
              A = v(A, (O) => {
                O.leadingComments && O.leadingComments.some(P) && N.add(p(O));
              }), A = v(A, (O) => {
                if (O.type === "ParenthesizedExpression") {
                  let { expression: H } = O;
                  if (H.type === "TypeCastExpression") return H.range = O.range, H;
                  let R = p(O);
                  if (!N.has(R)) return H.extra = Object.assign(Object.assign({}, H.extra), {}, { parenthesized: true }), H;
                }
              });
            }
            return A = v(A, (N) => {
              switch (N.type) {
                case "ChainExpression":
                  return F(N.expression);
                case "LogicalExpression": {
                  if (w(N)) return L(N);
                  break;
                }
                case "VariableDeclaration": {
                  let O = m(N.declarations);
                  O && O.init && G(N, O);
                  break;
                }
                case "TSParenthesizedType":
                  return x(N.typeAnnotation) || N.typeAnnotation.type === "TSThisType" || (N.typeAnnotation.range = [p(N), d(N)]), N.typeAnnotation;
                case "TSTypeParameter":
                  if (typeof N.name == "string") {
                    let O = p(N);
                    N.name = { type: "Identifier", name: N.name, range: [O, O + N.name.length] };
                  }
                  break;
                case "ObjectExpression":
                  if (_.parser === "typescript") {
                    let O = N.properties.find((H) => H.type === "Property" && H.value.type === "TSEmptyBodyFunctionExpression");
                    O && S(O.value, "Unexpected token.");
                  }
                  break;
                case "SequenceExpression": {
                  let O = m(N.expressions);
                  N.range = [p(N), Math.min(d(O), d(N))];
                  break;
                }
                case "TopicReference":
                  _.__isUsingHackPipeline = true;
                  break;
                case "ExportAllDeclaration": {
                  let { exported: O } = N;
                  if (_.parser === "meriyah" && O && O.type === "Identifier") {
                    let H = _.originalText.slice(p(O), d(O));
                    (H.startsWith('"') || H.startsWith("'")) && (N.exported = Object.assign(Object.assign({}, N.exported), {}, { type: "Literal", value: N.exported.name, raw: H }));
                  }
                  break;
                }
                case "PropertyDefinition":
                  if (_.parser === "meriyah" && N.static && !N.computed && !N.key) {
                    let O = "static", H = p(N);
                    Object.assign(N, { static: false, key: { type: "Identifier", name: O, range: [H, H + O.length] } });
                  }
                  break;
              }
            }), A;
            function G(N, O) {
              _.originalText[d(O)] !== ";" && (N.range = [p(N), d(O)]);
            }
          }
          function F(A) {
            switch (A.type) {
              case "CallExpression":
                A.type = "OptionalCallExpression", A.callee = F(A.callee);
                break;
              case "MemberExpression":
                A.type = "OptionalMemberExpression", A.object = F(A.object);
                break;
              case "TSNonNullExpression":
                A.expression = F(A.expression);
                break;
            }
            return A;
          }
          function w(A) {
            return A.type === "LogicalExpression" && A.right.type === "LogicalExpression" && A.operator === A.right.operator;
          }
          function L(A) {
            return w(A) ? L({ type: "LogicalExpression", operator: A.operator, left: L({ type: "LogicalExpression", operator: A.operator, left: A.left, right: A.right.left, range: [p(A.left), d(A.right.left)] }), right: A.right.right, range: [p(A), d(A)] }) : A;
          }
          h.exports = k;
        } }), Fo = $({ "node_modules/@babel/parser/lib/index.js"(l) {
          U(), Object.defineProperty(l, "__esModule", { value: true });
          var h = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
          function p(t) {
            if (t && t.annexB != null && t.annexB !== false) throw new Error("The `annexB` option can only be set to `false`.");
            let r2 = {};
            for (let e of Object.keys(h)) r2[e] = t && t[e] != null ? t[e] : h[e];
            return r2;
          }
          var d = class {
            constructor(t, r2) {
              this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r2;
            }
          }, x = { brace: new d("{"), j_oTag: new d("<tag"), j_cTag: new d("</tag"), j_expr: new d("<tag>...</tag>", true) };
          x.template = new d("`", true);
          var P = true, m = true, v = true, S = true, k = true, F = true, w = class {
            constructor(t) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r2.keyword, this.beforeExpr = !!r2.beforeExpr, this.startsExpr = !!r2.startsExpr, this.rightAssociative = !!r2.rightAssociative, this.isLoop = !!r2.isLoop, this.isAssign = !!r2.isAssign, this.prefix = !!r2.prefix, this.postfix = !!r2.postfix, this.binop = r2.binop != null ? r2.binop : null, this.updateContext = null;
            }
          }, L = /* @__PURE__ */ new Map();
          function A(t) {
            let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            r2.keyword = t;
            let e = b(t, r2);
            return L.set(t, e), e;
          }
          function _(t, r2) {
            return b(t, { beforeExpr: P, binop: r2 });
          }
          var G = -1, N = [], O = [], H = [], R = [], z = [], Q = [];
          function b(t) {
            let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var e, s, i, a;
            return ++G, O.push(t), H.push((e = r2.binop) != null ? e : -1), R.push((s = r2.beforeExpr) != null ? s : false), z.push((i = r2.startsExpr) != null ? i : false), Q.push((a = r2.prefix) != null ? a : false), N.push(new w(t, r2)), G;
          }
          function B(t) {
            let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var e, s, i, a;
            return ++G, L.set(t, G), O.push(t), H.push((e = r2.binop) != null ? e : -1), R.push((s = r2.beforeExpr) != null ? s : false), z.push((i = r2.startsExpr) != null ? i : false), Q.push((a = r2.prefix) != null ? a : false), N.push(new w("name", r2)), G;
          }
          var Z = { bracketL: b("[", { beforeExpr: P, startsExpr: m }), bracketHashL: b("#[", { beforeExpr: P, startsExpr: m }), bracketBarL: b("[|", { beforeExpr: P, startsExpr: m }), bracketR: b("]"), bracketBarR: b("|]"), braceL: b("{", { beforeExpr: P, startsExpr: m }), braceBarL: b("{|", { beforeExpr: P, startsExpr: m }), braceHashL: b("#{", { beforeExpr: P, startsExpr: m }), braceR: b("}"), braceBarR: b("|}"), parenL: b("(", { beforeExpr: P, startsExpr: m }), parenR: b(")"), comma: b(",", { beforeExpr: P }), semi: b(";", { beforeExpr: P }), colon: b(":", { beforeExpr: P }), doubleColon: b("::", { beforeExpr: P }), dot: b("."), question: b("?", { beforeExpr: P }), questionDot: b("?."), arrow: b("=>", { beforeExpr: P }), template: b("template"), ellipsis: b("...", { beforeExpr: P }), backQuote: b("`", { startsExpr: m }), dollarBraceL: b("${", { beforeExpr: P, startsExpr: m }), templateTail: b("...`", { startsExpr: m }), templateNonTail: b("...${", { beforeExpr: P, startsExpr: m }), at: b("@"), hash: b("#", { startsExpr: m }), interpreterDirective: b("#!..."), eq: b("=", { beforeExpr: P, isAssign: S }), assign: b("_=", { beforeExpr: P, isAssign: S }), slashAssign: b("_=", { beforeExpr: P, isAssign: S }), xorAssign: b("_=", { beforeExpr: P, isAssign: S }), moduloAssign: b("_=", { beforeExpr: P, isAssign: S }), incDec: b("++/--", { prefix: k, postfix: F, startsExpr: m }), bang: b("!", { beforeExpr: P, prefix: k, startsExpr: m }), tilde: b("~", { beforeExpr: P, prefix: k, startsExpr: m }), doubleCaret: b("^^", { startsExpr: m }), doubleAt: b("@@", { startsExpr: m }), pipeline: _("|>", 0), nullishCoalescing: _("??", 1), logicalOR: _("||", 1), logicalAND: _("&&", 2), bitwiseOR: _("|", 3), bitwiseXOR: _("^", 4), bitwiseAND: _("&", 5), equality: _("==/!=/===/!==", 6), lt: _("</>/<=/>=", 7), gt: _("</>/<=/>=", 7), relational: _("</>/<=/>=", 7), bitShift: _("<</>>/>>>", 8), bitShiftL: _("<</>>/>>>", 8), bitShiftR: _("<</>>/>>>", 8), plusMin: b("+/-", { beforeExpr: P, binop: 9, prefix: k, startsExpr: m }), modulo: b("%", { binop: 10, startsExpr: m }), star: b("*", { binop: 10 }), slash: _("/", 10), exponent: b("**", { beforeExpr: P, binop: 11, rightAssociative: true }), _in: A("in", { beforeExpr: P, binop: 7 }), _instanceof: A("instanceof", { beforeExpr: P, binop: 7 }), _break: A("break"), _case: A("case", { beforeExpr: P }), _catch: A("catch"), _continue: A("continue"), _debugger: A("debugger"), _default: A("default", { beforeExpr: P }), _else: A("else", { beforeExpr: P }), _finally: A("finally"), _function: A("function", { startsExpr: m }), _if: A("if"), _return: A("return", { beforeExpr: P }), _switch: A("switch"), _throw: A("throw", { beforeExpr: P, prefix: k, startsExpr: m }), _try: A("try"), _var: A("var"), _const: A("const"), _with: A("with"), _new: A("new", { beforeExpr: P, startsExpr: m }), _this: A("this", { startsExpr: m }), _super: A("super", { startsExpr: m }), _class: A("class", { startsExpr: m }), _extends: A("extends", { beforeExpr: P }), _export: A("export"), _import: A("import", { startsExpr: m }), _null: A("null", { startsExpr: m }), _true: A("true", { startsExpr: m }), _false: A("false", { startsExpr: m }), _typeof: A("typeof", { beforeExpr: P, prefix: k, startsExpr: m }), _void: A("void", { beforeExpr: P, prefix: k, startsExpr: m }), _delete: A("delete", { beforeExpr: P, prefix: k, startsExpr: m }), _do: A("do", { isLoop: v, beforeExpr: P }), _for: A("for", { isLoop: v }), _while: A("while", { isLoop: v }), _as: B("as", { startsExpr: m }), _assert: B("assert", { startsExpr: m }), _async: B("async", { startsExpr: m }), _await: B("await", { startsExpr: m }), _from: B("from", { startsExpr: m }), _get: B("get", { startsExpr: m }), _let: B("let", { startsExpr: m }), _meta: B("meta", { startsExpr: m }), _of: B("of", { startsExpr: m }), _sent: B("sent", { startsExpr: m }), _set: B("set", { startsExpr: m }), _static: B("static", { startsExpr: m }), _using: B("using", { startsExpr: m }), _yield: B("yield", { startsExpr: m }), _asserts: B("asserts", { startsExpr: m }), _checks: B("checks", { startsExpr: m }), _exports: B("exports", { startsExpr: m }), _global: B("global", { startsExpr: m }), _implements: B("implements", { startsExpr: m }), _intrinsic: B("intrinsic", { startsExpr: m }), _infer: B("infer", { startsExpr: m }), _is: B("is", { startsExpr: m }), _mixins: B("mixins", { startsExpr: m }), _proto: B("proto", { startsExpr: m }), _require: B("require", { startsExpr: m }), _satisfies: B("satisfies", { startsExpr: m }), _keyof: B("keyof", { startsExpr: m }), _readonly: B("readonly", { startsExpr: m }), _unique: B("unique", { startsExpr: m }), _abstract: B("abstract", { startsExpr: m }), _declare: B("declare", { startsExpr: m }), _enum: B("enum", { startsExpr: m }), _module: B("module", { startsExpr: m }), _namespace: B("namespace", { startsExpr: m }), _interface: B("interface", { startsExpr: m }), _type: B("type", { startsExpr: m }), _opaque: B("opaque", { startsExpr: m }), name: b("name", { startsExpr: m }), string: b("string", { startsExpr: m }), num: b("num", { startsExpr: m }), bigint: b("bigint", { startsExpr: m }), decimal: b("decimal", { startsExpr: m }), regexp: b("regexp", { startsExpr: m }), privateName: b("#name", { startsExpr: m }), eof: b("eof"), jsxName: b("jsxName"), jsxText: b("jsxText", { beforeExpr: true }), jsxTagStart: b("jsxTagStart", { startsExpr: true }), jsxTagEnd: b("jsxTagEnd"), placeholder: b("%%", { startsExpr: true }) };
          function q(t) {
            return t >= 93 && t <= 130;
          }
          function ue(t) {
            return t <= 92;
          }
          function te(t) {
            return t >= 58 && t <= 130;
          }
          function it(t) {
            return t >= 58 && t <= 134;
          }
          function se(t) {
            return R[t];
          }
          function He(t) {
            return z[t];
          }
          function Bo(t) {
            return t >= 29 && t <= 33;
          }
          function hr(t) {
            return t >= 127 && t <= 129;
          }
          function Mo(t) {
            return t >= 90 && t <= 92;
          }
          function $t(t) {
            return t >= 58 && t <= 92;
          }
          function _o(t) {
            return t >= 39 && t <= 59;
          }
          function Ro(t) {
            return t === 34;
          }
          function jo(t) {
            return Q[t];
          }
          function qo(t) {
            return t >= 119 && t <= 121;
          }
          function Uo(t) {
            return t >= 122 && t <= 128;
          }
          function xe(t) {
            return O[t];
          }
          function at(t) {
            return H[t];
          }
          function $o(t) {
            return t === 57;
          }
          function nt(t) {
            return t >= 24 && t <= 25;
          }
          function ce(t) {
            return N[t];
          }
          N[8].updateContext = (t) => {
            t.pop();
          }, N[5].updateContext = N[7].updateContext = N[23].updateContext = (t) => {
            t.push(x.brace);
          }, N[22].updateContext = (t) => {
            t[t.length - 1] === x.template ? t.pop() : t.push(x.template);
          }, N[140].updateContext = (t) => {
            t.push(x.j_expr, x.j_oTag);
          };
          function ot(t, r2) {
            if (t == null) return {};
            var e = {}, s = Object.keys(t), i, a;
            for (a = 0; a < s.length; a++) i = s[a], !(r2.indexOf(i) >= 0) && (e[i] = t[i]);
            return e;
          }
          var ge = class {
            constructor(t, r2, e) {
              this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r2, this.index = e;
            }
          }, lt = class {
            constructor(t, r2) {
              this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r2;
            }
          };
          function Y(t, r2) {
            let { line: e, column: s, index: i } = t;
            return new ge(e, s + r2, i + r2);
          }
          var Ht = { SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }, Ho = function(t) {
            let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t.length - 1;
            return { get() {
              return t.reduce((e, s) => e[s], this);
            }, set(e) {
              t.reduce((s, i, a) => a === r2 ? s[i] = e : s[i], this);
            } };
          }, zo = (t, r2, e) => Object.keys(e).map((s) => [s, e[s]]).filter((s) => {
            let [, i] = s;
            return !!i;
          }).map((s) => {
            let [i, a] = s;
            return [i, typeof a == "function" ? { value: a, enumerable: false } : typeof a.reflect == "string" ? Object.assign({}, a, Ho(a.reflect.split("."))) : a];
          }).reduce((s, i) => {
            let [a, n] = i;
            return Object.defineProperty(s, a, Object.assign({ configurable: true }, n));
          }, Object.assign(new t(), r2)), Vo = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: Ht.SourceTypeModuleError }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: Ht.SourceTypeModuleError } }, ur = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, zt = (t) => {
            let { type: r2, prefix: e } = t;
            return r2 === "UpdateExpression" ? ur.UpdateExpression[String(e)] : ur[r2];
          }, Ko = { AccessorIsGenerator: (t) => {
            let { kind: r2 } = t;
            return `A ${r2}ter cannot be a generator.`;
          }, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitInUsingBinding: "'await' is not allowed to be used as a name in 'using' declarations.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: (t) => {
            let { kind: r2 } = t;
            return `Missing initializer in ${r2} declaration.`;
          }, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: (t) => {
            let { exportName: r2 } = t;
            return `\`${r2}\` has already been exported. Exported identifiers must be unique.`;
          }, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: (t) => {
            let { localName: r2, exportName: e } = t;
            return `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${r2}' as '${e}' } from 'some-module'\`?`;
          }, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: (t) => {
            let { type: r2 } = t;
            return `'${r2 === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`;
          }, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: (t) => {
            let { type: r2 } = t;
            return `Unsyntactic ${r2 === "BreakStatement" ? "break" : "continue"}.`;
          }, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: (t) => {
            let { importName: r2 } = t;
            return `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${r2}" as foo }\`?`;
          }, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: (t) => {
            let { maxArgumentCount: r2 } = t;
            return `\`import()\` requires exactly ${r2 === 1 ? "one argument" : "one or two arguments"}.`;
          }, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: (t) => {
            let { radix: r2 } = t;
            return `Expected number in radix ${r2}.`;
          }, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: (t) => {
            let { reservedWord: r2 } = t;
            return `Escape sequence in keyword ${r2}.`;
          }, InvalidIdentifier: (t) => {
            let { identifierName: r2 } = t;
            return `Invalid identifier ${r2}.`;
          }, InvalidLhs: (t) => {
            let { ancestor: r2 } = t;
            return `Invalid left-hand side in ${zt(r2)}.`;
          }, InvalidLhsBinding: (t) => {
            let { ancestor: r2 } = t;
            return `Binding invalid left-hand side in ${zt(r2)}.`;
          }, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: (t) => {
            let { unexpected: r2 } = t;
            return `Unexpected character '${r2}'.`;
          }, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: (t) => {
            let { identifierName: r2 } = t;
            return `Private name #${r2} is not defined.`;
          }, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: (t) => {
            let { labelName: r2 } = t;
            return `Label '${r2}' is already declared.`;
          }, LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: (t) => {
            let { missingPlugin: r2 } = t;
            return `This experimental syntax requires enabling the parser plugin: ${r2.map((e) => JSON.stringify(e)).join(", ")}.`;
          }, MissingOneOfPlugins: (t) => {
            let { missingPlugin: r2 } = t;
            return `This experimental syntax requires enabling one of the following parser plugin(s): ${r2.map((e) => JSON.stringify(e)).join(", ")}.`;
          }, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: (t) => {
            let { key: r2 } = t;
            return `Duplicate key "${r2}" is not allowed in module attributes.`;
          }, ModuleExportNameHasLoneSurrogate: (t) => {
            let { surrogateCharCode: r2 } = t;
            return `An export name cannot include a lone surrogate, found '\\u${r2.toString(16)}'.`;
          }, ModuleExportUndefined: (t) => {
            let { localName: r2 } = t;
            return `Export '${r2}' is not defined.`;
          }, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: (t) => {
            let { identifierName: r2 } = t;
            return `Private names are only allowed in property accesses (\`obj.#${r2}\`) or in \`in\` expressions (\`#${r2} in obj\`).`;
          }, PrivateNameRedeclaration: (t) => {
            let { identifierName: r2 } = t;
            return `Duplicate private name #${r2}.`;
          }, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: (t) => {
            let { keyword: r2 } = t;
            return `Unexpected keyword '${r2}'.`;
          }, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: (t) => {
            let { reservedWord: r2 } = t;
            return `Unexpected reserved word '${r2}'.`;
          }, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: (t) => {
            let { expected: r2, unexpected: e } = t;
            return `Unexpected token${e ? ` '${e}'.` : ""}${r2 ? `, expected "${r2}"` : ""}`;
          }, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: (t) => {
            let { target: r2, onlyValidPropertyName: e } = t;
            return `The only valid meta property for ${r2} is ${r2}.${e}.`;
          }, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: (t) => {
            let { identifierName: r2 } = t;
            return `Identifier '${r2}' has already been declared.`;
          }, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, Wo = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: (t) => {
            let { referenceName: r2 } = t;
            return `Assigning to '${r2}' in strict mode.`;
          }, StrictEvalArgumentsBinding: (t) => {
            let { bindingName: r2 } = t;
            return `Binding '${r2}' in strict mode.`;
          }, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, Go = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Jo = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: (t) => {
            let { token: r2 } = t;
            return `Invalid topic token ${r2}. In order to use ${r2} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${r2}" }.`;
          }, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: (t) => {
            let { type: r2 } = t;
            return `Hack-style pipe body cannot be an unparenthesized ${zt({ type: r2 })}; please wrap it in parentheses.`;
          }, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, Xo = ["toMessage"], Yo = ["message"];
          function Qo(t) {
            let { toMessage: r2 } = t, e = ot(t, Xo);
            return function s(i) {
              let { loc: a, details: n } = i;
              return zo(SyntaxError, Object.assign({}, e, { loc: a }), { clone() {
                let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = o.loc || {};
                return s({ loc: new ge("line" in u ? u.line : this.loc.line, "column" in u ? u.column : this.loc.column, "index" in u ? u.index : this.loc.index), details: Object.assign({}, this.details, o.details) });
              }, details: { value: n, enumerable: false }, message: { get() {
                return `${r2(this.details)} (${this.loc.line}:${this.loc.column})`;
              }, set(o) {
                Object.defineProperty(this, "message", { value: o });
              } }, pos: { reflect: "loc.index", enumerable: true }, missingPlugin: "missingPlugin" in n && { reflect: "details.missingPlugin", enumerable: true } });
            };
          }
          function pe(t, r2) {
            if (Array.isArray(t)) return (s) => pe(s, t[0]);
            let e = {};
            for (let s of Object.keys(t)) {
              let i = t[s], a = typeof i == "string" ? { message: () => i } : typeof i == "function" ? { message: i } : i, { message: n } = a, o = ot(a, Yo), u = typeof n == "string" ? () => n : n;
              e[s] = Qo(Object.assign({ code: Ht.SyntaxError, reasonCode: s, toMessage: u }, r2 ? { syntaxPlugin: r2 } : {}, o));
            }
            return e;
          }
          var f = Object.assign({}, pe(Vo), pe(Ko), pe(Wo), pe`pipelineOperator`(Jo)), { defineProperty: Zo } = Object, cr = (t, r2) => Zo(t, r2, { enumerable: false, value: t[r2] });
          function ze(t) {
            return t.loc.start && cr(t.loc.start, "index"), t.loc.end && cr(t.loc.end, "index"), t;
          }
          var el = (t) => class extends t {
            parse() {
              let e = ze(super.parse());
              return this.options.tokens && (e.tokens = e.tokens.map(ze)), e;
            }
            parseRegExpLiteral(e) {
              let { pattern: s, flags: i } = e, a = null;
              try {
                a = new RegExp(s, i);
              } catch {
              }
              let n = this.estreeParseLiteral(a);
              return n.regex = { pattern: s, flags: i }, n;
            }
            parseBigIntLiteral(e) {
              let s;
              try {
                s = BigInt(e);
              } catch {
                s = null;
              }
              let i = this.estreeParseLiteral(s);
              return i.bigint = String(i.value || e), i;
            }
            parseDecimalLiteral(e) {
              let i = this.estreeParseLiteral(null);
              return i.decimal = String(i.value || e), i;
            }
            estreeParseLiteral(e) {
              return this.parseLiteral(e, "Literal");
            }
            parseStringLiteral(e) {
              return this.estreeParseLiteral(e);
            }
            parseNumericLiteral(e) {
              return this.estreeParseLiteral(e);
            }
            parseNullLiteral() {
              return this.estreeParseLiteral(null);
            }
            parseBooleanLiteral(e) {
              return this.estreeParseLiteral(e);
            }
            directiveToStmt(e) {
              let s = e.value;
              delete e.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
              let i = e;
              return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
            }
            initFunction(e, s) {
              super.initFunction(e, s), e.expression = false;
            }
            checkDeclaration(e) {
              e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
            }
            getObjectOrClassMethodParams(e) {
              return e.value.params;
            }
            isValidDirective(e) {
              var s;
              return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((s = e.expression.extra) != null && s.parenthesized);
            }
            parseBlockBody(e, s, i, a, n) {
              super.parseBlockBody(e, s, i, a, n);
              let o = e.directives.map((u) => this.directiveToStmt(u));
              e.body = o.concat(e.body), delete e.directives;
            }
            pushClassMethod(e, s, i, a, n, o) {
              this.parseMethod(s, i, a, n, o, "ClassMethod", true), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters), e.body.push(s);
            }
            parsePrivateName() {
              let e = super.parsePrivateName();
              return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
            }
            convertPrivateNameToPrivateIdentifier(e) {
              let s = super.getPrivateNameSV(e);
              return e = e, delete e.id, e.name = s, e.type = "PrivateIdentifier", e;
            }
            isPrivateName(e) {
              return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
            }
            getPrivateNameSV(e) {
              return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
            }
            parseLiteral(e, s) {
              let i = super.parseLiteral(e, s);
              return i.raw = i.extra.raw, delete i.extra, i;
            }
            parseFunctionBody(e, s) {
              let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              super.parseFunctionBody(e, s, i), e.expression = e.body.type !== "BlockStatement";
            }
            parseMethod(e, s, i, a, n, o) {
              let u = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, c2 = this.startNode();
              return c2.kind = e.kind, c2 = super.parseMethod(c2, s, i, a, n, o, u), c2.type = "FunctionExpression", delete c2.kind, e.value = c2, o === "ClassPrivateMethod" && (e.computed = false), this.finishNode(e, "MethodDefinition");
            }
            parseClassProperty() {
              let e = super.parseClassProperty(...arguments);
              return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition"), e;
            }
            parseClassPrivateProperty() {
              let e = super.parseClassPrivateProperty(...arguments);
              return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition", e.computed = false), e;
            }
            parseObjectMethod(e, s, i, a, n) {
              let o = super.parseObjectMethod(e, s, i, a, n);
              return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = false), o;
            }
            parseObjectProperty(e, s, i, a) {
              let n = super.parseObjectProperty(e, s, i, a);
              return n && (n.kind = "init", n.type = "Property"), n;
            }
            isValidLVal(e, s, i) {
              return e === "Property" ? "value" : super.isValidLVal(e, s, i);
            }
            isAssignable(e, s) {
              return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, s) : super.isAssignable(e, s);
            }
            toAssignable(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (e != null && this.isObjectProperty(e)) {
                let { key: i, value: a } = e;
                this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a, s);
              } else super.toAssignable(e, s);
            }
            toAssignableObjectExpressionProp(e, s, i) {
              e.kind === "get" || e.kind === "set" ? this.raise(f.PatternHasAccessor, { at: e.key }) : e.method ? this.raise(f.PatternHasMethod, { at: e.key }) : super.toAssignableObjectExpressionProp(e, s, i);
            }
            finishCallExpression(e, s) {
              let i = super.finishCallExpression(e, s);
              if (i.callee.type === "Import") {
                if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAssertions")) {
                  var a;
                  i.attributes = (a = i.arguments[1]) != null ? a : null;
                }
                delete i.arguments, delete i.callee;
              }
              return i;
            }
            toReferencedArguments(e) {
              e.type !== "ImportExpression" && super.toReferencedArguments(e);
            }
            parseExport(e, s) {
              let i = this.state.lastTokStartLoc, a = super.parseExport(e, s);
              switch (a.type) {
                case "ExportAllDeclaration":
                  a.exported = null;
                  break;
                case "ExportNamedDeclaration":
                  a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported = a.specifiers[0].exported, delete a.specifiers);
                case "ExportDefaultDeclaration":
                  {
                    var n;
                    let { declaration: o } = a;
                    (o == null ? void 0 : o.type) === "ClassDeclaration" && ((n = o.decorators) == null ? void 0 : n.length) > 0 && o.start === a.start && this.resetStartLocation(a, i);
                  }
                  break;
              }
              return a;
            }
            parseSubscript(e, s, i, a) {
              let n = super.parseSubscript(e, s, i, a);
              if (a.optionalChainMember) {
                if ((n.type === "OptionalMemberExpression" || n.type === "OptionalCallExpression") && (n.type = n.type.substring(8)), a.stop) {
                  let o = this.startNodeAtNode(n);
                  return o.expression = n, this.finishNode(o, "ChainExpression");
                }
              } else (n.type === "MemberExpression" || n.type === "CallExpression") && (n.optional = false);
              return n;
            }
            hasPropertyAsPrivateName(e) {
              return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
            }
            isObjectProperty(e) {
              return e.type === "Property" && e.kind === "init" && !e.method;
            }
            isObjectMethod(e) {
              return e.method || e.kind === "get" || e.kind === "set";
            }
            finishNodeAt(e, s, i) {
              return ze(super.finishNodeAt(e, s, i));
            }
            resetStartLocation(e, s) {
              super.resetStartLocation(e, s), ze(e);
            }
            resetEndLocation(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
              super.resetEndLocation(e, s), ze(e);
            }
          }, Vt = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", pr = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", tl = new RegExp("[" + Vt + "]"), sl = new RegExp("[" + Vt + pr + "]");
          Vt = pr = null;
          var fr = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], rl = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
          function Kt(t, r2) {
            let e = 65536;
            for (let s = 0, i = r2.length; s < i; s += 2) {
              if (e += r2[s], e > t) return false;
              if (e += r2[s + 1], e >= t) return true;
            }
            return false;
          }
          function fe(t) {
            return t < 65 ? t === 36 : t <= 90 ? true : t < 97 ? t === 95 : t <= 122 ? true : t <= 65535 ? t >= 170 && tl.test(String.fromCharCode(t)) : Kt(t, fr);
          }
          function De(t) {
            return t < 48 ? t === 36 : t < 58 ? true : t < 65 ? false : t <= 90 ? true : t < 97 ? t === 95 : t <= 122 ? true : t <= 65535 ? t >= 170 && sl.test(String.fromCharCode(t)) : Kt(t, fr) || Kt(t, rl);
          }
          var Wt = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, il = new Set(Wt.keyword), al = new Set(Wt.strict), nl = new Set(Wt.strictBind);
          function dr(t, r2) {
            return r2 && t === "await" || t === "enum";
          }
          function mr(t, r2) {
            return dr(t, r2) || al.has(t);
          }
          function yr(t) {
            return nl.has(t);
          }
          function xr(t, r2) {
            return mr(t, r2) || yr(t);
          }
          function ol(t) {
            return il.has(t);
          }
          function ll(t, r2, e) {
            return t === 64 && r2 === 64 && fe(e);
          }
          var hl = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
          function ul(t) {
            return hl.has(t);
          }
          var Fe = 0, Le = 1, de = 2, Gt = 4, gr = 8, ht = 16, Pr = 32, Ee = 64, ut = 128, Oe = 256, ct = Le | de | ut | Oe, le = 1, Ce = 2, Ar = 4, be = 8, pt = 16, Tr = 64, ft = 128, Jt = 256, Xt = 512, Yt = 1024, Qt = 2048, Ve = 4096, dt = 8192, vr = le | Ce | be | ft | dt, Be = le | 0 | be | dt, cl = le | 0 | be | 0, mt = le | 0 | Ar | 0, Er = le | 0 | pt | 0, pl = 0 | Ce | 0 | ft, fl = 0 | Ce | 0 | 0, Cr = le | Ce | be | Jt | dt, br = 0 | Yt, Pe = 0 | Tr, dl = le | 0 | 0 | Tr, ml = Cr | Xt, yl = 0 | Yt, Sr = 0 | Ce | 0 | Ve, xl = Qt, yt = 4, Zt = 2, es = 1, ts = Zt | es, gl = Zt | yt, Pl = es | yt, Al = Zt, Tl = es, ss = 0, rs = class {
            constructor(t) {
              this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t;
            }
          }, is = class {
            constructor(t, r2) {
              this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = r2;
            }
            get inTopLevel() {
              return (this.currentScope().flags & Le) > 0;
            }
            get inFunction() {
              return (this.currentVarScopeFlags() & de) > 0;
            }
            get allowSuper() {
              return (this.currentThisScopeFlags() & ht) > 0;
            }
            get allowDirectSuper() {
              return (this.currentThisScopeFlags() & Pr) > 0;
            }
            get inClass() {
              return (this.currentThisScopeFlags() & Ee) > 0;
            }
            get inClassAndNotInNonArrowFunction() {
              let t = this.currentThisScopeFlags();
              return (t & Ee) > 0 && (t & de) === 0;
            }
            get inStaticBlock() {
              for (let t = this.scopeStack.length - 1; ; t--) {
                let { flags: r2 } = this.scopeStack[t];
                if (r2 & ut) return true;
                if (r2 & (ct | Ee)) return false;
              }
            }
            get inNonArrowFunction() {
              return (this.currentThisScopeFlags() & de) > 0;
            }
            get treatFunctionsAsVar() {
              return this.treatFunctionsAsVarInScope(this.currentScope());
            }
            createScope(t) {
              return new rs(t);
            }
            enter(t) {
              this.scopeStack.push(this.createScope(t));
            }
            exit() {
              return this.scopeStack.pop().flags;
            }
            treatFunctionsAsVarInScope(t) {
              return !!(t.flags & (de | ut) || !this.parser.inModule && t.flags & Le);
            }
            declareName(t, r2, e) {
              let s = this.currentScope();
              if (r2 & be || r2 & pt) this.checkRedeclarationInScope(s, t, r2, e), r2 & pt ? s.functions.add(t) : s.lexical.add(t), r2 & be && this.maybeExportDefined(s, t);
              else if (r2 & Ar) for (let i = this.scopeStack.length - 1; i >= 0 && (s = this.scopeStack[i], this.checkRedeclarationInScope(s, t, r2, e), s.var.add(t), this.maybeExportDefined(s, t), !(s.flags & ct)); --i) ;
              this.parser.inModule && s.flags & Le && this.undefinedExports.delete(t);
            }
            maybeExportDefined(t, r2) {
              this.parser.inModule && t.flags & Le && this.undefinedExports.delete(r2);
            }
            checkRedeclarationInScope(t, r2, e, s) {
              this.isRedeclaredInScope(t, r2, e) && this.parser.raise(f.VarRedeclaration, { at: s, identifierName: r2 });
            }
            isRedeclaredInScope(t, r2, e) {
              return e & le ? e & be ? t.lexical.has(r2) || t.functions.has(r2) || t.var.has(r2) : e & pt ? t.lexical.has(r2) || !this.treatFunctionsAsVarInScope(t) && t.var.has(r2) : t.lexical.has(r2) && !(t.flags & gr && t.lexical.values().next().value === r2) || !this.treatFunctionsAsVarInScope(t) && t.functions.has(r2) : false;
            }
            checkLocalExport(t) {
              let { name: r2 } = t, e = this.scopeStack[0];
              !e.lexical.has(r2) && !e.var.has(r2) && !e.functions.has(r2) && this.undefinedExports.set(r2, t.loc.start);
            }
            currentScope() {
              return this.scopeStack[this.scopeStack.length - 1];
            }
            currentVarScopeFlags() {
              for (let t = this.scopeStack.length - 1; ; t--) {
                let { flags: r2 } = this.scopeStack[t];
                if (r2 & ct) return r2;
              }
            }
            currentThisScopeFlags() {
              for (let t = this.scopeStack.length - 1; ; t--) {
                let { flags: r2 } = this.scopeStack[t];
                if (r2 & (ct | Ee) && !(r2 & Gt)) return r2;
              }
            }
          }, vl = class extends rs {
            constructor() {
              super(...arguments), this.declareFunctions = /* @__PURE__ */ new Set();
            }
          }, El = class extends is {
            createScope(t) {
              return new vl(t);
            }
            declareName(t, r2, e) {
              let s = this.currentScope();
              if (r2 & Qt) {
                this.checkRedeclarationInScope(s, t, r2, e), this.maybeExportDefined(s, t), s.declareFunctions.add(t);
                return;
              }
              super.declareName(t, r2, e);
            }
            isRedeclaredInScope(t, r2, e) {
              return super.isRedeclaredInScope(t, r2, e) ? true : e & Qt ? !t.declareFunctions.has(r2) && (t.lexical.has(r2) || t.functions.has(r2)) : false;
            }
            checkLocalExport(t) {
              this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
            }
          }, Cl = class {
            constructor() {
              this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
            }
            hasPlugin(t) {
              if (typeof t == "string") return this.plugins.has(t);
              {
                let [r2, e] = t;
                if (!this.hasPlugin(r2)) return false;
                let s = this.plugins.get(r2);
                for (let i of Object.keys(e)) if ((s == null ? void 0 : s[i]) !== e[i]) return false;
                return true;
              }
            }
            getPluginOption(t, r2) {
              var e;
              return (e = this.plugins.get(t)) == null ? void 0 : e[r2];
            }
          };
          function wr(t, r2) {
            t.trailingComments === void 0 ? t.trailingComments = r2 : t.trailingComments.unshift(...r2);
          }
          function bl(t, r2) {
            t.leadingComments === void 0 ? t.leadingComments = r2 : t.leadingComments.unshift(...r2);
          }
          function Ke(t, r2) {
            t.innerComments === void 0 ? t.innerComments = r2 : t.innerComments.unshift(...r2);
          }
          function We(t, r2, e) {
            let s = null, i = r2.length;
            for (; s === null && i > 0; ) s = r2[--i];
            s === null || s.start > e.start ? Ke(t, e.comments) : wr(s, e.comments);
          }
          var Sl = class extends Cl {
            addComment(t) {
              this.filename && (t.loc.filename = this.filename), this.state.comments.push(t);
            }
            processComment(t) {
              let { commentStack: r2 } = this.state, e = r2.length;
              if (e === 0) return;
              let s = e - 1, i = r2[s];
              i.start === t.end && (i.leadingNode = t, s--);
              let { start: a } = t;
              for (; s >= 0; s--) {
                let n = r2[s], o = n.end;
                if (o > a) n.containingNode = t, this.finalizeComment(n), r2.splice(s, 1);
                else {
                  o === a && (n.trailingNode = t);
                  break;
                }
              }
            }
            finalizeComment(t) {
              let { comments: r2 } = t;
              if (t.leadingNode !== null || t.trailingNode !== null) t.leadingNode !== null && wr(t.leadingNode, r2), t.trailingNode !== null && bl(t.trailingNode, r2);
              else {
                let { containingNode: e, start: s } = t;
                if (this.input.charCodeAt(s - 1) === 44) switch (e.type) {
                  case "ObjectExpression":
                  case "ObjectPattern":
                  case "RecordExpression":
                    We(e, e.properties, t);
                    break;
                  case "CallExpression":
                  case "OptionalCallExpression":
                    We(e, e.arguments, t);
                    break;
                  case "FunctionDeclaration":
                  case "FunctionExpression":
                  case "ArrowFunctionExpression":
                  case "ObjectMethod":
                  case "ClassMethod":
                  case "ClassPrivateMethod":
                    We(e, e.params, t);
                    break;
                  case "ArrayExpression":
                  case "ArrayPattern":
                  case "TupleExpression":
                    We(e, e.elements, t);
                    break;
                  case "ExportNamedDeclaration":
                  case "ImportDeclaration":
                    We(e, e.specifiers, t);
                    break;
                  default:
                    Ke(e, r2);
                }
                else Ke(e, r2);
              }
            }
            finalizeRemainingComments() {
              let { commentStack: t } = this.state;
              for (let r2 = t.length - 1; r2 >= 0; r2--) this.finalizeComment(t[r2]);
              this.state.commentStack = [];
            }
            resetPreviousNodeTrailingComments(t) {
              let { commentStack: r2 } = this.state, { length: e } = r2;
              if (e === 0) return;
              let s = r2[e - 1];
              s.leadingNode === t && (s.leadingNode = null);
            }
            takeSurroundingComments(t, r2, e) {
              let { commentStack: s } = this.state, i = s.length;
              if (i === 0) return;
              let a = i - 1;
              for (; a >= 0; a--) {
                let n = s[a], o = n.end;
                if (n.start === e) n.leadingNode = t;
                else if (o === r2) n.trailingNode = t;
                else if (o < r2) break;
              }
            }
          }, as = /\r\n?|[\n\u2028\u2029]/, xt = new RegExp(as.source, "g");
          function Ge(t) {
            switch (t) {
              case 10:
              case 13:
              case 8232:
              case 8233:
                return true;
              default:
                return false;
            }
          }
          var ns = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, wl = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y, Ir = new RegExp("(?=(" + wl.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
          function Il(t) {
            switch (t) {
              case 9:
              case 11:
              case 12:
              case 32:
              case 160:
              case 5760:
              case 8192:
              case 8193:
              case 8194:
              case 8195:
              case 8196:
              case 8197:
              case 8198:
              case 8199:
              case 8200:
              case 8201:
              case 8202:
              case 8239:
              case 8287:
              case 12288:
              case 65279:
                return true;
              default:
                return false;
            }
          }
          var Nr = class {
            constructor() {
              this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 137, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [x.brace], this.canStartJSXElement = true, this.containsEsc = false, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
            }
            init(t) {
              let { strictMode: r2, sourceType: e, startLine: s, startColumn: i } = t;
              this.strict = r2 === false ? false : r2 === true ? true : e === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new ge(s, i, 0);
            }
            curPosition() {
              return new ge(this.curLine, this.pos - this.lineStart, this.pos);
            }
            clone(t) {
              let r2 = new Nr(), e = Object.keys(this);
              for (let s = 0, i = e.length; s < i; s++) {
                let a = e[s], n = this[a];
                !t && Array.isArray(n) && (n = n.slice()), r2[a] = n;
              }
              return r2;
            }
          }, Nl = function(r2) {
            return r2 >= 48 && r2 <= 57;
          }, kr = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, gt = { bin: (t) => t === 48 || t === 49, oct: (t) => t >= 48 && t <= 55, dec: (t) => t >= 48 && t <= 57, hex: (t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102 };
          function Dr(t, r2, e, s, i, a) {
            let n = e, o = s, u = i, c2 = "", y = null, g = e, { length: T } = r2;
            for (; ; ) {
              if (e >= T) {
                a.unterminated(n, o, u), c2 += r2.slice(g, e);
                break;
              }
              let C = r2.charCodeAt(e);
              if (kl(t, C, r2, e)) {
                c2 += r2.slice(g, e);
                break;
              }
              if (C === 92) {
                c2 += r2.slice(g, e);
                let M = Dl(r2, e, s, i, t === "template", a);
                M.ch === null && !y ? y = { pos: e, lineStart: s, curLine: i } : c2 += M.ch, { pos: e, lineStart: s, curLine: i } = M, g = e;
              } else C === 8232 || C === 8233 ? (++e, ++i, s = e) : C === 10 || C === 13 ? t === "template" ? (c2 += r2.slice(g, e) + `
`, ++e, C === 13 && r2.charCodeAt(e) === 10 && ++e, ++i, g = s = e) : a.unterminated(n, o, u) : ++e;
            }
            return { pos: e, str: c2, firstInvalidLoc: y, lineStart: s, curLine: i, containsInvalid: !!y };
          }
          function kl(t, r2, e, s) {
            return t === "template" ? r2 === 96 || r2 === 36 && e.charCodeAt(s + 1) === 123 : r2 === (t === "double" ? 34 : 39);
          }
          function Dl(t, r2, e, s, i, a) {
            let n = !i;
            r2++;
            let o = (c2) => ({ pos: r2, ch: c2, lineStart: e, curLine: s }), u = t.charCodeAt(r2++);
            switch (u) {
              case 110:
                return o(`
`);
              case 114:
                return o("\r");
              case 120: {
                let c2;
                return { code: c2, pos: r2 } = os(t, r2, e, s, 2, false, n, a), o(c2 === null ? null : String.fromCharCode(c2));
              }
              case 117: {
                let c2;
                return { code: c2, pos: r2 } = Lr(t, r2, e, s, n, a), o(c2 === null ? null : String.fromCodePoint(c2));
              }
              case 116:
                return o("	");
              case 98:
                return o("\b");
              case 118:
                return o("\v");
              case 102:
                return o("\f");
              case 13:
                t.charCodeAt(r2) === 10 && ++r2;
              case 10:
                e = r2, ++s;
              case 8232:
              case 8233:
                return o("");
              case 56:
              case 57:
                if (i) return o(null);
                a.strictNumericEscape(r2 - 1, e, s);
              default:
                if (u >= 48 && u <= 55) {
                  let c2 = r2 - 1, g = t.slice(c2, r2 + 2).match(/^[0-7]+/)[0], T = parseInt(g, 8);
                  T > 255 && (g = g.slice(0, -1), T = parseInt(g, 8)), r2 += g.length - 1;
                  let C = t.charCodeAt(r2);
                  if (g !== "0" || C === 56 || C === 57) {
                    if (i) return o(null);
                    a.strictNumericEscape(c2, e, s);
                  }
                  return o(String.fromCharCode(T));
                }
                return o(String.fromCharCode(u));
            }
          }
          function os(t, r2, e, s, i, a, n, o) {
            let u = r2, c2;
            return { n: c2, pos: r2 } = Fr(t, r2, e, s, 16, i, a, false, o, !n), c2 === null && (n ? o.invalidEscapeSequence(u, e, s) : r2 = u - 1), { code: c2, pos: r2 };
          }
          function Fr(t, r2, e, s, i, a, n, o, u, c2) {
            let y = r2, g = i === 16 ? kr.hex : kr.decBinOct, T = i === 16 ? gt.hex : i === 10 ? gt.dec : i === 8 ? gt.oct : gt.bin, C = false, M = 0;
            for (let j = 0, K = a == null ? 1 / 0 : a; j < K; ++j) {
              let W = t.charCodeAt(r2), V;
              if (W === 95 && o !== "bail") {
                let X = t.charCodeAt(r2 - 1), je = t.charCodeAt(r2 + 1);
                if (o) {
                  if (Number.isNaN(je) || !T(je) || g.has(X) || g.has(je)) {
                    if (c2) return { n: null, pos: r2 };
                    u.unexpectedNumericSeparator(r2, e, s);
                  }
                } else {
                  if (c2) return { n: null, pos: r2 };
                  u.numericSeparatorInEscapeSequence(r2, e, s);
                }
                ++r2;
                continue;
              }
              if (W >= 97 ? V = W - 97 + 10 : W >= 65 ? V = W - 65 + 10 : Nl(W) ? V = W - 48 : V = 1 / 0, V >= i) {
                if (V <= 9 && c2) return { n: null, pos: r2 };
                if (V <= 9 && u.invalidDigit(r2, e, s, i)) V = 0;
                else if (n) V = 0, C = true;
                else break;
              }
              ++r2, M = M * i + V;
            }
            return r2 === y || a != null && r2 - y !== a || C ? { n: null, pos: r2 } : { n: M, pos: r2 };
          }
          function Lr(t, r2, e, s, i, a) {
            let n = t.charCodeAt(r2), o;
            if (n === 123) {
              if (++r2, { code: o, pos: r2 } = os(t, r2, e, s, t.indexOf("}", r2) - r2, true, i, a), ++r2, o !== null && o > 1114111) if (i) a.invalidCodePoint(r2, e, s);
              else return { code: null, pos: r2 };
            } else ({ code: o, pos: r2 } = os(t, r2, e, s, 4, false, i, a));
            return { code: o, pos: r2 };
          }
          var Fl = ["at"], Ll = ["at"];
          function Je(t, r2, e) {
            return new ge(e, t - r2, t);
          }
          var Ol = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Ae = class {
            constructor(t) {
              this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new lt(t.startLoc, t.endLoc);
            }
          }, Bl = class extends Sl {
            constructor(t, r2) {
              super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (e, s, i, a) => this.options.errorRecovery ? (this.raise(f.InvalidDigit, { at: Je(e, s, i), radix: a }), true) : false, numericSeparatorInEscapeSequence: this.errorBuilder(f.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(f.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(f.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(f.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (e, s, i) => {
                this.recordStrictModeErrors(f.StrictNumericEscape, { at: Je(e, s, i) });
              }, unterminated: (e, s, i) => {
                throw this.raise(f.UnterminatedString, { at: Je(e - 1, s, i) });
              } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(f.StrictNumericEscape), unterminated: (e, s, i) => {
                throw this.raise(f.UnterminatedTemplate, { at: Je(e, s, i) });
              } }), this.state = new Nr(), this.state.init(t), this.input = r2, this.length = r2.length, this.isLookahead = false;
            }
            pushToken(t) {
              this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
            }
            next() {
              this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Ae(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
            }
            eat(t) {
              return this.match(t) ? (this.next(), true) : false;
            }
            match(t) {
              return this.state.type === t;
            }
            createLookaheadState(t) {
              return { pos: t.pos, value: null, type: t.type, start: t.start, end: t.end, context: [this.curContext()], inType: t.inType, startLoc: t.startLoc, lastTokEndLoc: t.lastTokEndLoc, curLine: t.curLine, lineStart: t.lineStart, curPosition: t.curPosition };
            }
            lookahead() {
              let t = this.state;
              this.state = this.createLookaheadState(t), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
              let r2 = this.state;
              return this.state = t, r2;
            }
            nextTokenStart() {
              return this.nextTokenStartSince(this.state.pos);
            }
            nextTokenStartSince(t) {
              return ns.lastIndex = t, ns.test(this.input) ? ns.lastIndex : t;
            }
            lookaheadCharCode() {
              return this.input.charCodeAt(this.nextTokenStart());
            }
            codePointAtPos(t) {
              let r2 = this.input.charCodeAt(t);
              if ((r2 & 64512) === 55296 && ++t < this.input.length) {
                let e = this.input.charCodeAt(t);
                (e & 64512) === 56320 && (r2 = 65536 + ((r2 & 1023) << 10) + (e & 1023));
              }
              return r2;
            }
            setStrict(t) {
              this.state.strict = t, t && (this.state.strictErrors.forEach((r2) => {
                let [e, s] = r2;
                return this.raise(e, { at: s });
              }), this.state.strictErrors.clear());
            }
            curContext() {
              return this.state.context[this.state.context.length - 1];
            }
            nextToken() {
              if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
                this.finishToken(137);
                return;
              }
              this.getTokenFromCode(this.codePointAtPos(this.state.pos));
            }
            skipBlockComment(t) {
              let r2;
              this.isLookahead || (r2 = this.state.curPosition());
              let e = this.state.pos, s = this.input.indexOf(t, e + 2);
              if (s === -1) throw this.raise(f.UnterminatedComment, { at: this.state.curPosition() });
              for (this.state.pos = s + t.length, xt.lastIndex = e + 2; xt.test(this.input) && xt.lastIndex <= s; ) ++this.state.curLine, this.state.lineStart = xt.lastIndex;
              if (this.isLookahead) return;
              let i = { type: "CommentBlock", value: this.input.slice(e + 2, s), start: e, end: s + t.length, loc: new lt(r2, this.state.curPosition()) };
              return this.options.tokens && this.pushToken(i), i;
            }
            skipLineComment(t) {
              let r2 = this.state.pos, e;
              this.isLookahead || (e = this.state.curPosition());
              let s = this.input.charCodeAt(this.state.pos += t);
              if (this.state.pos < this.length) for (; !Ge(s) && ++this.state.pos < this.length; ) s = this.input.charCodeAt(this.state.pos);
              if (this.isLookahead) return;
              let i = this.state.pos, n = { type: "CommentLine", value: this.input.slice(r2 + t, i), start: r2, end: i, loc: new lt(e, this.state.curPosition()) };
              return this.options.tokens && this.pushToken(n), n;
            }
            skipSpace() {
              let t = this.state.pos, r2 = [];
              e: for (; this.state.pos < this.length; ) {
                let e = this.input.charCodeAt(this.state.pos);
                switch (e) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42: {
                        let s = this.skipBlockComment("*/");
                        s !== void 0 && (this.addComment(s), this.options.attachComment && r2.push(s));
                        break;
                      }
                      case 47: {
                        let s = this.skipLineComment(2);
                        s !== void 0 && (this.addComment(s), this.options.attachComment && r2.push(s));
                        break;
                      }
                      default:
                        break e;
                    }
                    break;
                  default:
                    if (Il(e)) ++this.state.pos;
                    else if (e === 45 && !this.inModule && this.options.annexB) {
                      let s = this.state.pos;
                      if (this.input.charCodeAt(s + 1) === 45 && this.input.charCodeAt(s + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                        let i = this.skipLineComment(3);
                        i !== void 0 && (this.addComment(i), this.options.attachComment && r2.push(i));
                      } else break e;
                    } else if (e === 60 && !this.inModule && this.options.annexB) {
                      let s = this.state.pos;
                      if (this.input.charCodeAt(s + 1) === 33 && this.input.charCodeAt(s + 2) === 45 && this.input.charCodeAt(s + 3) === 45) {
                        let i = this.skipLineComment(4);
                        i !== void 0 && (this.addComment(i), this.options.attachComment && r2.push(i));
                      } else break e;
                    } else break e;
                }
              }
              if (r2.length > 0) {
                let e = this.state.pos, s = { start: t, end: e, comments: r2, leadingNode: null, trailingNode: null, containingNode: null };
                this.state.commentStack.push(s);
              }
            }
            finishToken(t, r2) {
              this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
              let e = this.state.type;
              this.state.type = t, this.state.value = r2, this.isLookahead || this.updateContext(e);
            }
            replaceToken(t) {
              this.state.type = t, this.updateContext();
            }
            readToken_numberSign() {
              if (this.state.pos === 0 && this.readToken_interpreter()) return;
              let t = this.state.pos + 1, r2 = this.codePointAtPos(t);
              if (r2 >= 48 && r2 <= 57) throw this.raise(f.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
              if (r2 === 123 || r2 === 91 && this.hasPlugin("recordAndTuple")) {
                if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar") throw this.raise(r2 === 123 ? f.RecordExpressionHashIncorrectStartSyntaxType : f.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
                this.state.pos += 2, r2 === 123 ? this.finishToken(7) : this.finishToken(1);
              } else fe(r2) ? (++this.state.pos, this.finishToken(136, this.readWord1(r2))) : r2 === 92 ? (++this.state.pos, this.finishToken(136, this.readWord1())) : this.finishOp(27, 1);
            }
            readToken_dot() {
              let t = this.input.charCodeAt(this.state.pos + 1);
              if (t >= 48 && t <= 57) {
                this.readNumber(true);
                return;
              }
              t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
            }
            readToken_slash() {
              this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
            }
            readToken_interpreter() {
              if (this.state.pos !== 0 || this.length < 2) return false;
              let t = this.input.charCodeAt(this.state.pos + 1);
              if (t !== 33) return false;
              let r2 = this.state.pos;
              for (this.state.pos += 1; !Ge(t) && ++this.state.pos < this.length; ) t = this.input.charCodeAt(this.state.pos);
              let e = this.input.slice(r2 + 2, this.state.pos);
              return this.finishToken(28, e), true;
            }
            readToken_mult_modulo(t) {
              let r2 = t === 42 ? 55 : 54, e = 1, s = this.input.charCodeAt(this.state.pos + 1);
              t === 42 && s === 42 && (e++, s = this.input.charCodeAt(this.state.pos + 2), r2 = 57), s === 61 && !this.state.inType && (e++, r2 = t === 37 ? 33 : 30), this.finishOp(r2, e);
            }
            readToken_pipe_amp(t) {
              let r2 = this.input.charCodeAt(this.state.pos + 1);
              if (r2 === t) {
                this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
                return;
              }
              if (t === 124) {
                if (r2 === 62) {
                  this.finishOp(39, 2);
                  return;
                }
                if (this.hasPlugin("recordAndTuple") && r2 === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(f.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(9);
                  return;
                }
                if (this.hasPlugin("recordAndTuple") && r2 === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(f.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(4);
                  return;
                }
              }
              if (r2 === 61) {
                this.finishOp(30, 2);
                return;
              }
              this.finishOp(t === 124 ? 43 : 45, 1);
            }
            readToken_caret() {
              let t = this.input.charCodeAt(this.state.pos + 1);
              t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
            }
            readToken_atSign() {
              this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
            }
            readToken_plus_min(t) {
              let r2 = this.input.charCodeAt(this.state.pos + 1);
              if (r2 === t) {
                this.finishOp(34, 2);
                return;
              }
              r2 === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
            }
            readToken_lt() {
              let { pos: t } = this.state, r2 = this.input.charCodeAt(t + 1);
              if (r2 === 60) {
                if (this.input.charCodeAt(t + 2) === 61) {
                  this.finishOp(30, 3);
                  return;
                }
                this.finishOp(51, 2);
                return;
              }
              if (r2 === 61) {
                this.finishOp(49, 2);
                return;
              }
              this.finishOp(47, 1);
            }
            readToken_gt() {
              let { pos: t } = this.state, r2 = this.input.charCodeAt(t + 1);
              if (r2 === 62) {
                let e = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
                if (this.input.charCodeAt(t + e) === 61) {
                  this.finishOp(30, e + 1);
                  return;
                }
                this.finishOp(52, e);
                return;
              }
              if (r2 === 61) {
                this.finishOp(49, 2);
                return;
              }
              this.finishOp(48, 1);
            }
            readToken_eq_excl(t) {
              let r2 = this.input.charCodeAt(this.state.pos + 1);
              if (r2 === 61) {
                this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                return;
              }
              if (t === 61 && r2 === 62) {
                this.state.pos += 2, this.finishToken(19);
                return;
              }
              this.finishOp(t === 61 ? 29 : 35, 1);
            }
            readToken_question() {
              let t = this.input.charCodeAt(this.state.pos + 1), r2 = this.input.charCodeAt(this.state.pos + 2);
              t === 63 ? r2 === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r2 >= 48 && r2 <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
            }
            getTokenFromCode(t) {
              switch (t) {
                case 46:
                  this.readToken_dot();
                  return;
                case 40:
                  ++this.state.pos, this.finishToken(10);
                  return;
                case 41:
                  ++this.state.pos, this.finishToken(11);
                  return;
                case 59:
                  ++this.state.pos, this.finishToken(13);
                  return;
                case 44:
                  ++this.state.pos, this.finishToken(12);
                  return;
                case 91:
                  if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(f.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                    this.state.pos += 2, this.finishToken(2);
                  } else ++this.state.pos, this.finishToken(0);
                  return;
                case 93:
                  ++this.state.pos, this.finishToken(3);
                  return;
                case 123:
                  if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(f.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                    this.state.pos += 2, this.finishToken(6);
                  } else ++this.state.pos, this.finishToken(5);
                  return;
                case 125:
                  ++this.state.pos, this.finishToken(8);
                  return;
                case 58:
                  this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
                  return;
                case 63:
                  this.readToken_question();
                  return;
                case 96:
                  this.readTemplateToken();
                  return;
                case 48: {
                  let r2 = this.input.charCodeAt(this.state.pos + 1);
                  if (r2 === 120 || r2 === 88) {
                    this.readRadixNumber(16);
                    return;
                  }
                  if (r2 === 111 || r2 === 79) {
                    this.readRadixNumber(8);
                    return;
                  }
                  if (r2 === 98 || r2 === 66) {
                    this.readRadixNumber(2);
                    return;
                  }
                }
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  this.readNumber(false);
                  return;
                case 34:
                case 39:
                  this.readString(t);
                  return;
                case 47:
                  this.readToken_slash();
                  return;
                case 37:
                case 42:
                  this.readToken_mult_modulo(t);
                  return;
                case 124:
                case 38:
                  this.readToken_pipe_amp(t);
                  return;
                case 94:
                  this.readToken_caret();
                  return;
                case 43:
                case 45:
                  this.readToken_plus_min(t);
                  return;
                case 60:
                  this.readToken_lt();
                  return;
                case 62:
                  this.readToken_gt();
                  return;
                case 61:
                case 33:
                  this.readToken_eq_excl(t);
                  return;
                case 126:
                  this.finishOp(36, 1);
                  return;
                case 64:
                  this.readToken_atSign();
                  return;
                case 35:
                  this.readToken_numberSign();
                  return;
                case 92:
                  this.readWord();
                  return;
                default:
                  if (fe(t)) {
                    this.readWord(t);
                    return;
                  }
              }
              throw this.raise(f.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(t) });
            }
            finishOp(t, r2) {
              let e = this.input.slice(this.state.pos, this.state.pos + r2);
              this.state.pos += r2, this.finishToken(t, e);
            }
            readRegexp() {
              let t = this.state.startLoc, r2 = this.state.start + 1, e, s, { pos: i } = this.state;
              for (; ; ++i) {
                if (i >= this.length) throw this.raise(f.UnterminatedRegExp, { at: Y(t, 1) });
                let u = this.input.charCodeAt(i);
                if (Ge(u)) throw this.raise(f.UnterminatedRegExp, { at: Y(t, 1) });
                if (e) e = false;
                else {
                  if (u === 91) s = true;
                  else if (u === 93 && s) s = false;
                  else if (u === 47 && !s) break;
                  e = u === 92;
                }
              }
              let a = this.input.slice(r2, i);
              ++i;
              let n = "", o = () => Y(t, i + 2 - r2);
              for (; i < this.length; ) {
                let u = this.codePointAtPos(i), c2 = String.fromCharCode(u);
                if (Ol.has(u)) u === 118 ? (this.expectPlugin("regexpUnicodeSets", o()), n.includes("u") && this.raise(f.IncompatibleRegExpUVFlags, { at: o() })) : u === 117 && n.includes("v") && this.raise(f.IncompatibleRegExpUVFlags, { at: o() }), n.includes(c2) && this.raise(f.DuplicateRegExpFlags, { at: o() });
                else if (De(u) || u === 92) this.raise(f.MalformedRegExpFlags, { at: o() });
                else break;
                ++i, n += c2;
              }
              this.state.pos = i, this.finishToken(135, { pattern: a, flags: n });
            }
            readInt(t, r2) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, { n: i, pos: a } = Fr(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r2, e, s, this.errorHandlers_readInt, false);
              return this.state.pos = a, i;
            }
            readRadixNumber(t) {
              let r2 = this.state.curPosition(), e = false;
              this.state.pos += 2;
              let s = this.readInt(t);
              s == null && this.raise(f.InvalidDigit, { at: Y(r2, 2), radix: t });
              let i = this.input.charCodeAt(this.state.pos);
              if (i === 110) ++this.state.pos, e = true;
              else if (i === 109) throw this.raise(f.InvalidDecimal, { at: r2 });
              if (fe(this.codePointAtPos(this.state.pos))) throw this.raise(f.NumberIdentifier, { at: this.state.curPosition() });
              if (e) {
                let a = this.input.slice(r2.index, this.state.pos).replace(/[_n]/g, "");
                this.finishToken(133, a);
                return;
              }
              this.finishToken(132, s);
            }
            readNumber(t) {
              let r2 = this.state.pos, e = this.state.curPosition(), s = false, i = false, a = false, n = false, o = false;
              !t && this.readInt(10) === null && this.raise(f.InvalidNumber, { at: this.state.curPosition() });
              let u = this.state.pos - r2 >= 2 && this.input.charCodeAt(r2) === 48;
              if (u) {
                let T = this.input.slice(r2, this.state.pos);
                if (this.recordStrictModeErrors(f.StrictOctalLiteral, { at: e }), !this.state.strict) {
                  let C = T.indexOf("_");
                  C > 0 && this.raise(f.ZeroDigitNumericSeparator, { at: Y(e, C) });
                }
                o = u && !/[89]/.test(T);
              }
              let c2 = this.input.charCodeAt(this.state.pos);
              if (c2 === 46 && !o && (++this.state.pos, this.readInt(10), s = true, c2 = this.input.charCodeAt(this.state.pos)), (c2 === 69 || c2 === 101) && !o && (c2 = this.input.charCodeAt(++this.state.pos), (c2 === 43 || c2 === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(f.InvalidOrMissingExponent, { at: e }), s = true, n = true, c2 = this.input.charCodeAt(this.state.pos)), c2 === 110 && ((s || u) && this.raise(f.InvalidBigIntLiteral, { at: e }), ++this.state.pos, i = true), c2 === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (n || u) && this.raise(f.InvalidDecimal, { at: e }), ++this.state.pos, a = true), fe(this.codePointAtPos(this.state.pos))) throw this.raise(f.NumberIdentifier, { at: this.state.curPosition() });
              let y = this.input.slice(r2, this.state.pos).replace(/[_mn]/g, "");
              if (i) {
                this.finishToken(133, y);
                return;
              }
              if (a) {
                this.finishToken(134, y);
                return;
              }
              let g = o ? parseInt(y, 8) : parseFloat(y);
              this.finishToken(132, g);
            }
            readCodePoint(t) {
              let { code: r2, pos: e } = Lr(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
              return this.state.pos = e, r2;
            }
            readString(t) {
              let { str: r2, pos: e, curLine: s, lineStart: i } = Dr(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
              this.state.pos = e + 1, this.state.lineStart = i, this.state.curLine = s, this.finishToken(131, r2);
            }
            readTemplateContinuation() {
              this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
            }
            readTemplateToken() {
              let t = this.input[this.state.pos], { str: r2, firstInvalidLoc: e, pos: s, curLine: i, lineStart: a } = Dr("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
              this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = i, e && (this.state.firstInvalidTemplateEscapePos = new ge(e.curLine, e.pos - e.lineStart, e.pos)), this.input.codePointAt(s) === 96 ? this.finishToken(24, e ? null : t + r2 + "`") : (this.state.pos++, this.finishToken(25, e ? null : t + r2 + "${"));
            }
            recordStrictModeErrors(t, r2) {
              let { at: e } = r2, s = e.index;
              this.state.strict && !this.state.strictErrors.has(s) ? this.raise(t, { at: e }) : this.state.strictErrors.set(s, [t, e]);
            }
            readWord1(t) {
              this.state.containsEsc = false;
              let r2 = "", e = this.state.pos, s = this.state.pos;
              for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
                let i = this.codePointAtPos(this.state.pos);
                if (De(i)) this.state.pos += i <= 65535 ? 1 : 2;
                else if (i === 92) {
                  this.state.containsEsc = true, r2 += this.input.slice(s, this.state.pos);
                  let a = this.state.curPosition(), n = this.state.pos === e ? fe : De;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(f.MissingUnicodeEscape, { at: this.state.curPosition() }), s = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  let o = this.readCodePoint(true);
                  o !== null && (n(o) || this.raise(f.EscapedCharNotAnIdentifier, { at: a }), r2 += String.fromCodePoint(o)), s = this.state.pos;
                } else break;
              }
              return r2 + this.input.slice(s, this.state.pos);
            }
            readWord(t) {
              let r2 = this.readWord1(t), e = L.get(r2);
              e !== void 0 ? this.finishToken(e, xe(e)) : this.finishToken(130, r2);
            }
            checkKeywordEscapes() {
              let { type: t } = this.state;
              $t(t) && this.state.containsEsc && this.raise(f.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: xe(t) });
            }
            raise(t, r2) {
              let { at: e } = r2, s = ot(r2, Fl), i = e instanceof ge ? e : e.loc.start, a = t({ loc: i, details: s });
              if (!this.options.errorRecovery) throw a;
              return this.isLookahead || this.state.errors.push(a), a;
            }
            raiseOverwrite(t, r2) {
              let { at: e } = r2, s = ot(r2, Ll), i = e instanceof ge ? e : e.loc.start, a = i.index, n = this.state.errors;
              for (let o = n.length - 1; o >= 0; o--) {
                let u = n[o];
                if (u.loc.index === a) return n[o] = t({ loc: i, details: s });
                if (u.loc.index < a) break;
              }
              return this.raise(t, r2);
            }
            updateContext(t) {
            }
            unexpected(t, r2) {
              throw this.raise(f.UnexpectedToken, { expected: r2 ? xe(r2) : null, at: t != null ? t : this.state.startLoc });
            }
            expectPlugin(t, r2) {
              if (this.hasPlugin(t)) return true;
              throw this.raise(f.MissingPlugin, { at: r2 != null ? r2 : this.state.startLoc, missingPlugin: [t] });
            }
            expectOnePlugin(t) {
              if (!t.some((r2) => this.hasPlugin(r2))) throw this.raise(f.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: t });
            }
            errorBuilder(t) {
              return (r2, e, s) => {
                this.raise(t, { at: Je(r2, e, s) });
              };
            }
          }, Ml = class {
            constructor() {
              this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
            }
          }, _l = class {
            constructor(t) {
              this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
            }
            current() {
              return this.stack[this.stack.length - 1];
            }
            enter() {
              this.stack.push(new Ml());
            }
            exit() {
              let t = this.stack.pop(), r2 = this.current();
              for (let [e, s] of Array.from(t.undefinedPrivateNames)) r2 ? r2.undefinedPrivateNames.has(e) || r2.undefinedPrivateNames.set(e, s) : this.parser.raise(f.InvalidPrivateFieldResolution, { at: s, identifierName: e });
            }
            declarePrivateName(t, r2, e) {
              let { privateNames: s, loneAccessors: i, undefinedPrivateNames: a } = this.current(), n = s.has(t);
              if (r2 & ts) {
                let o = n && i.get(t);
                if (o) {
                  let u = o & yt, c2 = r2 & yt, y = o & ts, g = r2 & ts;
                  n = y === g || u !== c2, n || i.delete(t);
                } else n || i.set(t, r2);
              }
              n && this.parser.raise(f.PrivateNameRedeclaration, { at: e, identifierName: t }), s.add(t), a.delete(t);
            }
            usePrivateName(t, r2) {
              let e;
              for (e of this.stack) if (e.privateNames.has(t)) return;
              e ? e.undefinedPrivateNames.set(t, r2) : this.parser.raise(f.InvalidPrivateFieldResolution, { at: r2, identifierName: t });
            }
          }, Rl = 0, Or = 1, ls = 2, Br = 3, Pt = class {
            constructor() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Rl;
              this.type = void 0, this.type = t;
            }
            canBeArrowParameterDeclaration() {
              return this.type === ls || this.type === Or;
            }
            isCertainlyParameterDeclaration() {
              return this.type === Br;
            }
          }, Mr = class extends Pt {
            constructor(t) {
              super(t), this.declarationErrors = /* @__PURE__ */ new Map();
            }
            recordDeclarationError(t, r2) {
              let { at: e } = r2, s = e.index;
              this.declarationErrors.set(s, [t, e]);
            }
            clearDeclarationError(t) {
              this.declarationErrors.delete(t);
            }
            iterateErrors(t) {
              this.declarationErrors.forEach(t);
            }
          }, jl = class {
            constructor(t) {
              this.parser = void 0, this.stack = [new Pt()], this.parser = t;
            }
            enter(t) {
              this.stack.push(t);
            }
            exit() {
              this.stack.pop();
            }
            recordParameterInitializerError(t, r2) {
              let { at: e } = r2, s = { at: e.loc.start }, { stack: i } = this, a = i.length - 1, n = i[a];
              for (; !n.isCertainlyParameterDeclaration(); ) {
                if (n.canBeArrowParameterDeclaration()) n.recordDeclarationError(t, s);
                else return;
                n = i[--a];
              }
              this.parser.raise(t, s);
            }
            recordArrowParameterBindingError(t, r2) {
              let { at: e } = r2, { stack: s } = this, i = s[s.length - 1], a = { at: e.loc.start };
              if (i.isCertainlyParameterDeclaration()) this.parser.raise(t, a);
              else if (i.canBeArrowParameterDeclaration()) i.recordDeclarationError(t, a);
              else return;
            }
            recordAsyncArrowParametersError(t) {
              let { at: r2 } = t, { stack: e } = this, s = e.length - 1, i = e[s];
              for (; i.canBeArrowParameterDeclaration(); ) i.type === ls && i.recordDeclarationError(f.AwaitBindingIdentifier, { at: r2 }), i = e[--s];
            }
            validateAsPattern() {
              let { stack: t } = this, r2 = t[t.length - 1];
              r2.canBeArrowParameterDeclaration() && r2.iterateErrors((e) => {
                let [s, i] = e;
                this.parser.raise(s, { at: i });
                let a = t.length - 2, n = t[a];
                for (; n.canBeArrowParameterDeclaration(); ) n.clearDeclarationError(i.index), n = t[--a];
              });
            }
          };
          function ql() {
            return new Pt(Br);
          }
          function Ul() {
            return new Mr(Or);
          }
          function $l() {
            return new Mr(ls);
          }
          function _r() {
            return new Pt();
          }
          var Me = 0, Rr = 1, At = 2, jr = 4, _e = 8, Hl = class {
            constructor() {
              this.stacks = [];
            }
            enter(t) {
              this.stacks.push(t);
            }
            exit() {
              this.stacks.pop();
            }
            currentFlags() {
              return this.stacks[this.stacks.length - 1];
            }
            get hasAwait() {
              return (this.currentFlags() & At) > 0;
            }
            get hasYield() {
              return (this.currentFlags() & Rr) > 0;
            }
            get hasReturn() {
              return (this.currentFlags() & jr) > 0;
            }
            get hasIn() {
              return (this.currentFlags() & _e) > 0;
            }
          };
          function Tt(t, r2) {
            return (t ? At : 0) | (r2 ? Rr : 0);
          }
          var zl = class extends Bl {
            addExtra(t, r2, e) {
              let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
              if (!t) return;
              let i = t.extra = t.extra || {};
              s ? i[r2] = e : Object.defineProperty(i, r2, { enumerable: s, value: e });
            }
            isContextual(t) {
              return this.state.type === t && !this.state.containsEsc;
            }
            isUnparsedContextual(t, r2) {
              let e = t + r2.length;
              if (this.input.slice(t, e) === r2) {
                let s = this.input.charCodeAt(e);
                return !(De(s) || (s & 64512) === 55296);
              }
              return false;
            }
            isLookaheadContextual(t) {
              let r2 = this.nextTokenStart();
              return this.isUnparsedContextual(r2, t);
            }
            eatContextual(t) {
              return this.isContextual(t) ? (this.next(), true) : false;
            }
            expectContextual(t, r2) {
              if (!this.eatContextual(t)) {
                if (r2 != null) throw this.raise(r2, { at: this.state.startLoc });
                this.unexpected(null, t);
              }
            }
            canInsertSemicolon() {
              return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
            }
            hasPrecedingLineBreak() {
              return as.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
            }
            hasFollowingLineBreak() {
              return Ir.lastIndex = this.state.end, Ir.test(this.input);
            }
            isLineTerminator() {
              return this.eat(13) || this.canInsertSemicolon();
            }
            semicolon() {
              ((arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true) ? this.isLineTerminator() : this.eat(13)) || this.raise(f.MissingSemicolon, { at: this.state.lastTokEndLoc });
            }
            expect(t, r2) {
              this.eat(t) || this.unexpected(r2, t);
            }
            tryParse(t) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone(), e = { node: null };
              try {
                let s = t(function() {
                  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  throw e.node = i, e;
                });
                if (this.state.errors.length > r2.errors.length) {
                  let i = this.state;
                  return this.state = r2, this.state.tokensLength = i.tokensLength, { node: s, error: i.errors[r2.errors.length], thrown: false, aborted: false, failState: i };
                }
                return { node: s, error: null, thrown: false, aborted: false, failState: null };
              } catch (s) {
                let i = this.state;
                if (this.state = r2, s instanceof SyntaxError) return { node: null, error: s, thrown: true, aborted: false, failState: i };
                if (s === e) return { node: e.node, error: null, thrown: false, aborted: true, failState: i };
                throw s;
              }
            }
            checkExpressionErrors(t, r2) {
              if (!t) return false;
              let { shorthandAssignLoc: e, doubleProtoLoc: s, privateKeyLoc: i, optionalParametersLoc: a } = t, n = !!e || !!s || !!a || !!i;
              if (!r2) return n;
              e != null && this.raise(f.InvalidCoverInitializedName, { at: e }), s != null && this.raise(f.DuplicateProto, { at: s }), i != null && this.raise(f.UnexpectedPrivateField, { at: i }), a != null && this.unexpected(a);
            }
            isLiteralPropertyName() {
              return it(this.state.type);
            }
            isPrivateName(t) {
              return t.type === "PrivateName";
            }
            getPrivateNameSV(t) {
              return t.id.name;
            }
            hasPropertyAsPrivateName(t) {
              return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
            }
            isObjectProperty(t) {
              return t.type === "ObjectProperty";
            }
            isObjectMethod(t) {
              return t.type === "ObjectMethod";
            }
            initializeScopes() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module", r2 = this.state.labels;
              this.state.labels = [];
              let e = this.exportedIdentifiers;
              this.exportedIdentifiers = /* @__PURE__ */ new Set();
              let s = this.inModule;
              this.inModule = t;
              let i = this.scope, a = this.getScopeHandler();
              this.scope = new a(this, t);
              let n = this.prodParam;
              this.prodParam = new Hl();
              let o = this.classScope;
              this.classScope = new _l(this);
              let u = this.expressionScope;
              return this.expressionScope = new jl(this), () => {
                this.state.labels = r2, this.exportedIdentifiers = e, this.inModule = s, this.scope = i, this.prodParam = n, this.classScope = o, this.expressionScope = u;
              };
            }
            enterInitialScopes() {
              let t = Me;
              this.inModule && (t |= At), this.scope.enter(Le), this.prodParam.enter(t);
            }
            checkDestructuringPrivate(t) {
              let { privateKeyLoc: r2 } = t;
              r2 !== null && this.expectPlugin("destructuringPrivate", r2);
            }
          }, vt = class {
            constructor() {
              this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
            }
          }, Et = class {
            constructor(t, r2, e) {
              this.type = "", this.start = r2, this.end = 0, this.loc = new lt(e), t != null && t.options.ranges && (this.range = [r2, 0]), t != null && t.filename && (this.loc.filename = t.filename);
            }
          }, hs = Et.prototype;
          hs.__clone = function() {
            let t = new Et(void 0, this.start, this.loc.start), r2 = Object.keys(this);
            for (let e = 0, s = r2.length; e < s; e++) {
              let i = r2[e];
              i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t[i] = this[i]);
            }
            return t;
          };
          function Vl(t) {
            return me(t);
          }
          function me(t) {
            let { type: r2, start: e, end: s, loc: i, range: a, extra: n, name: o } = t, u = Object.create(hs);
            return u.type = r2, u.start = e, u.end = s, u.loc = i, u.range = a, u.extra = n, u.name = o, r2 === "Placeholder" && (u.expectedNode = t.expectedNode), u;
          }
          function Kl(t) {
            let { type: r2, start: e, end: s, loc: i, range: a, extra: n } = t;
            if (r2 === "Placeholder") return Vl(t);
            let o = Object.create(hs);
            return o.type = r2, o.start = e, o.end = s, o.loc = i, o.range = a, t.raw !== void 0 ? o.raw = t.raw : o.extra = n, o.value = t.value, o;
          }
          var Wl = class extends zl {
            startNode() {
              return new Et(this, this.state.start, this.state.startLoc);
            }
            startNodeAt(t) {
              return new Et(this, t.index, t);
            }
            startNodeAtNode(t) {
              return this.startNodeAt(t.loc.start);
            }
            finishNode(t, r2) {
              return this.finishNodeAt(t, r2, this.state.lastTokEndLoc);
            }
            finishNodeAt(t, r2, e) {
              return t.type = r2, t.end = e.index, t.loc.end = e, this.options.ranges && (t.range[1] = e.index), this.options.attachComment && this.processComment(t), t;
            }
            resetStartLocation(t, r2) {
              t.start = r2.index, t.loc.start = r2, this.options.ranges && (t.range[0] = r2.index);
            }
            resetEndLocation(t) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
              t.end = r2.index, t.loc.end = r2, this.options.ranges && (t.range[1] = r2.index);
            }
            resetStartLocationFromNode(t, r2) {
              this.resetStartLocation(t, r2.loc.start);
            }
          }, Gl = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), D = pe`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: (t) => {
            let { reservedType: r2 } = t;
            return `Cannot overwrite reserved type ${r2}.`;
          }, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: (t) => {
            let { memberName: r2, enumName: e } = t;
            return `Boolean enum members need to be initialized. Use either \`${r2} = true,\` or \`${r2} = false,\` in enum \`${e}\`.`;
          }, EnumDuplicateMemberName: (t) => {
            let { memberName: r2, enumName: e } = t;
            return `Enum member names need to be unique, but the name \`${r2}\` has already been used before in enum \`${e}\`.`;
          }, EnumInconsistentMemberValues: (t) => {
            let { enumName: r2 } = t;
            return `Enum \`${r2}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`;
          }, EnumInvalidExplicitType: (t) => {
            let { invalidEnumType: r2, enumName: e } = t;
            return `Enum type \`${r2}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`;
          }, EnumInvalidExplicitTypeUnknownSupplied: (t) => {
            let { enumName: r2 } = t;
            return `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r2}\`.`;
          }, EnumInvalidMemberInitializerPrimaryType: (t) => {
            let { enumName: r2, memberName: e, explicitType: s } = t;
            return `Enum \`${r2}\` has type \`${s}\`, so the initializer of \`${e}\` needs to be a ${s} literal.`;
          }, EnumInvalidMemberInitializerSymbolType: (t) => {
            let { enumName: r2, memberName: e } = t;
            return `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${r2}\`.`;
          }, EnumInvalidMemberInitializerUnknownType: (t) => {
            let { enumName: r2, memberName: e } = t;
            return `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${r2}\`.`;
          }, EnumInvalidMemberName: (t) => {
            let { enumName: r2, memberName: e, suggestion: s } = t;
            return `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${s}\`, in enum \`${r2}\`.`;
          }, EnumNumberMemberNotInitialized: (t) => {
            let { enumName: r2, memberName: e } = t;
            return `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${r2}\`.`;
          }, EnumStringMemberInconsistentlyInitailized: (t) => {
            let { enumName: r2 } = t;
            return `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${r2}\`.`;
          }, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: (t) => {
            let { reservedType: r2 } = t;
            return `Unexpected reserved type ${r2}.`;
          }, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: (t) => {
            let { unsupportedExportKind: r2, suggestion: e } = t;
            return `\`declare export ${r2}\` is not supported. Use \`${e}\` instead.`;
          }, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
          function Jl(t) {
            return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "TypeAlias" && t.declaration.type !== "InterfaceDeclaration");
          }
          function us(t) {
            return t.importKind === "type" || t.importKind === "typeof";
          }
          function qr(t) {
            return te(t) && t !== 97;
          }
          var Xl = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
          function Yl(t, r2) {
            let e = [], s = [];
            for (let i = 0; i < t.length; i++) (r2(t[i], i, t) ? e : s).push(t[i]);
            return [e, s];
          }
          var Ql = /\*?\s*@((?:no)?flow)\b/, Zl = (t) => class extends t {
            constructor() {
              super(...arguments), this.flowPragma = void 0;
            }
            getScopeHandler() {
              return El;
            }
            shouldParseTypes() {
              return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
            }
            shouldParseEnums() {
              return !!this.getPluginOption("flow", "enums");
            }
            finishToken(e, s) {
              e !== 131 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, s);
            }
            addComment(e) {
              if (this.flowPragma === void 0) {
                let s = Ql.exec(e.value);
                if (s) if (s[1] === "flow") this.flowPragma = "flow";
                else if (s[1] === "noflow") this.flowPragma = "noflow";
                else throw new Error("Unexpected flow pragma");
              }
              super.addComment(e);
            }
            flowParseTypeInitialiser(e) {
              let s = this.state.inType;
              this.state.inType = true, this.expect(e || 14);
              let i = this.flowParseType();
              return this.state.inType = s, i;
            }
            flowParsePredicate() {
              let e = this.startNode(), s = this.state.startLoc;
              return this.next(), this.expectContextual(108), this.state.lastTokStart > s.index + 1 && this.raise(D.UnexpectedSpaceBetweenModuloChecks, { at: s }), this.eat(10) ? (e.value = super.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
            }
            flowParseTypeAndPredicateInitialiser() {
              let e = this.state.inType;
              this.state.inType = true, this.expect(14);
              let s = null, i = null;
              return this.match(54) ? (this.state.inType = e, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = e, this.match(54) && (i = this.flowParsePredicate())), [s, i];
            }
            flowParseDeclareClass(e) {
              return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
            }
            flowParseDeclareFunction(e) {
              this.next();
              let s = e.id = this.parseIdentifier(), i = this.startNode(), a = this.startNode();
              this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
              let n = this.flowParseFunctionTypeParams();
              return i.params = n.params, i.rest = n.rest, i.this = n._this, this.expect(11), [i.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(s), this.semicolon(), this.scope.declareName(e.id.name, xl, e.id.loc.start), this.finishNode(e, "DeclareFunction");
            }
            flowParseDeclare(e, s) {
              if (this.match(80)) return this.flowParseDeclareClass(e);
              if (this.match(68)) return this.flowParseDeclareFunction(e);
              if (this.match(74)) return this.flowParseDeclareVariable(e);
              if (this.eatContextual(125)) return this.match(16) ? this.flowParseDeclareModuleExports(e) : (s && this.raise(D.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(e));
              if (this.isContextual(128)) return this.flowParseDeclareTypeAlias(e);
              if (this.isContextual(129)) return this.flowParseDeclareOpaqueType(e);
              if (this.isContextual(127)) return this.flowParseDeclareInterface(e);
              if (this.match(82)) return this.flowParseDeclareExportDeclaration(e, s);
              this.unexpected();
            }
            flowParseDeclareVariable(e) {
              return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, mt, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
            }
            flowParseDeclareModule(e) {
              this.scope.enter(Fe), this.match(131) ? e.id = super.parseExprAtom() : e.id = this.parseIdentifier();
              let s = e.body = this.startNode(), i = s.body = [];
              for (this.expect(5); !this.match(8); ) {
                let o = this.startNode();
                this.match(83) ? (this.next(), !this.isContextual(128) && !this.match(87) && this.raise(D.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), super.parseImport(o)) : (this.expectContextual(123, D.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, true)), i.push(o);
              }
              this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
              let a = null, n = false;
              return i.forEach((o) => {
                Jl(o) ? (a === "CommonJS" && this.raise(D.AmbiguousDeclareModuleKind, { at: o }), a = "ES") : o.type === "DeclareModuleExports" && (n && this.raise(D.DuplicateDeclareModuleExports, { at: o }), a === "ES" && this.raise(D.AmbiguousDeclareModuleKind, { at: o }), a = "CommonJS", n = true);
              }), e.kind = a || "CommonJS", this.finishNode(e, "DeclareModule");
            }
            flowParseDeclareExportDeclaration(e, s) {
              if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
              if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !s) {
                let i = this.state.value;
                throw this.raise(D.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: i, suggestion: Xl[i] });
              }
              if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129)) return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
              if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129)) return e = this.parseExport(e, null), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
              this.unexpected();
            }
            flowParseDeclareModuleExports(e) {
              return this.next(), this.expectContextual(109), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
            }
            flowParseDeclareTypeAlias(e) {
              this.next();
              let s = this.flowParseTypeAlias(e);
              return s.type = "DeclareTypeAlias", s;
            }
            flowParseDeclareOpaqueType(e) {
              this.next();
              let s = this.flowParseOpaqueType(e, true);
              return s.type = "DeclareOpaqueType", s;
            }
            flowParseDeclareInterface(e) {
              return this.next(), this.flowParseInterfaceish(e, false), this.finishNode(e, "DeclareInterface");
            }
            flowParseInterfaceish(e, s) {
              if (e.id = this.flowParseRestrictedIdentifier(!s, true), this.scope.declareName(e.id.name, s ? Er : Be, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], e.implements = [], e.mixins = [], this.eat(81)) do
                e.extends.push(this.flowParseInterfaceExtends());
              while (!s && this.eat(12));
              if (s) {
                if (this.eatContextual(115)) do
                  e.mixins.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
                if (this.eatContextual(111)) do
                  e.implements.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              }
              e.body = this.flowParseObjectType({ allowStatic: s, allowExact: false, allowSpread: false, allowProto: s, allowInexact: false });
            }
            flowParseInterfaceExtends() {
              let e = this.startNode();
              return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
            }
            flowParseInterface(e) {
              return this.flowParseInterfaceish(e, false), this.finishNode(e, "InterfaceDeclaration");
            }
            checkNotUnderscore(e) {
              e === "_" && this.raise(D.UnexpectedReservedUnderscore, { at: this.state.startLoc });
            }
            checkReservedType(e, s, i) {
              Gl.has(e) && this.raise(i ? D.AssignReservedType : D.UnexpectedReservedType, { at: s, reservedType: e });
            }
            flowParseRestrictedIdentifier(e, s) {
              return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(e);
            }
            flowParseTypeAlias(e) {
              return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, Be, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
            }
            flowParseOpaqueType(e, s) {
              return this.expectContextual(128), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, Be, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, s || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
            }
            flowParseTypeParameter() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, s = this.state.startLoc, i = this.startNode(), a = this.flowParseVariance(), n = this.flowParseTypeAnnotatableIdentifier();
              return i.name = n.name, i.variance = a, i.bound = n.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) : e && this.raise(D.MissingTypeParamDefault, { at: s }), this.finishNode(i, "TypeParameter");
            }
            flowParseTypeParameterDeclaration() {
              let e = this.state.inType, s = this.startNode();
              s.params = [], this.state.inType = true, this.match(47) || this.match(140) ? this.next() : this.unexpected();
              let i = false;
              do {
                let a = this.flowParseTypeParameter(i);
                s.params.push(a), a.default && (i = true), this.match(48) || this.expect(12);
              } while (!this.match(48));
              return this.expect(48), this.state.inType = e, this.finishNode(s, "TypeParameterDeclaration");
            }
            flowParseTypeParameterInstantiation() {
              let e = this.startNode(), s = this.state.inType;
              e.params = [], this.state.inType = true, this.expect(47);
              let i = this.state.noAnonFunctionType;
              for (this.state.noAnonFunctionType = false; !this.match(48); ) e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
              return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
            }
            flowParseTypeParameterInstantiationCallOrNew() {
              let e = this.startNode(), s = this.state.inType;
              for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); ) e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
              return this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
            }
            flowParseInterfaceType() {
              let e = this.startNode();
              if (this.expectContextual(127), e.extends = [], this.eat(81)) do
                e.extends.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
              return e.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e, "InterfaceTypeAnnotation");
            }
            flowParseObjectPropertyKey() {
              return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
            }
            flowParseObjectTypeIndexer(e, s, i) {
              return e.static = s, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = i, this.finishNode(e, "ObjectTypeIndexer");
            }
            flowParseObjectTypeInternalSlot(e, s) {
              return e.static = s, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
            }
            flowParseObjectTypeMethodish(e) {
              for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
              return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
            }
            flowParseObjectTypeCallProperty(e, s) {
              let i = this.startNode();
              return e.static = s, e.value = this.flowParseObjectTypeMethodish(i), this.finishNode(e, "ObjectTypeCallProperty");
            }
            flowParseObjectType(e) {
              let { allowStatic: s, allowExact: i, allowSpread: a, allowProto: n, allowInexact: o } = e, u = this.state.inType;
              this.state.inType = true;
              let c2 = this.startNode();
              c2.callProperties = [], c2.properties = [], c2.indexers = [], c2.internalSlots = [];
              let y, g, T = false;
              for (i && this.match(6) ? (this.expect(6), y = 9, g = true) : (this.expect(5), y = 8, g = false), c2.exact = g; !this.match(y); ) {
                let M = false, j = null, K = null, W = this.startNode();
                if (n && this.isContextual(116)) {
                  let X = this.lookahead();
                  X.type !== 14 && X.type !== 17 && (this.next(), j = this.state.startLoc, s = false);
                }
                if (s && this.isContextual(104)) {
                  let X = this.lookahead();
                  X.type !== 14 && X.type !== 17 && (this.next(), M = true);
                }
                let V = this.flowParseVariance();
                if (this.eat(0)) j != null && this.unexpected(j), this.eat(0) ? (V && this.unexpected(V.loc.start), c2.internalSlots.push(this.flowParseObjectTypeInternalSlot(W, M))) : c2.indexers.push(this.flowParseObjectTypeIndexer(W, M, V));
                else if (this.match(10) || this.match(47)) j != null && this.unexpected(j), V && this.unexpected(V.loc.start), c2.callProperties.push(this.flowParseObjectTypeCallProperty(W, M));
                else {
                  let X = "init";
                  if (this.isContextual(98) || this.isContextual(103)) {
                    let Nh = this.lookahead();
                    it(Nh.type) && (X = this.state.value, this.next());
                  }
                  let je = this.flowParseObjectTypeProperty(W, M, j, V, X, a, o != null ? o : !g);
                  je === null ? (T = true, K = this.state.lastTokStartLoc) : c2.properties.push(je);
                }
                this.flowObjectTypeSemicolon(), K && !this.match(8) && !this.match(9) && this.raise(D.UnexpectedExplicitInexactInObject, { at: K });
              }
              this.expect(y), a && (c2.inexact = T);
              let C = this.finishNode(c2, "ObjectTypeAnnotation");
              return this.state.inType = u, C;
            }
            flowParseObjectTypeProperty(e, s, i, a, n, o, u) {
              if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? u || this.raise(D.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(D.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), a && this.raise(D.InexactVariance, { at: a }), null) : (o || this.raise(D.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), i != null && this.unexpected(i), a && this.raise(D.SpreadVariance, { at: a }), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
              {
                e.key = this.flowParseObjectPropertyKey(), e.static = s, e.proto = i != null, e.kind = n;
                let c2 = false;
                return this.match(47) || this.match(10) ? (e.method = true, i != null && this.unexpected(i), a && this.unexpected(a.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)), (n === "get" || n === "set") && this.flowCheckGetterSetterParams(e), !o && e.key.name === "constructor" && e.value.this && this.raise(D.ThisParamBannedInConstructor, { at: e.value.this })) : (n !== "init" && this.unexpected(), e.method = false, this.eat(17) && (c2 = true), e.value = this.flowParseTypeInitialiser(), e.variance = a), e.optional = c2, this.finishNode(e, "ObjectTypeProperty");
              }
            }
            flowCheckGetterSetterParams(e) {
              let s = e.kind === "get" ? 0 : 1, i = e.value.params.length + (e.value.rest ? 1 : 0);
              e.value.this && this.raise(e.kind === "get" ? D.GetterMayNotHaveThisParam : D.SetterMayNotHaveThisParam, { at: e.value.this }), i !== s && this.raise(e.kind === "get" ? f.BadGetterArity : f.BadSetterArity, { at: e }), e.kind === "set" && e.value.rest && this.raise(f.BadSetterRestParameter, { at: e });
            }
            flowObjectTypeSemicolon() {
              !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
            }
            flowParseQualifiedTypeIdentifier(e, s) {
              (e) != null || (e = this.state.startLoc);
              let a = s || this.flowParseRestrictedIdentifier(true);
              for (; this.eat(16); ) {
                let n = this.startNodeAt(e);
                n.qualification = a, n.id = this.flowParseRestrictedIdentifier(true), a = this.finishNode(n, "QualifiedTypeIdentifier");
              }
              return a;
            }
            flowParseGenericType(e, s) {
              let i = this.startNodeAt(e);
              return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
            }
            flowParseTypeofType() {
              let e = this.startNode();
              return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
            }
            flowParseTupleType() {
              let e = this.startNode();
              for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
              return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
            }
            flowParseFunctionTypeParam(e) {
              let s = null, i = false, a = null, n = this.startNode(), o = this.lookahead(), u = this.state.type === 78;
              return o.type === 14 || o.type === 17 ? (u && !e && this.raise(D.ThisParamMustBeFirst, { at: n }), s = this.parseIdentifier(u), this.eat(17) && (i = true, u && this.raise(D.ThisParamMayNotBeOptional, { at: n })), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), n.name = s, n.optional = i, n.typeAnnotation = a, this.finishNode(n, "FunctionTypeParam");
            }
            reinterpretTypeAsFunctionTypeParam(e) {
              let s = this.startNodeAt(e.loc.start);
              return s.name = null, s.optional = false, s.typeAnnotation = e, this.finishNode(s, "FunctionTypeParam");
            }
            flowParseFunctionTypeParams() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], s = null, i = null;
              for (this.match(78) && (i = this.flowParseFunctionTypeParam(true), i.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
              return this.eat(21) && (s = this.flowParseFunctionTypeParam(false)), { params: e, rest: s, _this: i };
            }
            flowIdentToTypeAnnotation(e, s, i) {
              switch (i.name) {
                case "any":
                  return this.finishNode(s, "AnyTypeAnnotation");
                case "bool":
                case "boolean":
                  return this.finishNode(s, "BooleanTypeAnnotation");
                case "mixed":
                  return this.finishNode(s, "MixedTypeAnnotation");
                case "empty":
                  return this.finishNode(s, "EmptyTypeAnnotation");
                case "number":
                  return this.finishNode(s, "NumberTypeAnnotation");
                case "string":
                  return this.finishNode(s, "StringTypeAnnotation");
                case "symbol":
                  return this.finishNode(s, "SymbolTypeAnnotation");
                default:
                  return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, i);
              }
            }
            flowParsePrimaryType() {
              let e = this.state.startLoc, s = this.startNode(), i, a, n = false, o = this.state.noAnonFunctionType;
              switch (this.state.type) {
                case 5:
                  return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
                case 6:
                  return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
                case 0:
                  return this.state.noAnonFunctionType = false, a = this.flowParseTupleType(), this.state.noAnonFunctionType = o, a;
                case 47:
                  return s.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), s.params = i.params, s.rest = i.rest, s.this = i._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), this.finishNode(s, "FunctionTypeAnnotation");
                case 10:
                  if (this.next(), !this.match(11) && !this.match(21)) if (q(this.state.type) || this.match(78)) {
                    let u = this.lookahead().type;
                    n = u !== 17 && u !== 14;
                  } else n = true;
                  if (n) {
                    if (this.state.noAnonFunctionType = false, a = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) return this.expect(11), a;
                    this.eat(12);
                  }
                  return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(), s.params = i.params, s.rest = i.rest, s.this = i._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
                case 131:
                  return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                case 85:
                case 86:
                  return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
                case 53:
                  if (this.state.value === "-") {
                    if (this.next(), this.match(132)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
                    if (this.match(133)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
                    throw this.raise(D.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                  }
                  this.unexpected();
                  return;
                case 132:
                  return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                case 133:
                  return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                case 88:
                  return this.next(), this.finishNode(s, "VoidTypeAnnotation");
                case 84:
                  return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
                case 78:
                  return this.next(), this.finishNode(s, "ThisTypeAnnotation");
                case 55:
                  return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
                case 87:
                  return this.flowParseTypeofType();
                default:
                  if ($t(this.state.type)) {
                    let u = xe(this.state.type);
                    return this.next(), super.createIdentifier(s, u);
                  } else if (q(this.state.type)) return this.isContextual(127) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, s, this.parseIdentifier());
              }
              this.unexpected();
            }
            flowParsePostfixType() {
              let e = this.state.startLoc, s = this.flowParsePrimaryType(), i = false;
              for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
                let a = this.startNodeAt(e), n = this.eat(18);
                i = i || n, this.expect(0), !n && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.objectType = s, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = n, s = this.finishNode(a, "OptionalIndexedAccessType")) : s = this.finishNode(a, "IndexedAccessType"));
              }
              return s;
            }
            flowParsePrefixType() {
              let e = this.startNode();
              return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
            }
            flowParseAnonFunctionWithoutParens() {
              let e = this.flowParsePrefixType();
              if (!this.state.noAnonFunctionType && this.eat(19)) {
                let s = this.startNodeAt(e.loc.start);
                return s.params = [this.reinterpretTypeAsFunctionTypeParam(e)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
              }
              return e;
            }
            flowParseIntersectionType() {
              let e = this.startNode();
              this.eat(45);
              let s = this.flowParseAnonFunctionWithoutParens();
              for (e.types = [s]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens());
              return e.types.length === 1 ? s : this.finishNode(e, "IntersectionTypeAnnotation");
            }
            flowParseUnionType() {
              let e = this.startNode();
              this.eat(43);
              let s = this.flowParseIntersectionType();
              for (e.types = [s]; this.eat(43); ) e.types.push(this.flowParseIntersectionType());
              return e.types.length === 1 ? s : this.finishNode(e, "UnionTypeAnnotation");
            }
            flowParseType() {
              let e = this.state.inType;
              this.state.inType = true;
              let s = this.flowParseUnionType();
              return this.state.inType = e, s;
            }
            flowParseTypeOrImplicitInstantiation() {
              if (this.state.type === 130 && this.state.value === "_") {
                let e = this.state.startLoc, s = this.parseIdentifier();
                return this.flowParseGenericType(e, s);
              } else return this.flowParseType();
            }
            flowParseTypeAnnotation() {
              let e = this.startNode();
              return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
            }
            flowParseTypeAnnotatableIdentifier(e) {
              let s = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
              return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
            }
            typeCastToParameter(e) {
              return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
            }
            flowParseVariance() {
              let e = null;
              return this.match(53) ? (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")) : e;
            }
            parseFunctionBody(e, s) {
              let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (s) {
                this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, i));
                return;
              }
              super.parseFunctionBody(e, false, i);
            }
            parseFunctionBodyAndFinish(e, s) {
              let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (this.match(14)) {
                let a = this.startNode();
                [a.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = a.typeAnnotation ? this.finishNode(a, "TypeAnnotation") : null;
              }
              return super.parseFunctionBodyAndFinish(e, s, i);
            }
            parseStatementLike(e) {
              if (this.state.strict && this.isContextual(127)) {
                let i = this.lookahead();
                if (te(i.type)) {
                  let a = this.startNode();
                  return this.next(), this.flowParseInterface(a);
                }
              } else if (this.shouldParseEnums() && this.isContextual(124)) {
                let i = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(i);
              }
              let s = super.parseStatementLike(e);
              return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
            }
            parseExpressionStatement(e, s, i) {
              if (s.type === "Identifier") {
                if (s.name === "declare") {
                  if (this.match(80) || q(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e);
                } else if (q(this.state.type)) {
                  if (s.name === "interface") return this.flowParseInterface(e);
                  if (s.name === "type") return this.flowParseTypeAlias(e);
                  if (s.name === "opaque") return this.flowParseOpaqueType(e, false);
                }
              }
              return super.parseExpressionStatement(e, s, i);
            }
            shouldParseExportDeclaration() {
              let { type: e } = this.state;
              return hr(e) || this.shouldParseEnums() && e === 124 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
            }
            isExportDefaultSpecifier() {
              let { type: e } = this.state;
              return hr(e) || this.shouldParseEnums() && e === 124 ? this.state.containsEsc : super.isExportDefaultSpecifier();
            }
            parseExportDefaultExpression() {
              if (this.shouldParseEnums() && this.isContextual(124)) {
                let e = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(e);
              }
              return super.parseExportDefaultExpression();
            }
            parseConditional(e, s, i) {
              if (!this.match(17)) return e;
              if (this.state.maybeInArrowParameters) {
                let T = this.lookaheadCharCode();
                if (T === 44 || T === 61 || T === 58 || T === 41) return this.setOptionalParametersError(i), e;
              }
              this.expect(17);
              let a = this.state.clone(), n = this.state.noArrowAt, o = this.startNodeAt(s), { consequent: u, failed: c2 } = this.tryParseConditionalConsequent(), [y, g] = this.getArrowLikeExpressions(u);
              if (c2 || g.length > 0) {
                let T = [...n];
                if (g.length > 0) {
                  this.state = a, this.state.noArrowAt = T;
                  for (let C = 0; C < g.length; C++) T.push(g[C].start);
                  (({ consequent: u, failed: c2 } = this.tryParseConditionalConsequent())), [y, g] = this.getArrowLikeExpressions(u);
                }
                c2 && y.length > 1 && this.raise(D.AmbiguousConditionalArrow, { at: a.startLoc }), c2 && y.length === 1 && (this.state = a, T.push(y[0].start), this.state.noArrowAt = T, { consequent: u, failed: c2 } = this.tryParseConditionalConsequent());
              }
              return this.getArrowLikeExpressions(u, true), this.state.noArrowAt = n, this.expect(14), o.test = e, o.consequent = u, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
            }
            tryParseConditionalConsequent() {
              this.state.noArrowParamsConversionAt.push(this.state.start);
              let e = this.parseMaybeAssignAllowIn(), s = !this.match(14);
              return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: s };
            }
            getArrowLikeExpressions(e, s) {
              let i = [e], a = [];
              for (; i.length !== 0; ) {
                let n = i.pop();
                n.type === "ArrowFunctionExpression" ? (n.typeParameters || !n.returnType ? this.finishArrowValidation(n) : a.push(n), i.push(n.body)) : n.type === "ConditionalExpression" && (i.push(n.consequent), i.push(n.alternate));
              }
              return s ? (a.forEach((n) => this.finishArrowValidation(n)), [a, []]) : Yl(a, (n) => n.params.every((o) => this.isAssignable(o, true)));
            }
            finishArrowValidation(e) {
              var s;
              this.toAssignableList(e.params, (s = e.extra) == null ? void 0 : s.trailingCommaLoc, false), this.scope.enter(de | Gt), super.checkParams(e, false, true), this.scope.exit();
            }
            forwardNoArrowParamsConversionAt(e, s) {
              let i;
              return this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
            }
            parseParenItem(e, s) {
              if (e = super.parseParenItem(e, s), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
                let i = this.startNodeAt(s);
                return i.expression = e, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
              }
              return e;
            }
            assertModuleNodeAllowed(e) {
              e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
            }
            parseExport(e, s) {
              let i = super.parseExport(e, s);
              return (i.type === "ExportNamedDeclaration" || i.type === "ExportAllDeclaration") && (i.exportKind = i.exportKind || "value"), i;
            }
            parseExportDeclaration(e) {
              if (this.isContextual(128)) {
                e.exportKind = "type";
                let s = this.startNode();
                return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e), null) : this.flowParseTypeAlias(s);
              } else if (this.isContextual(129)) {
                e.exportKind = "type";
                let s = this.startNode();
                return this.next(), this.flowParseOpaqueType(s, false);
              } else if (this.isContextual(127)) {
                e.exportKind = "type";
                let s = this.startNode();
                return this.next(), this.flowParseInterface(s);
              } else if (this.shouldParseEnums() && this.isContextual(124)) {
                e.exportKind = "value";
                let s = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(s);
              } else return super.parseExportDeclaration(e);
            }
            eatExportStar(e) {
              return super.eatExportStar(e) ? true : this.isContextual(128) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
            }
            maybeParseExportNamespaceSpecifier(e) {
              let { startLoc: s } = this.state, i = super.maybeParseExportNamespaceSpecifier(e);
              return i && e.exportKind === "type" && this.unexpected(s), i;
            }
            parseClassId(e, s, i) {
              super.parseClassId(e, s, i), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
            }
            parseClassMember(e, s, i) {
              let { startLoc: a } = this.state;
              if (this.isContextual(123)) {
                if (super.parseClassMemberFromModifier(e, s)) return;
                s.declare = true;
              }
              super.parseClassMember(e, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "PropertyDefinition" ? this.raise(D.DeclareClassElement, { at: a }) : s.value && this.raise(D.DeclareClassFieldInitializer, { at: s.value }));
            }
            isIterator(e) {
              return e === "iterator" || e === "asyncIterator";
            }
            readIterator() {
              let e = super.readWord1(), s = "@@" + e;
              (!this.isIterator(e) || !this.state.inType) && this.raise(f.InvalidIdentifier, { at: this.state.curPosition(), identifierName: s }), this.finishToken(130, s);
            }
            getTokenFromCode(e) {
              let s = this.input.charCodeAt(this.state.pos + 1);
              e === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : ll(e, s, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
            }
            isAssignable(e, s) {
              return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, s) : super.isAssignable(e, s);
            }
            toAssignable(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              !s && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, s);
            }
            toAssignableList(e, s, i) {
              for (let a = 0; a < e.length; a++) {
                let n = e[a];
                (n == null ? void 0 : n.type) === "TypeCastExpression" && (e[a] = this.typeCastToParameter(n));
              }
              super.toAssignableList(e, s, i);
            }
            toReferencedList(e, s) {
              for (let a = 0; a < e.length; a++) {
                var i;
                let n = e[a];
                n && n.type === "TypeCastExpression" && !((i = n.extra) != null && i.parenthesized) && (e.length > 1 || !s) && this.raise(D.TypeCastInPattern, { at: n.typeAnnotation });
              }
              return e;
            }
            parseArrayLike(e, s, i, a) {
              let n = super.parseArrayLike(e, s, i, a);
              return s && !this.state.maybeInArrowParameters && this.toReferencedList(n.elements), n;
            }
            isValidLVal(e, s, i) {
              return e === "TypeCastExpression" || super.isValidLVal(e, s, i);
            }
            parseClassProperty(e) {
              return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
            }
            parseClassPrivateProperty(e) {
              return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
            }
            isClassMethod() {
              return this.match(47) || super.isClassMethod();
            }
            isClassProperty() {
              return this.match(14) || super.isClassProperty();
            }
            isNonstaticConstructor(e) {
              return !this.match(14) && super.isNonstaticConstructor(e);
            }
            pushClassMethod(e, s, i, a, n, o) {
              if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, s, i, a, n, o), s.params && n) {
                let u = s.params;
                u.length > 0 && this.isThisParam(u[0]) && this.raise(D.ThisParamBannedInConstructor, { at: s });
              } else if (s.type === "MethodDefinition" && n && s.value.params) {
                let u = s.value.params;
                u.length > 0 && this.isThisParam(u[0]) && this.raise(D.ThisParamBannedInConstructor, { at: s });
              }
            }
            pushClassPrivateMethod(e, s, i, a) {
              s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, s, i, a);
            }
            parseClassSuper(e) {
              if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(111)) {
                this.next();
                let s = e.implements = [];
                do {
                  let i = this.startNode();
                  i.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
                } while (this.eat(12));
              }
            }
            checkGetterSetterParams(e) {
              super.checkGetterSetterParams(e);
              let s = this.getObjectOrClassMethodParams(e);
              if (s.length > 0) {
                let i = s[0];
                this.isThisParam(i) && e.kind === "get" ? this.raise(D.GetterMayNotHaveThisParam, { at: i }) : this.isThisParam(i) && this.raise(D.SetterMayNotHaveThisParam, { at: i });
              }
            }
            parsePropertyNamePrefixOperator(e) {
              e.variance = this.flowParseVariance();
            }
            parseObjPropValue(e, s, i, a, n, o, u) {
              e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
              let c2;
              this.match(47) && !o && (c2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
              let y = super.parseObjPropValue(e, s, i, a, n, o, u);
              return c2 && ((y.value || y).typeParameters = c2), y;
            }
            parseAssignableListItemTypes(e) {
              return this.eat(17) && (e.type !== "Identifier" && this.raise(D.PatternIsOptional, { at: e }), this.isThisParam(e) && this.raise(D.ThisParamMayNotBeOptional, { at: e }), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(D.ThisParamAnnotationRequired, { at: e }), this.match(29) && this.isThisParam(e) && this.raise(D.ThisParamNoDefault, { at: e }), this.resetEndLocation(e), e;
            }
            parseMaybeDefault(e, s) {
              let i = super.parseMaybeDefault(e, s);
              return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(D.TypeBeforeInitializer, { at: i.typeAnnotation }), i;
            }
            shouldParseDefaultImport(e) {
              return us(e) ? qr(this.state.type) : super.shouldParseDefaultImport(e);
            }
            checkImportReflection(e) {
              super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(D.ImportReflectionHasImportType, { at: e.specifiers[0].loc.start });
            }
            parseImportSpecifierLocal(e, s, i) {
              s.local = us(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, i));
            }
            maybeParseDefaultImportSpecifier(e) {
              e.importKind = "value";
              let s = null;
              if (this.match(87) ? s = "typeof" : this.isContextual(128) && (s = "type"), s) {
                let i = this.lookahead(), { type: a } = i;
                s === "type" && a === 55 && this.unexpected(null, i.type), (qr(a) || a === 5 || a === 55) && (this.next(), e.importKind = s);
              }
              return super.maybeParseDefaultImportSpecifier(e);
            }
            parseImportSpecifier(e, s, i, a, n) {
              let o = e.imported, u = null;
              o.type === "Identifier" && (o.name === "type" ? u = "type" : o.name === "typeof" && (u = "typeof"));
              let c2 = false;
              if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                let g = this.parseIdentifier(true);
                u !== null && !te(this.state.type) ? (e.imported = g, e.importKind = u, e.local = me(g)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
              } else {
                if (u !== null && te(this.state.type)) e.imported = this.parseIdentifier(true), e.importKind = u;
                else {
                  if (s) throw this.raise(f.ImportBindingIsString, { at: e, importName: o.value });
                  e.imported = o, e.importKind = null;
                }
                this.eatContextual(93) ? e.local = this.parseIdentifier() : (c2 = true, e.local = me(e.imported));
              }
              let y = us(e);
              return i && y && this.raise(D.ImportTypeShorthandOnlyInPureImport, { at: e }), (i || y) && this.checkReservedType(e.local.name, e.local.loc.start, true), c2 && !i && !y && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 78:
                  return this.parseIdentifier(true);
                default:
                  return super.parseBindingAtom();
              }
            }
            parseFunctionParams(e, s) {
              let i = e.kind;
              i !== "get" && i !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, s);
            }
            parseVarId(e, s) {
              super.parseVarId(e, s), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
            }
            parseAsyncArrowFromCallExpression(e, s) {
              if (this.match(14)) {
                let i = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
              }
              return super.parseAsyncArrowFromCallExpression(e, s);
            }
            shouldParseAsyncArrow() {
              return this.match(14) || super.shouldParseAsyncArrow();
            }
            parseMaybeAssign(e, s) {
              var i;
              let a = null, n;
              if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                if (a = this.state.clone(), n = this.tryParse(() => super.parseMaybeAssign(e, s), a), !n.error) return n.node;
                let { context: c2 } = this.state, y = c2[c2.length - 1];
                (y === x.j_oTag || y === x.j_expr) && c2.pop();
              }
              if ((i = n) != null && i.error || this.match(47)) {
                var o, u;
                a = a || this.state.clone();
                let c2, y = this.tryParse((T) => {
                  var C;
                  c2 = this.flowParseTypeParameterDeclaration();
                  let M = this.forwardNoArrowParamsConversionAt(c2, () => {
                    let K = super.parseMaybeAssign(e, s);
                    return this.resetStartLocationFromNode(K, c2), K;
                  });
                  (C = M.extra) != null && C.parenthesized && T();
                  let j = this.maybeUnwrapTypeCastExpression(M);
                  return j.type !== "ArrowFunctionExpression" && T(), j.typeParameters = c2, this.resetStartLocationFromNode(j, c2), M;
                }, a), g = null;
                if (y.node && this.maybeUnwrapTypeCastExpression(y.node).type === "ArrowFunctionExpression") {
                  if (!y.error && !y.aborted) return y.node.async && this.raise(D.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: c2 }), y.node;
                  g = y.node;
                }
                if ((o = n) != null && o.node) return this.state = n.failState, n.node;
                if (g) return this.state = y.failState, g;
                throw (u = n) != null && u.thrown ? n.error : y.thrown ? y.error : this.raise(D.UnexpectedTokenAfterTypeParameter, { at: c2 });
              }
              return super.parseMaybeAssign(e, s);
            }
            parseArrow(e) {
              if (this.match(14)) {
                let s = this.tryParse(() => {
                  let i = this.state.noAnonFunctionType;
                  this.state.noAnonFunctionType = true;
                  let a = this.startNode();
                  return [a.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), a;
                });
                if (s.thrown) return null;
                s.error && (this.state = s.failState), e.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
              }
              return super.parseArrow(e);
            }
            shouldParseArrow(e) {
              return this.match(14) || super.shouldParseArrow(e);
            }
            setArrowFunctionParameters(e, s) {
              this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? e.params = s : super.setArrowFunctionParameters(e, s);
            }
            checkParams(e, s, i) {
              let a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
              if (!(i && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
                for (let n = 0; n < e.params.length; n++) this.isThisParam(e.params[n]) && n > 0 && this.raise(D.ThisParamMustBeFirst, { at: e.params[n] });
                super.checkParams(e, s, i, a);
              }
            }
            parseParenAndDistinguishExpression(e) {
              return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1);
            }
            parseSubscripts(e, s, i) {
              if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
                this.next();
                let a = this.startNodeAt(s);
                a.callee = e, a.arguments = super.parseCallExpressionArguments(11, false), e = this.finishNode(a, "CallExpression");
              } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
                let a = this.state.clone(), n = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), a);
                if (!n.error && !n.aborted) return n.node;
                let o = this.tryParse(() => super.parseSubscripts(e, s, i), a);
                if (o.node && !o.error) return o.node;
                if (n.node) return this.state = n.failState, n.node;
                if (o.node) return this.state = o.failState, o.node;
                throw n.error || o.error;
              }
              return super.parseSubscripts(e, s, i);
            }
            parseSubscript(e, s, i, a) {
              if (this.match(18) && this.isLookaheadToken_lt()) {
                if (a.optionalChainMember = true, i) return a.stop = true, e;
                this.next();
                let n = this.startNodeAt(s);
                return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n.arguments = this.parseCallExpressionArguments(11, false), n.optional = true, this.finishCallExpression(n, true);
              } else if (!i && this.shouldParseTypes() && this.match(47)) {
                let n = this.startNodeAt(s);
                n.callee = e;
                let o = this.tryParse(() => (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = super.parseCallExpressionArguments(11, false), a.optionalChainMember && (n.optional = false), this.finishCallExpression(n, a.optionalChainMember)));
                if (o.node) return o.error && (this.state = o.failState), o.node;
              }
              return super.parseSubscript(e, s, i, a);
            }
            parseNewCallee(e) {
              super.parseNewCallee(e);
              let s = null;
              this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = s;
            }
            parseAsyncArrowWithTypeParameters(e) {
              let s = this.startNodeAt(e);
              if (this.parseFunctionParams(s, false), !!this.parseArrow(s)) return super.parseArrowExpression(s, void 0, true);
            }
            readToken_mult_modulo(e) {
              let s = this.input.charCodeAt(this.state.pos + 1);
              if (e === 42 && s === 47 && this.state.hasFlowComment) {
                this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
                return;
              }
              super.readToken_mult_modulo(e);
            }
            readToken_pipe_amp(e) {
              let s = this.input.charCodeAt(this.state.pos + 1);
              if (e === 124 && s === 125) {
                this.finishOp(9, 2);
                return;
              }
              super.readToken_pipe_amp(e);
            }
            parseTopLevel(e, s) {
              let i = super.parseTopLevel(e, s);
              return this.state.hasFlowComment && this.raise(D.UnterminatedFlowComment, { at: this.state.curPosition() }), i;
            }
            skipBlockComment() {
              if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                if (this.state.hasFlowComment) throw this.raise(D.NestedFlowComment, { at: this.state.startLoc });
                this.hasFlowCommentCompletion();
                let e = this.skipFlowComment();
                e && (this.state.pos += e, this.state.hasFlowComment = true);
                return;
              }
              return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
            }
            skipFlowComment() {
              let { pos: e } = this.state, s = 2;
              for (; [32, 9].includes(this.input.charCodeAt(e + s)); ) s++;
              let i = this.input.charCodeAt(s + e), a = this.input.charCodeAt(s + e + 1);
              return i === 58 && a === 58 ? s + 2 : this.input.slice(s + e, s + e + 12) === "flow-include" ? s + 12 : i === 58 && a !== 58 ? s : false;
            }
            hasFlowCommentCompletion() {
              if (this.input.indexOf("*/", this.state.pos) === -1) throw this.raise(f.UnterminatedComment, { at: this.state.curPosition() });
            }
            flowEnumErrorBooleanMemberNotInitialized(e, s) {
              let { enumName: i, memberName: a } = s;
              this.raise(D.EnumBooleanMemberNotInitialized, { at: e, memberName: a, enumName: i });
            }
            flowEnumErrorInvalidMemberInitializer(e, s) {
              return this.raise(s.explicitType ? s.explicitType === "symbol" ? D.EnumInvalidMemberInitializerSymbolType : D.EnumInvalidMemberInitializerPrimaryType : D.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: e }, s));
            }
            flowEnumErrorNumberMemberNotInitialized(e, s) {
              let { enumName: i, memberName: a } = s;
              this.raise(D.EnumNumberMemberNotInitialized, { at: e, enumName: i, memberName: a });
            }
            flowEnumErrorStringMemberInconsistentlyInitailized(e, s) {
              let { enumName: i } = s;
              this.raise(D.EnumStringMemberInconsistentlyInitailized, { at: e, enumName: i });
            }
            flowEnumMemberInit() {
              let e = this.state.startLoc, s = () => this.match(12) || this.match(8);
              switch (this.state.type) {
                case 132: {
                  let i = this.parseNumericLiteral(this.state.value);
                  return s() ? { type: "number", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
                }
                case 131: {
                  let i = this.parseStringLiteral(this.state.value);
                  return s() ? { type: "string", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
                }
                case 85:
                case 86: {
                  let i = this.parseBooleanLiteral(this.match(85));
                  return s() ? { type: "boolean", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
                }
                default:
                  return { type: "invalid", loc: e };
              }
            }
            flowEnumMemberRaw() {
              let e = this.state.startLoc, s = this.parseIdentifier(true), i = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e };
              return { id: s, init: i };
            }
            flowEnumCheckExplicitTypeMismatch(e, s, i) {
              let { explicitType: a } = s;
              a !== null && a !== i && this.flowEnumErrorInvalidMemberInitializer(e, s);
            }
            flowEnumMembers(e) {
              let { enumName: s, explicitType: i } = e, a = /* @__PURE__ */ new Set(), n = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, o = false;
              for (; !this.match(8); ) {
                if (this.eat(21)) {
                  o = true;
                  break;
                }
                let u = this.startNode(), { id: c2, init: y } = this.flowEnumMemberRaw(), g = c2.name;
                if (g === "") continue;
                /^[a-z]/.test(g) && this.raise(D.EnumInvalidMemberName, { at: c2, memberName: g, suggestion: g[0].toUpperCase() + g.slice(1), enumName: s }), a.has(g) && this.raise(D.EnumDuplicateMemberName, { at: c2, memberName: g, enumName: s }), a.add(g);
                let T = { enumName: s, explicitType: i, memberName: g };
                switch (u.id = c2, y.type) {
                  case "boolean": {
                    this.flowEnumCheckExplicitTypeMismatch(y.loc, T, "boolean"), u.init = y.value, n.booleanMembers.push(this.finishNode(u, "EnumBooleanMember"));
                    break;
                  }
                  case "number": {
                    this.flowEnumCheckExplicitTypeMismatch(y.loc, T, "number"), u.init = y.value, n.numberMembers.push(this.finishNode(u, "EnumNumberMember"));
                    break;
                  }
                  case "string": {
                    this.flowEnumCheckExplicitTypeMismatch(y.loc, T, "string"), u.init = y.value, n.stringMembers.push(this.finishNode(u, "EnumStringMember"));
                    break;
                  }
                  case "invalid":
                    throw this.flowEnumErrorInvalidMemberInitializer(y.loc, T);
                  case "none":
                    switch (i) {
                      case "boolean":
                        this.flowEnumErrorBooleanMemberNotInitialized(y.loc, T);
                        break;
                      case "number":
                        this.flowEnumErrorNumberMemberNotInitialized(y.loc, T);
                        break;
                      default:
                        n.defaultedMembers.push(this.finishNode(u, "EnumDefaultedMember"));
                    }
                }
                this.match(8) || this.expect(12);
              }
              return { members: n, hasUnknownMembers: o };
            }
            flowEnumStringMembers(e, s, i) {
              let { enumName: a } = i;
              if (e.length === 0) return s;
              if (s.length === 0) return e;
              if (s.length > e.length) {
                for (let n of e) this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: a });
                return s;
              } else {
                for (let n of s) this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: a });
                return e;
              }
            }
            flowEnumParseExplicitType(e) {
              let { enumName: s } = e;
              if (!this.eatContextual(101)) return null;
              if (!q(this.state.type)) throw this.raise(D.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: s });
              let { value: i } = this.state;
              return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(D.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: s, invalidEnumType: i }), i;
            }
            flowEnumBody(e, s) {
              let i = s.name, a = s.loc.start, n = this.flowEnumParseExplicitType({ enumName: i });
              this.expect(5);
              let { members: o, hasUnknownMembers: u } = this.flowEnumMembers({ enumName: i, explicitType: n });
              switch (e.hasUnknownMembers = u, n) {
                case "boolean":
                  return e.explicitType = true, e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
                case "number":
                  return e.explicitType = true, e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
                case "string":
                  return e.explicitType = true, e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
                case "symbol":
                  return e.members = o.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
                default: {
                  let c2 = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
                  e.explicitType = false;
                  let y = o.booleanMembers.length, g = o.numberMembers.length, T = o.stringMembers.length, C = o.defaultedMembers.length;
                  if (!y && !g && !T && !C) return c2();
                  if (!y && !g) return e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
                  if (!g && !T && y >= C) {
                    for (let M of o.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(M.loc.start, { enumName: i, memberName: M.id.name });
                    return e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
                  } else if (!y && !T && g >= C) {
                    for (let M of o.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(M.loc.start, { enumName: i, memberName: M.id.name });
                    return e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
                  } else return this.raise(D.EnumInconsistentMemberValues, { at: a, enumName: i }), c2();
                }
              }
            }
            flowParseEnumDeclaration(e) {
              let s = this.parseIdentifier();
              return e.id = s, e.body = this.flowEnumBody(this.startNode(), s), this.finishNode(e, "EnumDeclaration");
            }
            isLookaheadToken_lt() {
              let e = this.nextTokenStart();
              if (this.input.charCodeAt(e) === 60) {
                let s = this.input.charCodeAt(e + 1);
                return s !== 60 && s !== 61;
              }
              return false;
            }
            maybeUnwrapTypeCastExpression(e) {
              return e.type === "TypeCastExpression" ? e.expression : e;
            }
          }, eh = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, Se = pe`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: (t) => {
            let { openingTagName: r2 } = t;
            return `Expected corresponding JSX closing tag for <${r2}>.`;
          }, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: (t) => {
            let { unexpected: r2, HTMLEntity: e } = t;
            return `Unexpected token \`${r2}\`. Did you mean \`${e}\` or \`{'${r2}'}\`?`;
          }, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
          function Te(t) {
            return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : false;
          }
          function Re(t) {
            if (t.type === "JSXIdentifier") return t.name;
            if (t.type === "JSXNamespacedName") return t.namespace.name + ":" + t.name.name;
            if (t.type === "JSXMemberExpression") return Re(t.object) + "." + Re(t.property);
            throw new Error("Node had unexpected type: " + t.type);
          }
          var th = (t) => class extends t {
            jsxReadToken() {
              let e = "", s = this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length) throw this.raise(Se.UnterminatedJsxContent, { at: this.state.startLoc });
                let i = this.input.charCodeAt(this.state.pos);
                switch (i) {
                  case 60:
                  case 123:
                    if (this.state.pos === this.state.start) {
                      i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(i);
                      return;
                    }
                    e += this.input.slice(s, this.state.pos), this.finishToken(139, e);
                    return;
                  case 38:
                    e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos;
                    break;
                  case 62:
                  case 125:
                  default:
                    Ge(i) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(true), s = this.state.pos) : ++this.state.pos;
                }
              }
            }
            jsxReadNewLine(e) {
              let s = this.input.charCodeAt(this.state.pos), i;
              return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = e ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
            }
            jsxReadString(e) {
              let s = "", i = ++this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length) throw this.raise(f.UnterminatedString, { at: this.state.startLoc });
                let a = this.input.charCodeAt(this.state.pos);
                if (a === e) break;
                a === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : Ge(a) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(false), i = this.state.pos) : ++this.state.pos;
              }
              s += this.input.slice(i, this.state.pos++), this.finishToken(131, s);
            }
            jsxReadEntity() {
              let e = ++this.state.pos;
              if (this.codePointAtPos(this.state.pos) === 35) {
                ++this.state.pos;
                let s = 10;
                this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
                let i = this.readInt(s, void 0, false, "bail");
                if (i !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(i);
              } else {
                let s = 0, i = false;
                for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) == 59); ) ++this.state.pos;
                if (i) {
                  let a = this.input.slice(e, this.state.pos), n = eh[a];
                  if (++this.state.pos, n) return n;
                }
              }
              return this.state.pos = e, "&";
            }
            jsxReadWord() {
              let e, s = this.state.pos;
              do
                e = this.input.charCodeAt(++this.state.pos);
              while (De(e) || e === 45);
              this.finishToken(138, this.input.slice(s, this.state.pos));
            }
            jsxParseIdentifier() {
              let e = this.startNode();
              return this.match(138) ? e.name = this.state.value : $t(this.state.type) ? e.name = xe(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
            }
            jsxParseNamespacedName() {
              let e = this.state.startLoc, s = this.jsxParseIdentifier();
              if (!this.eat(14)) return s;
              let i = this.startNodeAt(e);
              return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
            }
            jsxParseElementName() {
              let e = this.state.startLoc, s = this.jsxParseNamespacedName();
              if (s.type === "JSXNamespacedName") return s;
              for (; this.eat(16); ) {
                let i = this.startNodeAt(e);
                i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
              }
              return s;
            }
            jsxParseAttributeValue() {
              let e;
              switch (this.state.type) {
                case 5:
                  return e = this.startNode(), this.setContext(x.brace), this.next(), e = this.jsxParseExpressionContainer(e, x.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(Se.AttributeIsEmpty, { at: e }), e;
                case 140:
                case 131:
                  return this.parseExprAtom();
                default:
                  throw this.raise(Se.UnsupportedJsxValue, { at: this.state.startLoc });
              }
            }
            jsxParseEmptyExpression() {
              let e = this.startNodeAt(this.state.lastTokEndLoc);
              return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
            }
            jsxParseSpreadChild(e) {
              return this.next(), e.expression = this.parseExpression(), this.setContext(x.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
            }
            jsxParseExpressionContainer(e, s) {
              if (this.match(8)) e.expression = this.jsxParseEmptyExpression();
              else {
                let i = this.parseExpression();
                e.expression = i;
              }
              return this.setContext(s), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
            }
            jsxParseAttribute() {
              let e = this.startNode();
              return this.match(5) ? (this.setContext(x.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(x.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
            }
            jsxParseOpeningElementAt(e) {
              let s = this.startNodeAt(e);
              return this.eat(141) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));
            }
            jsxParseOpeningElementAfterName(e) {
              let s = [];
              for (; !this.match(56) && !this.match(141); ) s.push(this.jsxParseAttribute());
              return e.attributes = s, e.selfClosing = this.eat(56), this.expect(141), this.finishNode(e, "JSXOpeningElement");
            }
            jsxParseClosingElementAt(e) {
              let s = this.startNodeAt(e);
              return this.eat(141) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(141), this.finishNode(s, "JSXClosingElement"));
            }
            jsxParseElementAt(e) {
              let s = this.startNodeAt(e), i = [], a = this.jsxParseOpeningElementAt(e), n = null;
              if (!a.selfClosing) {
                e: for (; ; ) switch (this.state.type) {
                  case 140:
                    if (e = this.state.startLoc, this.next(), this.eat(56)) {
                      n = this.jsxParseClosingElementAt(e);
                      break e;
                    }
                    i.push(this.jsxParseElementAt(e));
                    break;
                  case 139:
                    i.push(this.parseExprAtom());
                    break;
                  case 5: {
                    let o = this.startNode();
                    this.setContext(x.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, x.j_expr));
                    break;
                  }
                  default:
                    this.unexpected();
                }
                Te(a) && !Te(n) && n !== null ? this.raise(Se.MissingClosingTagFragment, { at: n }) : !Te(a) && Te(n) ? this.raise(Se.MissingClosingTagElement, { at: n, openingTagName: Re(a.name) }) : !Te(a) && !Te(n) && Re(n.name) !== Re(a.name) && this.raise(Se.MissingClosingTagElement, { at: n, openingTagName: Re(a.name) });
              }
              if (Te(a) ? (s.openingFragment = a, s.closingFragment = n) : (s.openingElement = a, s.closingElement = n), s.children = i, this.match(47)) throw this.raise(Se.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
              return Te(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
            }
            jsxParseElement() {
              let e = this.state.startLoc;
              return this.next(), this.jsxParseElementAt(e);
            }
            setContext(e) {
              let { context: s } = this.state;
              s[s.length - 1] = e;
            }
            parseExprAtom(e) {
              return this.match(139) ? this.parseLiteral(this.state.value, "JSXText") : this.match(140) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(140), this.jsxParseElement()) : super.parseExprAtom(e);
            }
            skipSpace() {
              this.curContext().preserveSpace || super.skipSpace();
            }
            getTokenFromCode(e) {
              let s = this.curContext();
              if (s === x.j_expr) {
                this.jsxReadToken();
                return;
              }
              if (s === x.j_oTag || s === x.j_cTag) {
                if (fe(e)) {
                  this.jsxReadWord();
                  return;
                }
                if (e === 62) {
                  ++this.state.pos, this.finishToken(141);
                  return;
                }
                if ((e === 34 || e === 39) && s === x.j_oTag) {
                  this.jsxReadString(e);
                  return;
                }
              }
              if (e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                ++this.state.pos, this.finishToken(140);
                return;
              }
              super.getTokenFromCode(e);
            }
            updateContext(e) {
              let { context: s, type: i } = this.state;
              if (i === 56 && e === 140) s.splice(-2, 2, x.j_cTag), this.state.canStartJSXElement = false;
              else if (i === 140) s.push(x.j_oTag);
              else if (i === 141) {
                let a = s[s.length - 1];
                a === x.j_oTag && e === 56 || a === x.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === x.j_expr) : (this.setContext(x.j_expr), this.state.canStartJSXElement = true);
              } else this.state.canStartJSXElement = se(i);
            }
          }, sh = class extends rs {
            constructor() {
              super(...arguments), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
            }
          }, rh = class extends is {
            constructor() {
              super(...arguments), this.importsStack = [];
            }
            createScope(t) {
              return this.importsStack.push(/* @__PURE__ */ new Set()), new sh(t);
            }
            enter(t) {
              t == Oe && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
            }
            exit() {
              let t = super.exit();
              return t == Oe && this.importsStack.pop(), t;
            }
            hasImport(t, r2) {
              let e = this.importsStack.length;
              if (this.importsStack[e - 1].has(t)) return true;
              if (!r2 && e > 1) {
                for (let s = 0; s < e - 1; s++) if (this.importsStack[s].has(t)) return true;
              }
              return false;
            }
            declareName(t, r2, e) {
              if (r2 & Ve) {
                this.hasImport(t, true) && this.parser.raise(f.VarRedeclaration, { at: e, identifierName: t }), this.importsStack[this.importsStack.length - 1].add(t);
                return;
              }
              let s = this.currentScope();
              if (r2 & Yt) {
                this.maybeExportDefined(s, t), s.exportOnlyBindings.add(t);
                return;
              }
              super.declareName(t, r2, e), r2 & Ce && (r2 & le || (this.checkRedeclarationInScope(s, t, r2, e), this.maybeExportDefined(s, t)), s.types.add(t)), r2 & Jt && s.enums.add(t), r2 & Xt && s.constEnums.add(t), r2 & ft && s.classes.add(t);
            }
            isRedeclaredInScope(t, r2, e) {
              if (t.enums.has(r2)) {
                if (e & Jt) {
                  let s = !!(e & Xt), i = t.constEnums.has(r2);
                  return s !== i;
                }
                return true;
              }
              return e & ft && t.classes.has(r2) ? t.lexical.has(r2) ? !!(e & le) : false : e & Ce && t.types.has(r2) ? true : super.isRedeclaredInScope(t, r2, e);
            }
            checkLocalExport(t) {
              let { name: r2 } = t;
              if (this.hasImport(r2)) return;
              let e = this.scopeStack.length;
              for (let s = e - 1; s >= 0; s--) {
                let i = this.scopeStack[s];
                if (i.types.has(r2) || i.exportOnlyBindings.has(r2)) return;
              }
              super.checkLocalExport(t);
            }
          }, ih = (t, r2) => Object.hasOwnProperty.call(t, r2) && t[r2], Ur = (t) => t.type === "ParenthesizedExpression" ? Ur(t.expression) : t, ah = class extends Wl {
            toAssignable(t) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var e, s;
              let i;
              switch ((t.type === "ParenthesizedExpression" || (e = t.extra) != null && e.parenthesized) && (i = Ur(t), r2 ? i.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(f.InvalidParenthesizedAssignment, { at: t }) : i.type !== "MemberExpression" && this.raise(f.InvalidParenthesizedAssignment, { at: t }) : this.raise(f.InvalidParenthesizedAssignment, { at: t })), t.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                  break;
                case "ObjectExpression":
                  t.type = "ObjectPattern";
                  for (let n = 0, o = t.properties.length, u = o - 1; n < o; n++) {
                    var a;
                    let c2 = t.properties[n], y = n === u;
                    this.toAssignableObjectExpressionProp(c2, y, r2), y && c2.type === "RestElement" && (a = t.extra) != null && a.trailingCommaLoc && this.raise(f.RestTrailingComma, { at: t.extra.trailingCommaLoc });
                  }
                  break;
                case "ObjectProperty": {
                  let { key: n, value: o } = t;
                  this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(o, r2);
                  break;
                }
                case "SpreadElement":
                  throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
                case "ArrayExpression":
                  t.type = "ArrayPattern", this.toAssignableList(t.elements, (s = t.extra) == null ? void 0 : s.trailingCommaLoc, r2);
                  break;
                case "AssignmentExpression":
                  t.operator !== "=" && this.raise(f.MissingEqInAssignment, { at: t.left.loc.end }), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, r2);
                  break;
                case "ParenthesizedExpression":
                  this.toAssignable(i, r2);
                  break;
              }
            }
            toAssignableObjectExpressionProp(t, r2, e) {
              if (t.type === "ObjectMethod") this.raise(t.kind === "get" || t.kind === "set" ? f.PatternHasAccessor : f.PatternHasMethod, { at: t.key });
              else if (t.type === "SpreadElement") {
                t.type = "RestElement";
                let s = t.argument;
                this.checkToRestConversion(s, false), this.toAssignable(s, e), r2 || this.raise(f.RestTrailingComma, { at: t });
              } else this.toAssignable(t, e);
            }
            toAssignableList(t, r2, e) {
              let s = t.length - 1;
              for (let i = 0; i <= s; i++) {
                let a = t[i];
                if (a) {
                  if (a.type === "SpreadElement") {
                    a.type = "RestElement";
                    let n = a.argument;
                    this.checkToRestConversion(n, true), this.toAssignable(n, e);
                  } else this.toAssignable(a, e);
                  a.type === "RestElement" && (i < s ? this.raise(f.RestTrailingComma, { at: a }) : r2 && this.raise(f.RestTrailingComma, { at: r2 }));
                }
              }
            }
            isAssignable(t, r2) {
              switch (t.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                  return true;
                case "ObjectExpression": {
                  let e = t.properties.length - 1;
                  return t.properties.every((s, i) => s.type !== "ObjectMethod" && (i === e || s.type !== "SpreadElement") && this.isAssignable(s));
                }
                case "ObjectProperty":
                  return this.isAssignable(t.value);
                case "SpreadElement":
                  return this.isAssignable(t.argument);
                case "ArrayExpression":
                  return t.elements.every((e) => e === null || this.isAssignable(e));
                case "AssignmentExpression":
                  return t.operator === "=";
                case "ParenthesizedExpression":
                  return this.isAssignable(t.expression);
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return !r2;
                default:
                  return false;
              }
            }
            toReferencedList(t, r2) {
              return t;
            }
            toReferencedListDeep(t, r2) {
              this.toReferencedList(t, r2);
              for (let e of t) (e == null ? void 0 : e.type) === "ArrayExpression" && this.toReferencedListDeep(e.elements);
            }
            parseSpread(t) {
              let r2 = this.startNode();
              return this.next(), r2.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r2, "SpreadElement");
            }
            parseRestBinding() {
              let t = this.startNode();
              return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 0: {
                  let t = this.startNode();
                  return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
                }
                case 5:
                  return this.parseObjectLike(8, true);
              }
              return this.parseIdentifier();
            }
            parseBindingList(t, r2, e) {
              let s = e & 1, i = [], a = true;
              for (; !this.eat(t); ) if (a ? a = false : this.expect(12), s && this.match(12)) i.push(null);
              else {
                if (this.eat(t)) break;
                if (this.match(21)) {
                  if (i.push(this.parseAssignableListItemTypes(this.parseRestBinding(), e)), !this.checkCommaAfterRest(r2)) {
                    this.expect(t);
                    break;
                  }
                } else {
                  let n = [];
                  for (this.match(26) && this.hasPlugin("decorators") && this.raise(f.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); ) n.push(this.parseDecorator());
                  i.push(this.parseAssignableListItem(e, n));
                }
              }
              return i;
            }
            parseBindingRestProperty(t) {
              return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
            }
            parseBindingProperty() {
              let t = this.startNode(), { type: r2, startLoc: e } = this.state;
              return r2 === 21 ? this.parseBindingRestProperty(t) : (r2 === 136 ? (this.expectPlugin("destructuringPrivate", e), this.classScope.usePrivateName(this.state.value, e), t.key = this.parsePrivateName()) : this.parsePropertyName(t), t.method = false, this.parseObjPropValue(t, e, false, false, true, false));
            }
            parseAssignableListItem(t, r2) {
              let e = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(e, t);
              let s = this.parseMaybeDefault(e.loc.start, e);
              return r2.length && (e.decorators = r2), s;
            }
            parseAssignableListItemTypes(t, r2) {
              return t;
            }
            parseMaybeDefault(t, r2) {
              var s;
              if ((t) != null || (t = this.state.startLoc), r2 = (s = r2) != null ? s : this.parseBindingAtom(), !this.eat(29)) return r2;
              let i = this.startNodeAt(t);
              return i.left = r2, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
            }
            isValidLVal(t, r2, e) {
              return ih({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t);
            }
            checkLVal(t, r2) {
              let { in: e, binding: s = Pe, checkClashes: i = false, strictModeChanged: a = false, hasParenthesizedAncestor: n = false } = r2;
              var o;
              let u = t.type;
              if (this.isObjectMethod(t)) return;
              if (u === "MemberExpression") {
                s !== Pe && this.raise(f.InvalidPropertyBindingPattern, { at: t });
                return;
              }
              if (u === "Identifier") {
                this.checkIdentifier(t, s, a);
                let { name: C } = t;
                i && (i.has(C) ? this.raise(f.ParamDupe, { at: t }) : i.add(C));
                return;
              }
              let c2 = this.isValidLVal(u, !(n || (o = t.extra) != null && o.parenthesized) && e.type === "AssignmentExpression", s);
              if (c2 === true) return;
              if (c2 === false) {
                let C = s === Pe ? f.InvalidLhs : f.InvalidLhsBinding;
                this.raise(C, { at: t, ancestor: e });
                return;
              }
              let [y, g] = Array.isArray(c2) ? c2 : [c2, u === "ParenthesizedExpression"], T = u === "ArrayPattern" || u === "ObjectPattern" || u === "ParenthesizedExpression" ? { type: u } : e;
              for (let C of [].concat(t[y])) C && this.checkLVal(C, { in: T, binding: s, checkClashes: i, strictModeChanged: a, hasParenthesizedAncestor: g });
            }
            checkIdentifier(t, r2) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              this.state.strict && (e ? xr(t.name, this.inModule) : yr(t.name)) && (r2 === Pe ? this.raise(f.StrictEvalArguments, { at: t, referenceName: t.name }) : this.raise(f.StrictEvalArgumentsBinding, { at: t, bindingName: t.name })), r2 & dt && t.name === "let" && this.raise(f.LetInLexicalBinding, { at: t }), r2 & Pe || this.declareNameFromIdentifier(t, r2);
            }
            declareNameFromIdentifier(t, r2) {
              this.scope.declareName(t.name, r2, t.loc.start);
            }
            checkToRestConversion(t, r2) {
              switch (t.type) {
                case "ParenthesizedExpression":
                  this.checkToRestConversion(t.expression, r2);
                  break;
                case "Identifier":
                case "MemberExpression":
                  break;
                case "ArrayExpression":
                case "ObjectExpression":
                  if (r2) break;
                default:
                  this.raise(f.InvalidRestAssignmentPattern, { at: t });
              }
            }
            checkCommaAfterRest(t) {
              return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? f.RestTrailingComma : f.ElementAfterRest, { at: this.state.startLoc }), true) : false;
            }
          }, nh = (t, r2) => Object.hasOwnProperty.call(t, r2) && t[r2];
          function oh(t) {
            if (t == null) throw new Error(`Unexpected ${t} value.`);
            return t;
          }
          function $r(t) {
            if (!t) throw new Error("Assert fail");
          }
          var I = pe`typescript`({ AbstractMethodHasImplementation: (t) => {
            let { methodName: r2 } = t;
            return `Method '${r2}' cannot have an implementation because it is marked abstract.`;
          }, AbstractPropertyHasInitializer: (t) => {
            let { propertyName: r2 } = t;
            return `Property '${r2}' cannot have an initializer because it is marked abstract.`;
          }, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: (t) => {
            let { kind: r2 } = t;
            return `'declare' is not allowed in ${r2}ters.`;
          }, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: (t) => {
            let { modifier: r2 } = t;
            return "Accessibility modifier already seen.";
          }, DuplicateModifier: (t) => {
            let { modifier: r2 } = t;
            return `Duplicate modifier: '${r2}'.`;
          }, EmptyHeritageClauseType: (t) => {
            let { token: r2 } = t;
            return `'${r2}' list cannot be empty.`;
          }, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: (t) => {
            let { modifiers: r2 } = t;
            return `'${r2[0]}' modifier cannot be used with '${r2[1]}' modifier.`;
          }, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: (t) => {
            let { modifier: r2 } = t;
            return `Index signatures cannot have an accessibility modifier ('${r2}').`;
          }, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: (t) => {
            let { modifier: r2 } = t;
            return `'${r2}' modifier cannot appear on a type member.`;
          }, InvalidModifierOnTypeParameter: (t) => {
            let { modifier: r2 } = t;
            return `'${r2}' modifier cannot appear on a type parameter.`;
          }, InvalidModifierOnTypeParameterPositions: (t) => {
            let { modifier: r2 } = t;
            return `'${r2}' modifier can only appear on a type parameter of a class, interface or type alias.`;
          }, InvalidModifiersOrder: (t) => {
            let { orderedModifiers: r2 } = t;
            return `'${r2[0]}' modifier must precede '${r2[1]}' modifier.`;
          }, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: (t) => {
            let { modifier: r2 } = t;
            return `Private elements cannot have an accessibility modifier ('${r2}').`;
          }, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: (t) => {
            let { typeParameterName: r2 } = t;
            return `Single type parameter ${r2} should have a trailing comma. Example usage: <${r2},>.`;
          }, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: (t) => {
            let { type: r2 } = t;
            return `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${r2}.`;
          } });
          function lh(t) {
            switch (t) {
              case "any":
                return "TSAnyKeyword";
              case "boolean":
                return "TSBooleanKeyword";
              case "bigint":
                return "TSBigIntKeyword";
              case "never":
                return "TSNeverKeyword";
              case "number":
                return "TSNumberKeyword";
              case "object":
                return "TSObjectKeyword";
              case "string":
                return "TSStringKeyword";
              case "symbol":
                return "TSSymbolKeyword";
              case "undefined":
                return "TSUndefinedKeyword";
              case "unknown":
                return "TSUnknownKeyword";
              default:
                return;
            }
          }
          function Hr(t) {
            return t === "private" || t === "public" || t === "protected";
          }
          function hh(t) {
            return t === "in" || t === "out";
          }
          var uh = (t) => class extends t {
            constructor() {
              super(...arguments), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: I.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: I.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: I.InvalidModifierOnTypeParameter });
            }
            getScopeHandler() {
              return rh;
            }
            tsIsIdentifier() {
              return q(this.state.type);
            }
            tsTokenCanFollowModifier() {
              return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
            }
            tsNextTokenCanFollowModifier() {
              return this.next(), this.tsTokenCanFollowModifier();
            }
            tsParseModifier(e, s) {
              if (!q(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
              let i = this.state.value;
              if (e.indexOf(i) !== -1) {
                if (s && this.tsIsStartOfStaticBlocks()) return;
                if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return i;
              }
            }
            tsParseModifiers(e, s) {
              let { allowedModifiers: i, disallowedModifiers: a, stopOnStartOfClassStaticBlock: n, errorTemplate: o = I.InvalidModifierOnTypeMember } = e, u = (y, g, T, C) => {
                g === T && s[C] && this.raise(I.InvalidModifiersOrder, { at: y, orderedModifiers: [T, C] });
              }, c2 = (y, g, T, C) => {
                (s[T] && g === C || s[C] && g === T) && this.raise(I.IncompatibleModifiers, { at: y, modifiers: [T, C] });
              };
              for (; ; ) {
                let { startLoc: y } = this.state, g = this.tsParseModifier(i.concat(a != null ? a : []), n);
                if (!g) break;
                Hr(g) ? s.accessibility ? this.raise(I.DuplicateAccessibilityModifier, { at: y, modifier: g }) : (u(y, g, g, "override"), u(y, g, g, "static"), u(y, g, g, "readonly"), s.accessibility = g) : hh(g) ? (s[g] && this.raise(I.DuplicateModifier, { at: y, modifier: g }), s[g] = true, u(y, g, "in", "out")) : (Object.hasOwnProperty.call(s, g) ? this.raise(I.DuplicateModifier, { at: y, modifier: g }) : (u(y, g, "static", "readonly"), u(y, g, "static", "override"), u(y, g, "override", "readonly"), u(y, g, "abstract", "override"), c2(y, g, "declare", "override"), c2(y, g, "static", "abstract")), s[g] = true), a != null && a.includes(g) && this.raise(o, { at: y, modifier: g });
              }
            }
            tsIsListTerminator(e) {
              switch (e) {
                case "EnumMembers":
                case "TypeMembers":
                  return this.match(8);
                case "HeritageClauseElement":
                  return this.match(5);
                case "TupleElementTypes":
                  return this.match(3);
                case "TypeParametersOrArguments":
                  return this.match(48);
              }
            }
            tsParseList(e, s) {
              let i = [];
              for (; !this.tsIsListTerminator(e); ) i.push(s());
              return i;
            }
            tsParseDelimitedList(e, s, i) {
              return oh(this.tsParseDelimitedListWorker(e, s, true, i));
            }
            tsParseDelimitedListWorker(e, s, i, a) {
              let n = [], o = -1;
              for (; !this.tsIsListTerminator(e); ) {
                o = -1;
                let u = s();
                if (u == null) return;
                if (n.push(u), this.eat(12)) {
                  o = this.state.lastTokStart;
                  continue;
                }
                if (this.tsIsListTerminator(e)) break;
                i && this.expect(12);
                return;
              }
              return a && (a.value = o), n;
            }
            tsParseBracketedList(e, s, i, a, n) {
              a || (i ? this.expect(0) : this.expect(47));
              let o = this.tsParseDelimitedList(e, s, n);
              return i ? this.expect(3) : this.expect(48), o;
            }
            tsParseImportType() {
              let e = this.startNode();
              return this.expect(83), this.expect(10), this.match(131) || this.raise(I.UnsupportedImportTypeArgument, { at: this.state.startLoc }), e.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
            }
            tsParseEntityName() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s = this.parseIdentifier(e);
              for (; this.eat(16); ) {
                let i = this.startNodeAtNode(s);
                i.left = s, i.right = this.parseIdentifier(e), s = this.finishNode(i, "TSQualifiedName");
              }
              return s;
            }
            tsParseTypeReference() {
              let e = this.startNode();
              return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
            }
            tsParseThisTypePredicate(e) {
              this.next();
              let s = this.startNodeAtNode(e);
              return s.parameterName = e, s.typeAnnotation = this.tsParseTypeAnnotation(false), s.asserts = false, this.finishNode(s, "TSTypePredicate");
            }
            tsParseThisTypeNode() {
              let e = this.startNode();
              return this.next(), this.finishNode(e, "TSThisType");
            }
            tsParseTypeQuery() {
              let e = this.startNode();
              return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
            }
            tsParseTypeParameter(e) {
              let s = this.startNode();
              return e(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(29), this.finishNode(s, "TSTypeParameter");
            }
            tsTryParseTypeParameters(e) {
              if (this.match(47)) return this.tsParseTypeParameters(e);
            }
            tsParseTypeParameters(e) {
              let s = this.startNode();
              this.match(47) || this.match(140) ? this.next() : this.unexpected();
              let i = { value: -1 };
              return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, i), s.params.length === 0 && this.raise(I.EmptyTypeParameters, { at: s }), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s, "TSTypeParameterDeclaration");
            }
            tsFillSignature(e, s) {
              let i = e === 19, a = "parameters", n = "typeAnnotation";
              s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[a] = this.tsParseBindingListForSignature(), i ? s[n] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (s[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
            }
            tsParseBindingListForSignature() {
              return super.parseBindingList(11, 41, 2).map((e) => (e.type !== "Identifier" && e.type !== "RestElement" && e.type !== "ObjectPattern" && e.type !== "ArrayPattern" && this.raise(I.UnsupportedSignatureParameterKind, { at: e, type: e.type }), e));
            }
            tsParseTypeMemberSemicolon() {
              !this.eat(12) && !this.isLineTerminator() && this.expect(13);
            }
            tsParseSignatureMember(e, s) {
              return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, e);
            }
            tsIsUnambiguouslyIndexSignature() {
              return this.next(), q(this.state.type) ? (this.next(), this.match(14)) : false;
            }
            tsTryParseIndexSignature(e) {
              if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
              this.expect(0);
              let s = this.parseIdentifier();
              s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), e.parameters = [s];
              let i = this.tsTryParseTypeAnnotation();
              return i && (e.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
            }
            tsParsePropertyOrMethodSignature(e, s) {
              this.eat(17) && (e.optional = true);
              let i = e;
              if (this.match(10) || this.match(47)) {
                s && this.raise(I.ReadonlyForMethodSignature, { at: e });
                let a = i;
                a.kind && this.match(47) && this.raise(I.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, a), this.tsParseTypeMemberSemicolon();
                let n = "parameters", o = "typeAnnotation";
                if (a.kind === "get") a[n].length > 0 && (this.raise(f.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(a[n][0]) && this.raise(I.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
                else if (a.kind === "set") {
                  if (a[n].length !== 1) this.raise(f.BadSetterArity, { at: this.state.curPosition() });
                  else {
                    let u = a[n][0];
                    this.isThisParam(u) && this.raise(I.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), u.type === "Identifier" && u.optional && this.raise(I.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), u.type === "RestElement" && this.raise(I.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
                  }
                  a[o] && this.raise(I.SetAccesorCannotHaveReturnType, { at: a[o] });
                } else a.kind = "method";
                return this.finishNode(a, "TSMethodSignature");
              } else {
                let a = i;
                s && (a.readonly = true);
                let n = this.tsTryParseTypeAnnotation();
                return n && (a.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
              }
            }
            tsParseTypeMember() {
              let e = this.startNode();
              if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
              if (this.match(77)) {
                let i = this.startNode();
                return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(e, false));
              }
              this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e);
              let s = this.tsTryParseIndexSignature(e);
              return s || (super.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
            }
            tsParseTypeLiteral() {
              let e = this.startNode();
              return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
            }
            tsParseObjectTypeMembers() {
              this.expect(5);
              let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
              return this.expect(8), e;
            }
            tsIsStartOfMappedType() {
              return this.next(), this.eat(53) ? this.isContextual(120) : (this.isContextual(120) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
            }
            tsParseMappedTypeParameter() {
              let e = this.startNode();
              return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
            }
            tsParseMappedType() {
              let e = this.startNode();
              return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(120)) : this.eatContextual(120) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
            }
            tsParseTupleType() {
              let e = this.startNode();
              e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
              let s = false, i = null;
              return e.elementTypes.forEach((a) => {
                let { type: o } = a;
                s && o !== "TSRestType" && o !== "TSOptionalType" && !(o === "TSNamedTupleMember" && a.optional) && this.raise(I.OptionalTypeBeforeRequired, { at: a }), s || (s = o === "TSNamedTupleMember" && a.optional || o === "TSOptionalType");
                let u = o;
                o === "TSRestType" && (a = a.typeAnnotation, u = a.type);
                let c2 = u === "TSNamedTupleMember";
                (i) != null || (i = c2), i !== c2 && this.raise(I.MixedLabeledAndUnlabeledElements, { at: a });
              }), this.finishNode(e, "TSTupleType");
            }
            tsParseTupleElementType() {
              let { startLoc: e } = this.state, s = this.eat(21), i, a, n, o, c2 = te(this.state.type) ? this.lookaheadCharCode() : null;
              if (c2 === 58) i = true, n = false, a = this.parseIdentifier(true), this.expect(14), o = this.tsParseType();
              else if (c2 === 63) {
                n = true;
                let y = this.state.startLoc, g = this.state.value, T = this.tsParseNonArrayType();
                this.lookaheadCharCode() === 58 ? (i = true, a = this.createIdentifier(this.startNodeAt(y), g), this.expect(17), this.expect(14), o = this.tsParseType()) : (i = false, o = T, this.expect(17));
              } else o = this.tsParseType(), n = this.eat(17), i = this.eat(14);
              if (i) {
                let y;
                a ? (y = this.startNodeAtNode(a), y.optional = n, y.label = a, y.elementType = o, this.eat(17) && (y.optional = true, this.raise(I.TupleOptionalAfterType, { at: this.state.lastTokStartLoc }))) : (y = this.startNodeAtNode(o), y.optional = n, this.raise(I.InvalidTupleMemberLabel, { at: o }), y.label = o, y.elementType = this.tsParseType()), o = this.finishNode(y, "TSNamedTupleMember");
              } else if (n) {
                let y = this.startNodeAtNode(o);
                y.typeAnnotation = o, o = this.finishNode(y, "TSOptionalType");
              }
              if (s) {
                let y = this.startNodeAt(e);
                y.typeAnnotation = o, o = this.finishNode(y, "TSRestType");
              }
              return o;
            }
            tsParseParenthesizedType() {
              let e = this.startNode();
              return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
            }
            tsParseFunctionOrConstructorType(e, s) {
              let i = this.startNode();
              return e === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)), this.finishNode(i, e);
            }
            tsParseLiteralTypeNode() {
              let e = this.startNode();
              return e.literal = (() => {
                switch (this.state.type) {
                  case 132:
                  case 133:
                  case 131:
                  case 85:
                  case 86:
                    return super.parseExprAtom();
                  default:
                    this.unexpected();
                }
              })(), this.finishNode(e, "TSLiteralType");
            }
            tsParseTemplateLiteralType() {
              let e = this.startNode();
              return e.literal = super.parseTemplate(false), this.finishNode(e, "TSLiteralType");
            }
            parseTemplateSubstitution() {
              return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
            }
            tsParseThisTypeOrThisTypePredicate() {
              let e = this.tsParseThisTypeNode();
              return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
            }
            tsParseNonArrayType() {
              switch (this.state.type) {
                case 131:
                case 132:
                case 133:
                case 85:
                case 86:
                  return this.tsParseLiteralTypeNode();
                case 53:
                  if (this.state.value === "-") {
                    let e = this.startNode(), s = this.lookahead();
                    return s.type !== 132 && s.type !== 133 && this.unexpected(), e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
                  }
                  break;
                case 78:
                  return this.tsParseThisTypeOrThisTypePredicate();
                case 87:
                  return this.tsParseTypeQuery();
                case 83:
                  return this.tsParseImportType();
                case 5:
                  return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                case 0:
                  return this.tsParseTupleType();
                case 10:
                  return this.tsParseParenthesizedType();
                case 25:
                case 24:
                  return this.tsParseTemplateLiteralType();
                default: {
                  let { type: e } = this.state;
                  if (q(e) || e === 88 || e === 84) {
                    let s = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : lh(this.state.value);
                    if (s !== void 0 && this.lookaheadCharCode() !== 46) {
                      let i = this.startNode();
                      return this.next(), this.finishNode(i, s);
                    }
                    return this.tsParseTypeReference();
                  }
                }
              }
              this.unexpected();
            }
            tsParseArrayTypeOrHigher() {
              let e = this.tsParseNonArrayType();
              for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
                let s = this.startNodeAtNode(e);
                s.elementType = e, this.expect(3), e = this.finishNode(s, "TSArrayType");
              } else {
                let s = this.startNodeAtNode(e);
                s.objectType = e, s.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(s, "TSIndexedAccessType");
              }
              return e;
            }
            tsParseTypeOperator() {
              let e = this.startNode(), s = this.state.value;
              return this.next(), e.operator = s, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
            }
            tsCheckTypeAnnotationForReadOnly(e) {
              switch (e.typeAnnotation.type) {
                case "TSTupleType":
                case "TSArrayType":
                  return;
                default:
                  this.raise(I.UnexpectedReadonly, { at: e });
              }
            }
            tsParseInferType() {
              let e = this.startNode();
              this.expectContextual(113);
              let s = this.startNode();
              return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(s, "TSTypeParameter"), this.finishNode(e, "TSInferType");
            }
            tsParseConstraintForInferType() {
              if (this.eat(81)) {
                let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
                if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e;
              }
            }
            tsParseTypeOperatorOrHigher() {
              return qo(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
            }
            tsParseUnionOrIntersectionType(e, s, i) {
              let a = this.startNode(), n = this.eat(i), o = [];
              do
                o.push(s());
              while (this.eat(i));
              return o.length === 1 && !n ? o[0] : (a.types = o, this.finishNode(a, e));
            }
            tsParseIntersectionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
            }
            tsParseUnionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
            }
            tsIsStartOfFunctionType() {
              return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
            }
            tsSkipParameterStart() {
              if (q(this.state.type) || this.match(78)) return this.next(), true;
              if (this.match(5)) {
                let { errors: e } = this.state, s = e.length;
                try {
                  return this.parseObjectLike(8, true), e.length === s;
                } catch {
                  return false;
                }
              }
              if (this.match(0)) {
                this.next();
                let { errors: e } = this.state, s = e.length;
                try {
                  return super.parseBindingList(3, 93, 1), e.length === s;
                } catch {
                  return false;
                }
              }
              return false;
            }
            tsIsUnambiguouslyStartOfFunctionType() {
              return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
            }
            tsParseTypeOrTypePredicateAnnotation(e) {
              return this.tsInType(() => {
                let s = this.startNode();
                this.expect(e);
                let i = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                if (a && this.match(78)) {
                  let u = this.tsParseThisTypeOrThisTypePredicate();
                  return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = true, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(u, i), u.asserts = true), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
                }
                let n = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                if (!n) return a ? (i.parameterName = this.parseIdentifier(), i.asserts = a, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s);
                let o = this.tsParseTypeAnnotation(false);
                return i.parameterName = n, i.typeAnnotation = o, i.asserts = a, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation");
              });
            }
            tsTryParseTypeOrTypePredicateAnnotation() {
              return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
            }
            tsTryParseTypeAnnotation() {
              return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
            }
            tsTryParseType() {
              return this.tsEatThenParseType(14);
            }
            tsParseTypePredicatePrefix() {
              let e = this.parseIdentifier();
              if (this.isContextual(114) && !this.hasPrecedingLineBreak()) return this.next(), e;
            }
            tsParseTypePredicateAsserts() {
              if (this.state.type !== 107) return false;
              let e = this.state.containsEsc;
              return this.next(), !q(this.state.type) && !this.match(78) ? false : (e && this.raise(f.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), true);
            }
            tsParseTypeAnnotation() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
              return this.tsInType(() => {
                e && this.expect(14), s.typeAnnotation = this.tsParseType();
              }), this.finishNode(s, "TSTypeAnnotation");
            }
            tsParseType() {
              $r(this.state.inType);
              let e = this.tsParseNonConditionalType();
              if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e;
              let s = this.startNodeAtNode(e);
              return s.checkType = e, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s, "TSConditionalType");
            }
            isAbstractConstructorSignature() {
              return this.isContextual(122) && this.lookahead().type === 77;
            }
            tsParseNonConditionalType() {
              return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
            }
            tsParseTypeAssertion() {
              this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(I.ReservedTypeAssertion, { at: this.state.startLoc });
              let e = this.startNode();
              return e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
            }
            tsParseHeritageClause(e) {
              let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
                let a = this.startNode();
                return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(a, "TSExpressionWithTypeArguments");
              });
              return i.length || this.raise(I.EmptyHeritageClauseType, { at: s, token: e }), i;
            }
            tsParseInterfaceDeclaration(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (this.hasFollowingLineBreak()) return null;
              this.expectContextual(127), s.declare && (e.declare = true), q(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, pl)) : (e.id = null, this.raise(I.MissingInterfaceName, { at: this.state.startLoc })), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
              let i = this.startNode();
              return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
            }
            tsParseTypeAliasDeclaration(e) {
              return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, fl), e.typeAnnotation = this.tsInType(() => {
                if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(112) && this.lookahead().type !== 16) {
                  let s = this.startNode();
                  return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
                }
                return this.tsParseType();
              }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
            }
            tsInNoContext(e) {
              let s = this.state.context;
              this.state.context = [s[0]];
              try {
                return e();
              } finally {
                this.state.context = s;
              }
            }
            tsInType(e) {
              let s = this.state.inType;
              this.state.inType = true;
              try {
                return e();
              } finally {
                this.state.inType = s;
              }
            }
            tsInDisallowConditionalTypesContext(e) {
              let s = this.state.inDisallowConditionalTypesContext;
              this.state.inDisallowConditionalTypesContext = true;
              try {
                return e();
              } finally {
                this.state.inDisallowConditionalTypesContext = s;
              }
            }
            tsInAllowConditionalTypesContext(e) {
              let s = this.state.inDisallowConditionalTypesContext;
              this.state.inDisallowConditionalTypesContext = false;
              try {
                return e();
              } finally {
                this.state.inDisallowConditionalTypesContext = s;
              }
            }
            tsEatThenParseType(e) {
              return this.match(e) ? this.tsNextThenParseType() : void 0;
            }
            tsExpectThenParseType(e) {
              return this.tsDoThenParseType(() => this.expect(e));
            }
            tsNextThenParseType() {
              return this.tsDoThenParseType(() => this.next());
            }
            tsDoThenParseType(e) {
              return this.tsInType(() => (e(), this.tsParseType()));
            }
            tsParseEnumMember() {
              let e = this.startNode();
              return e.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
            }
            tsParseEnumDeclaration(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return s.const && (e.const = true), s.declare && (e.declare = true), this.expectContextual(124), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? ml : Cr), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
            }
            tsParseModuleBlock() {
              let e = this.startNode();
              return this.scope.enter(Fe), this.expect(5), super.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
            }
            tsParseModuleOrNamespaceDeclaration(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (e.id = this.parseIdentifier(), s || this.checkIdentifier(e.id, yl), this.eat(16)) {
                let i = this.startNode();
                this.tsParseModuleOrNamespaceDeclaration(i, true), e.body = i;
              } else this.scope.enter(Oe), this.prodParam.enter(Me), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
              return this.finishNode(e, "TSModuleDeclaration");
            }
            tsParseAmbientExternalModuleDeclaration(e) {
              return this.isContextual(110) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(131) ? e.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(Oe), this.prodParam.enter(Me), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
            }
            tsParseImportEqualsDeclaration(e, s) {
              e.isExport = s || false, e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Ve), this.expect(29);
              let i = this.tsParseModuleReference();
              return e.importKind === "type" && i.type !== "TSExternalModuleReference" && this.raise(I.ImportAliasHasImportType, { at: i }), e.moduleReference = i, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
            }
            tsIsExternalModuleReference() {
              return this.isContextual(117) && this.lookaheadCharCode() === 40;
            }
            tsParseModuleReference() {
              return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
            }
            tsParseExternalModuleReference() {
              let e = this.startNode();
              return this.expectContextual(117), this.expect(10), this.match(131) || this.unexpected(), e.expression = super.parseExprAtom(), this.expect(11), this.finishNode(e, "TSExternalModuleReference");
            }
            tsLookAhead(e) {
              let s = this.state.clone(), i = e();
              return this.state = s, i;
            }
            tsTryParseAndCatch(e) {
              let s = this.tryParse((i) => e() || i());
              if (!(s.aborted || !s.node)) return s.error && (this.state = s.failState), s.node;
            }
            tsTryParse(e) {
              let s = this.state.clone(), i = e();
              if (i !== void 0 && i !== false) return i;
              this.state = s;
            }
            tsTryParseDeclare(e) {
              if (this.isLineTerminator()) return;
              let s = this.state.type, i;
              return this.isContextual(99) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
                if (s === 68) return e.declare = true, super.parseFunctionStatement(e, false, false);
                if (s === 80) return e.declare = true, this.parseClass(e, true, false);
                if (s === 124) return this.tsParseEnumDeclaration(e, { declare: true });
                if (s === 110) return this.tsParseAmbientExternalModuleDeclaration(e);
                if (s === 75 || s === 74) return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, i || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, { const: true, declare: true }));
                if (s === 127) {
                  let a = this.tsParseInterfaceDeclaration(e, { declare: true });
                  if (a) return a;
                }
                if (q(s)) return this.tsParseDeclaration(e, this.state.value, true, null);
              });
            }
            tsTryParseExportDeclaration() {
              return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
            }
            tsParseExpressionStatement(e, s, i) {
              switch (s.name) {
                case "declare": {
                  let a = this.tsTryParseDeclare(e);
                  if (a) return a.declare = true, a;
                  break;
                }
                case "global":
                  if (this.match(5)) {
                    this.scope.enter(Oe), this.prodParam.enter(Me);
                    let a = e;
                    return a.global = true, a.id = s, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a, "TSModuleDeclaration");
                  }
                  break;
                default:
                  return this.tsParseDeclaration(e, s.name, false, i);
              }
            }
            tsParseDeclaration(e, s, i, a) {
              switch (s) {
                case "abstract":
                  if (this.tsCheckLineTerminator(i) && (this.match(80) || q(this.state.type))) return this.tsParseAbstractDeclaration(e, a);
                  break;
                case "module":
                  if (this.tsCheckLineTerminator(i)) {
                    if (this.match(131)) return this.tsParseAmbientExternalModuleDeclaration(e);
                    if (q(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
                  }
                  break;
                case "namespace":
                  if (this.tsCheckLineTerminator(i) && q(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
                  break;
                case "type":
                  if (this.tsCheckLineTerminator(i) && q(this.state.type)) return this.tsParseTypeAliasDeclaration(e);
                  break;
              }
            }
            tsCheckLineTerminator(e) {
              return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
            }
            tsTryParseGenericAsyncArrowFunction(e) {
              if (!this.match(47)) return;
              let s = this.state.maybeInArrowParameters;
              this.state.maybeInArrowParameters = true;
              let i = this.tsTryParseAndCatch(() => {
                let a = this.startNodeAt(e);
                return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), a;
              });
              if (this.state.maybeInArrowParameters = s, !!i) return super.parseArrowExpression(i, null, true);
            }
            tsParseTypeArgumentsInExpression() {
              if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
            }
            tsParseTypeArguments() {
              let e = this.startNode();
              return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 && this.raise(I.EmptyTypeArguments, { at: e }), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
            }
            tsIsDeclarationStart() {
              return Uo(this.state.type);
            }
            isExportDefaultSpecifier() {
              return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
            }
            parseAssignableListItem(e, s) {
              let i = this.state.startLoc, a = {};
              this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, a);
              let n = a.accessibility, o = a.override, u = a.readonly;
              !(e & 4) && (n || u || o) && this.raise(I.UnexpectedParameterModifier, { at: i });
              let c2 = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(c2, e);
              let y = this.parseMaybeDefault(c2.loc.start, c2);
              if (n || u || o) {
                let g = this.startNodeAt(i);
                return s.length && (g.decorators = s), n && (g.accessibility = n), u && (g.readonly = u), o && (g.override = o), y.type !== "Identifier" && y.type !== "AssignmentPattern" && this.raise(I.UnsupportedParameterPropertyKind, { at: g }), g.parameter = y, this.finishNode(g, "TSParameterProperty");
              }
              return s.length && (c2.decorators = s), y;
            }
            isSimpleParameter(e) {
              return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
            }
            tsDisallowOptionalPattern(e) {
              for (let s of e.params) s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(I.PatternIsOptional, { at: s });
            }
            setArrowFunctionParameters(e, s, i) {
              super.setArrowFunctionParameters(e, s, i), this.tsDisallowOptionalPattern(e);
            }
            parseFunctionBodyAndFinish(e, s) {
              let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
              let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
              return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, a) : a === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(I.DeclareFunctionHasImplementation, { at: e }), e.declare) ? super.parseFunctionBodyAndFinish(e, a, i) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, s, i));
            }
            registerFunctionStatementId(e) {
              !e.body && e.id ? this.checkIdentifier(e.id, br) : super.registerFunctionStatementId(e);
            }
            tsCheckForInvalidTypeCasts(e) {
              e.forEach((s) => {
                (s == null ? void 0 : s.type) === "TSTypeCastExpression" && this.raise(I.UnexpectedTypeAnnotation, { at: s.typeAnnotation });
              });
            }
            toReferencedList(e, s) {
              return this.tsCheckForInvalidTypeCasts(e), e;
            }
            parseArrayLike(e, s, i, a) {
              let n = super.parseArrayLike(e, s, i, a);
              return n.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(n.elements), n;
            }
            parseSubscript(e, s, i, a) {
              if (!this.hasPrecedingLineBreak() && this.match(35)) {
                this.state.canStartJSXElement = false, this.next();
                let o = this.startNodeAt(s);
                return o.expression = e, this.finishNode(o, "TSNonNullExpression");
              }
              let n = false;
              if (this.match(18) && this.lookaheadCharCode() === 60) {
                if (i) return a.stop = true, e;
                a.optionalChainMember = n = true, this.next();
              }
              if (this.match(47) || this.match(51)) {
                let o, u = this.tsTryParseAndCatch(() => {
                  if (!i && this.atPossibleAsyncArrow(e)) {
                    let T = this.tsTryParseGenericAsyncArrowFunction(s);
                    if (T) return T;
                  }
                  let c2 = this.tsParseTypeArgumentsInExpression();
                  if (!c2) return;
                  if (n && !this.match(10)) {
                    o = this.state.curPosition();
                    return;
                  }
                  if (nt(this.state.type)) {
                    let T = super.parseTaggedTemplateExpression(e, s, a);
                    return T.typeParameters = c2, T;
                  }
                  if (!i && this.eat(10)) {
                    let T = this.startNodeAt(s);
                    return T.callee = e, T.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(T.arguments), T.typeParameters = c2, a.optionalChainMember && (T.optional = n), this.finishCallExpression(T, a.optionalChainMember);
                  }
                  let y = this.state.type;
                  if (y === 48 || y === 52 || y !== 10 && He(y) && !this.hasPrecedingLineBreak()) return;
                  let g = this.startNodeAt(s);
                  return g.expression = e, g.typeParameters = c2, this.finishNode(g, "TSInstantiationExpression");
                });
                if (o && this.unexpected(o, 10), u) return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(I.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }), u;
              }
              return super.parseSubscript(e, s, i, a);
            }
            parseNewCallee(e) {
              var s;
              super.parseNewCallee(e);
              let { callee: i } = e;
              i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (e.typeParameters = i.typeParameters, e.callee = i.expression);
            }
            parseExprOp(e, s, i) {
              let a;
              if (at(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(118)))) {
                let n = this.startNodeAt(s);
                return n.expression = e, n.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(f.UnexpectedKeyword, { at: this.state.startLoc, keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n, s, i);
              }
              return super.parseExprOp(e, s, i);
            }
            checkReservedWord(e, s, i, a) {
              this.state.isAmbientContext || super.checkReservedWord(e, s, i, a);
            }
            checkImportReflection(e) {
              super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(I.ImportReflectionHasImportType, { at: e.specifiers[0].loc.start });
            }
            checkDuplicateExports() {
            }
            parseImport(e) {
              if (e.importKind = "value", q(this.state.type) || this.match(55) || this.match(5)) {
                let i = this.lookahead();
                if (this.isContextual(128) && i.type !== 12 && i.type !== 97 && i.type !== 29 && (e.importKind = "type", this.next(), i = this.lookahead()), q(this.state.type) && i.type === 29) return this.tsParseImportEqualsDeclaration(e);
              }
              let s = super.parseImport(e);
              return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(I.TypeImportCannotSpecifyDefaultAndNamed, { at: s }), s;
            }
            parseExport(e, s) {
              if (this.match(83)) return this.next(), this.isContextual(128) && this.lookaheadCharCode() !== 61 ? (e.importKind = "type", this.next()) : e.importKind = "value", this.tsParseImportEqualsDeclaration(e, true);
              if (this.eat(29)) {
                let i = e;
                return i.expression = super.parseExpression(), this.semicolon(), this.finishNode(i, "TSExportAssignment");
              } else if (this.eatContextual(93)) {
                let i = e;
                return this.expectContextual(126), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
              } else {
                if (e.exportKind = "value", this.isContextual(128)) {
                  let i = this.lookaheadCharCode();
                  (i === 123 || i === 42) && (this.next(), e.exportKind = "type");
                }
                return super.parseExport(e, s);
              }
            }
            isAbstractClass() {
              return this.isContextual(122) && this.lookahead().type === 80;
            }
            parseExportDefaultExpression() {
              if (this.isAbstractClass()) {
                let e = this.startNode();
                return this.next(), e.abstract = true, this.parseClass(e, true, true);
              }
              if (this.match(127)) {
                let e = this.tsParseInterfaceDeclaration(this.startNode());
                if (e) return e;
              }
              return super.parseExportDefaultExpression();
            }
            parseVarStatement(e, s) {
              let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, { isAmbientContext: a } = this.state, n = super.parseVarStatement(e, s, i || a);
              if (!a) return n;
              for (let { id: o, init: u } of n.declarations) u && (s !== "const" || o.typeAnnotation ? this.raise(I.InitializerNotAllowedInAmbientContext, { at: u }) : ph(u, this.hasPlugin("estree")) || this.raise(I.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: u }));
              return n;
            }
            parseStatementContent(e, s) {
              if (this.match(75) && this.isLookaheadContextual("enum")) {
                let i = this.startNode();
                return this.expect(75), this.tsParseEnumDeclaration(i, { const: true });
              }
              if (this.isContextual(124)) return this.tsParseEnumDeclaration(this.startNode());
              if (this.isContextual(127)) {
                let i = this.tsParseInterfaceDeclaration(this.startNode());
                if (i) return i;
              }
              return super.parseStatementContent(e, s);
            }
            parseAccessModifier() {
              return this.tsParseModifier(["public", "protected", "private"]);
            }
            tsHasSomeModifiers(e, s) {
              return s.some((i) => Hr(i) ? e.accessibility === i : !!e[i]);
            }
            tsIsStartOfStaticBlocks() {
              return this.isContextual(104) && this.lookaheadCharCode() === 123;
            }
            parseClassMember(e, s, i) {
              let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
              this.tsParseModifiers({ allowedModifiers: a, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: I.InvalidModifierOnTypeParameterPositions }, s);
              let n = () => {
                this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(I.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), super.parseClassStaticBlock(e, s)) : this.parseClassMemberWithIsStatic(e, s, i, !!s.static);
              };
              s.declare ? this.tsInAmbientContext(n) : n();
            }
            parseClassMemberWithIsStatic(e, s, i, a) {
              let n = this.tsTryParseIndexSignature(s);
              if (n) {
                e.body.push(n), s.abstract && this.raise(I.IndexSignatureHasAbstract, { at: s }), s.accessibility && this.raise(I.IndexSignatureHasAccessibility, { at: s, modifier: s.accessibility }), s.declare && this.raise(I.IndexSignatureHasDeclare, { at: s }), s.override && this.raise(I.IndexSignatureHasOverride, { at: s });
                return;
              }
              !this.state.inAbstractClass && s.abstract && this.raise(I.NonAbstractClassHasAbstractMethod, { at: s }), s.override && (i.hadSuperClass || this.raise(I.OverrideNotInSubClass, { at: s })), super.parseClassMemberWithIsStatic(e, s, i, a);
            }
            parsePostMemberNameModifiers(e) {
              this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(I.ClassMethodHasReadonly, { at: e }), e.declare && this.match(10) && this.raise(I.ClassMethodHasDeclare, { at: e });
            }
            parseExpressionStatement(e, s, i) {
              return (s.type === "Identifier" ? this.tsParseExpressionStatement(e, s, i) : void 0) || super.parseExpressionStatement(e, s, i);
            }
            shouldParseExportDeclaration() {
              return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
            }
            parseConditional(e, s, i) {
              if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e, s, i);
              let a = this.tryParse(() => super.parseConditional(e, s));
              return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), e);
            }
            parseParenItem(e, s) {
              if (e = super.parseParenItem(e, s), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
                let i = this.startNodeAt(s);
                return i.expression = e, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
              }
              return e;
            }
            parseExportDeclaration(e) {
              if (!this.state.isAmbientContext && this.isContextual(123)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
              let s = this.state.startLoc, i = this.eatContextual(123);
              if (i && (this.isContextual(123) || !this.shouldParseExportDeclaration())) throw this.raise(I.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
              let n = q(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
              return n ? ((n.type === "TSInterfaceDeclaration" || n.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && (this.resetStartLocation(n, s), n.declare = true), n) : null;
            }
            parseClassId(e, s, i, a) {
              if ((!s || i) && this.isContextual(111)) return;
              super.parseClassId(e, s, i, e.declare ? br : vr);
              let n = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
              n && (e.typeParameters = n);
            }
            parseClassPropertyAnnotation(e) {
              e.optional || (this.eat(35) ? e.definite = true : this.eat(17) && (e.optional = true));
              let s = this.tsTryParseTypeAnnotation();
              s && (e.typeAnnotation = s);
            }
            parseClassProperty(e) {
              if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(I.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), e.abstract && this.match(29)) {
                let { key: s } = e;
                this.raise(I.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: s.type === "Identifier" && !e.computed ? s.name : `[${this.input.slice(s.start, s.end)}]` });
              }
              return super.parseClassProperty(e);
            }
            parseClassPrivateProperty(e) {
              return e.abstract && this.raise(I.PrivateElementHasAbstract, { at: e }), e.accessibility && this.raise(I.PrivateElementHasAccessibility, { at: e, modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
            }
            parseClassAccessorProperty(e) {
              return this.parseClassPropertyAnnotation(e), e.optional && this.raise(I.AccessorCannotBeOptional, { at: e }), super.parseClassAccessorProperty(e);
            }
            pushClassMethod(e, s, i, a, n, o) {
              let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              u && n && this.raise(I.ConstructorHasTypeParameters, { at: u });
              let { declare: c2 = false, kind: y } = s;
              c2 && (y === "get" || y === "set") && this.raise(I.DeclareAccessor, { at: s, kind: y }), u && (s.typeParameters = u), super.pushClassMethod(e, s, i, a, n, o);
            }
            pushClassPrivateMethod(e, s, i, a) {
              let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              n && (s.typeParameters = n), super.pushClassPrivateMethod(e, s, i, a);
            }
            declareClassPrivateMethodInScope(e, s) {
              e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !e.value.body || super.declareClassPrivateMethodInScope(e, s));
            }
            parseClassSuper(e) {
              super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(111) && (e.implements = this.tsParseHeritageClause("implements"));
            }
            parseObjPropValue(e, s, i, a, n, o, u) {
              let c2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              return c2 && (e.typeParameters = c2), super.parseObjPropValue(e, s, i, a, n, o, u);
            }
            parseFunctionParams(e, s) {
              let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              i && (e.typeParameters = i), super.parseFunctionParams(e, s);
            }
            parseVarId(e, s) {
              super.parseVarId(e, s), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
              let i = this.tsTryParseTypeAnnotation();
              i && (e.id.typeAnnotation = i, this.resetEndLocation(e.id));
            }
            parseAsyncArrowFromCallExpression(e, s) {
              return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, s);
            }
            parseMaybeAssign(e, s) {
              var i, a, n, o, u, c2, y;
              let g, T, C;
              if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                if (g = this.state.clone(), T = this.tryParse(() => super.parseMaybeAssign(e, s), g), !T.error) return T.node;
                let { context: K } = this.state, W = K[K.length - 1];
                (W === x.j_oTag || W === x.j_expr) && K.pop();
              }
              if (!((i = T) != null && i.error) && !this.match(47)) return super.parseMaybeAssign(e, s);
              (!g || g === this.state) && (g = this.state.clone());
              let M, j = this.tryParse((K) => {
                var W, V;
                M = this.tsParseTypeParameters(this.tsParseConstModifier);
                let X = super.parseMaybeAssign(e, s);
                return (X.type !== "ArrowFunctionExpression" || (W = X.extra) != null && W.parenthesized) && K(), ((V = M) == null ? void 0 : V.params.length) !== 0 && this.resetStartLocationFromNode(X, M), X.typeParameters = M, X;
              }, g);
              if (!j.error && !j.aborted) return M && this.reportReservedArrowTypeParam(M), j.node;
              if (!T && ($r(!this.hasPlugin("jsx")), C = this.tryParse(() => super.parseMaybeAssign(e, s), g), !C.error)) return C.node;
              if ((a = T) != null && a.node) return this.state = T.failState, T.node;
              if (j.node) return this.state = j.failState, M && this.reportReservedArrowTypeParam(M), j.node;
              if ((n = C) != null && n.node) return this.state = C.failState, C.node;
              throw (o = T) != null && o.thrown ? T.error : j.thrown ? j.error : (u = C) != null && u.thrown ? C.error : ((c2 = T) == null ? void 0 : c2.error) || j.error || ((y = C) == null ? void 0 : y.error);
            }
            reportReservedArrowTypeParam(e) {
              var s;
              e.params.length === 1 && !e.params[0].constraint && !((s = e.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(I.ReservedArrowTypeParam, { at: e });
            }
            parseMaybeUnary(e, s) {
              return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, s);
            }
            parseArrow(e) {
              if (this.match(14)) {
                let s = this.tryParse((i) => {
                  let a = this.tsParseTypeOrTypePredicateAnnotation(14);
                  return (this.canInsertSemicolon() || !this.match(19)) && i(), a;
                });
                if (s.aborted) return;
                s.thrown || (s.error && (this.state = s.failState), e.returnType = s.node);
              }
              return super.parseArrow(e);
            }
            parseAssignableListItemTypes(e, s) {
              if (!(s & 2)) return e;
              this.eat(17) && (e.optional = true);
              let i = this.tsTryParseTypeAnnotation();
              return i && (e.typeAnnotation = i), this.resetEndLocation(e), e;
            }
            isAssignable(e, s) {
              switch (e.type) {
                case "TSTypeCastExpression":
                  return this.isAssignable(e.expression, s);
                case "TSParameterProperty":
                  return true;
                default:
                  return super.isAssignable(e, s);
              }
            }
            toAssignable(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              switch (e.type) {
                case "ParenthesizedExpression":
                  this.toAssignableParenthesizedExpression(e, s);
                  break;
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                  s ? this.expressionScope.recordArrowParameterBindingError(I.UnexpectedTypeCastInParameter, { at: e }) : this.raise(I.UnexpectedTypeCastInParameter, { at: e }), this.toAssignable(e.expression, s);
                  break;
                case "AssignmentExpression":
                  !s && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
                default:
                  super.toAssignable(e, s);
              }
            }
            toAssignableParenthesizedExpression(e, s) {
              switch (e.expression.type) {
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                case "ParenthesizedExpression":
                  this.toAssignable(e.expression, s);
                  break;
                default:
                  super.toAssignable(e, s);
              }
            }
            checkToRestConversion(e, s) {
              switch (e.type) {
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSTypeAssertion":
                case "TSNonNullExpression":
                  this.checkToRestConversion(e.expression, false);
                  break;
                default:
                  super.checkToRestConversion(e, s);
              }
            }
            isValidLVal(e, s, i) {
              return nh({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (i !== Pe || !s) && ["expression", true], TSSatisfiesExpression: (i !== Pe || !s) && ["expression", true], TSTypeAssertion: (i !== Pe || !s) && ["expression", true] }, e) || super.isValidLVal(e, s, i);
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 78:
                  return this.parseIdentifier(true);
                default:
                  return super.parseBindingAtom();
              }
            }
            parseMaybeDecoratorArguments(e) {
              if (this.match(47) || this.match(51)) {
                let s = this.tsParseTypeArgumentsInExpression();
                if (this.match(10)) {
                  let i = super.parseMaybeDecoratorArguments(e);
                  return i.typeParameters = s, i;
                }
                this.unexpected(null, 10);
              }
              return super.parseMaybeDecoratorArguments(e);
            }
            checkCommaAfterRest(e) {
              return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
            }
            isClassMethod() {
              return this.match(47) || super.isClassMethod();
            }
            isClassProperty() {
              return this.match(35) || this.match(14) || super.isClassProperty();
            }
            parseMaybeDefault(e, s) {
              let i = super.parseMaybeDefault(e, s);
              return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(I.TypeAnnotationAfterAssign, { at: i.typeAnnotation }), i;
            }
            getTokenFromCode(e) {
              if (this.state.inType) {
                if (e === 62) {
                  this.finishOp(48, 1);
                  return;
                }
                if (e === 60) {
                  this.finishOp(47, 1);
                  return;
                }
              }
              super.getTokenFromCode(e);
            }
            reScan_lt_gt() {
              let { type: e } = this.state;
              e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
            }
            reScan_lt() {
              let { type: e } = this.state;
              return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
            }
            toAssignableList(e, s, i) {
              for (let a = 0; a < e.length; a++) {
                let n = e[a];
                (n == null ? void 0 : n.type) === "TSTypeCastExpression" && (e[a] = this.typeCastToParameter(n));
              }
              super.toAssignableList(e, s, i);
            }
            typeCastToParameter(e) {
              return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
            }
            shouldParseArrow(e) {
              return this.match(14) ? e.every((s) => this.isAssignable(s, true)) : super.shouldParseArrow(e);
            }
            shouldParseAsyncArrow() {
              return this.match(14) || super.shouldParseAsyncArrow();
            }
            canHaveLeadingDecorator() {
              return super.canHaveLeadingDecorator() || this.isAbstractClass();
            }
            jsxParseOpeningElementAfterName(e) {
              if (this.match(47) || this.match(51)) {
                let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
                s && (e.typeParameters = s);
              }
              return super.jsxParseOpeningElementAfterName(e);
            }
            getGetterSetterExpectedParamCount(e) {
              let s = super.getGetterSetterExpectedParamCount(e), a = this.getObjectOrClassMethodParams(e)[0];
              return a && this.isThisParam(a) ? s + 1 : s;
            }
            parseCatchClauseParam() {
              let e = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
              return s && (e.typeAnnotation = s, this.resetEndLocation(e)), e;
            }
            tsInAmbientContext(e) {
              let s = this.state.isAmbientContext;
              this.state.isAmbientContext = true;
              try {
                return e();
              } finally {
                this.state.isAmbientContext = s;
              }
            }
            parseClass(e, s, i) {
              let a = this.state.inAbstractClass;
              this.state.inAbstractClass = !!e.abstract;
              try {
                return super.parseClass(e, s, i);
              } finally {
                this.state.inAbstractClass = a;
              }
            }
            tsParseAbstractDeclaration(e, s) {
              if (this.match(80)) return e.abstract = true, this.maybeTakeDecorators(s, this.parseClass(e, true, false));
              if (this.isContextual(127)) {
                if (!this.hasFollowingLineBreak()) return e.abstract = true, this.raise(I.NonClassMethodPropertyHasAbstractModifer, { at: e }), this.tsParseInterfaceDeclaration(e);
              } else this.unexpected(null, 80);
            }
            parseMethod(e, s, i, a, n, o, u) {
              let c2 = super.parseMethod(e, s, i, a, n, o, u);
              if (c2.abstract && (this.hasPlugin("estree") ? !!c2.value.body : !!c2.body)) {
                let { key: g } = c2;
                this.raise(I.AbstractMethodHasImplementation, { at: c2, methodName: g.type === "Identifier" && !c2.computed ? g.name : `[${this.input.slice(g.start, g.end)}]` });
              }
              return c2;
            }
            tsParseTypeParameterName() {
              return this.parseIdentifier().name;
            }
            shouldParseAsAmbientContext() {
              return !!this.getPluginOption("typescript", "dts");
            }
            parse() {
              return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
            }
            getExpression() {
              return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
            }
            parseExportSpecifier(e, s, i, a) {
              return !s && a ? (this.parseTypeOnlyImportExportSpecifier(e, false, i), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, s, i, a));
            }
            parseImportSpecifier(e, s, i, a, n) {
              return !s && a ? (this.parseTypeOnlyImportExportSpecifier(e, true, i), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, s, i, a, i ? Sr : Ve));
            }
            parseTypeOnlyImportExportSpecifier(e, s, i) {
              let a = s ? "imported" : "local", n = s ? "local" : "exported", o = e[a], u, c2 = false, y = true, g = o.loc.start;
              if (this.isContextual(93)) {
                let C = this.parseIdentifier();
                if (this.isContextual(93)) {
                  let M = this.parseIdentifier();
                  te(this.state.type) ? (c2 = true, o = C, u = s ? this.parseIdentifier() : this.parseModuleExportName(), y = false) : (u = M, y = false);
                } else te(this.state.type) ? (y = false, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c2 = true, o = C);
              } else te(this.state.type) && (c2 = true, s ? (o = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, true, true)) : o = this.parseModuleExportName());
              c2 && i && this.raise(s ? I.TypeModifierIsUsedInTypeImports : I.TypeModifierIsUsedInTypeExports, { at: g }), e[a] = o, e[n] = u;
              let T = s ? "importKind" : "exportKind";
              e[T] = c2 ? "type" : "value", y && this.eatContextual(93) && (e[n] = s ? this.parseIdentifier() : this.parseModuleExportName()), e[n] || (e[n] = me(e[a])), s && this.checkIdentifier(e[n], c2 ? Sr : Ve);
            }
          };
          function ch(t) {
            if (t.type !== "MemberExpression") return false;
            let { computed: r2, property: e } = t;
            return r2 && e.type !== "StringLiteral" && (e.type !== "TemplateLiteral" || e.expressions.length > 0) ? false : Vr(t.object);
          }
          function ph(t, r2) {
            var e;
            let { type: s } = t;
            if ((e = t.extra) != null && e.parenthesized) return false;
            if (r2) {
              if (s === "Literal") {
                let { value: i } = t;
                if (typeof i == "string" || typeof i == "boolean") return true;
              }
            } else if (s === "StringLiteral" || s === "BooleanLiteral") return true;
            return !!(zr(t, r2) || fh(t, r2) || s === "TemplateLiteral" && t.expressions.length === 0 || ch(t));
          }
          function zr(t, r2) {
            return r2 ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLiteral";
          }
          function fh(t, r2) {
            if (t.type === "UnaryExpression") {
              let { operator: e, argument: s } = t;
              if (e === "-" && zr(s, r2)) return true;
            }
            return false;
          }
          function Vr(t) {
            return t.type === "Identifier" ? true : t.type !== "MemberExpression" || t.computed ? false : Vr(t.object);
          }
          var Kr = pe`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), dh = (t) => class extends t {
            parsePlaceholder(e) {
              if (this.match(142)) {
                let s = this.startNode();
                return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(142), this.finishPlaceholder(s, e);
              }
            }
            finishPlaceholder(e, s) {
              let i = !!(e.expectedNode && e.type === "Placeholder");
              return e.expectedNode = s, i ? e : this.finishNode(e, "Placeholder");
            }
            getTokenFromCode(e) {
              e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(142, 2) : super.getTokenFromCode(e);
            }
            parseExprAtom(e) {
              return this.parsePlaceholder("Expression") || super.parseExprAtom(e);
            }
            parseIdentifier(e) {
              return this.parsePlaceholder("Identifier") || super.parseIdentifier(e);
            }
            checkReservedWord(e, s, i, a) {
              e !== void 0 && super.checkReservedWord(e, s, i, a);
            }
            parseBindingAtom() {
              return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
            }
            isValidLVal(e, s, i) {
              return e === "Placeholder" || super.isValidLVal(e, s, i);
            }
            toAssignable(e, s) {
              e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(e, s);
            }
            chStartsBindingIdentifier(e, s) {
              return !!(super.chStartsBindingIdentifier(e, s) || this.lookahead().type === 142);
            }
            verifyBreakContinue(e, s) {
              e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(e, s);
            }
            parseExpressionStatement(e, s) {
              if (s.type !== "Placeholder" || s.extra && s.extra.parenthesized) return super.parseExpressionStatement(e, s);
              if (this.match(14)) {
                let i = e;
                return i.label = this.finishPlaceholder(s, "Identifier"), this.next(), i.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(i, "LabeledStatement");
              }
              return this.semicolon(), e.name = s.name, this.finishPlaceholder(e, "Statement");
            }
            parseBlock(e, s, i) {
              return this.parsePlaceholder("BlockStatement") || super.parseBlock(e, s, i);
            }
            parseFunctionId(e) {
              return this.parsePlaceholder("Identifier") || super.parseFunctionId(e);
            }
            parseClass(e, s, i) {
              let a = s ? "ClassDeclaration" : "ClassExpression";
              this.next();
              let n = this.state.strict, o = this.parsePlaceholder("Identifier");
              if (o) if (this.match(81) || this.match(142) || this.match(5)) e.id = o;
              else {
                if (i || !s) return e.id = null, e.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(e, a);
                throw this.raise(Kr.ClassNameIsRequired, { at: this.state.startLoc });
              }
              else this.parseClassId(e, s, i);
              return super.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e.superClass, n), this.finishNode(e, a);
            }
            parseExport(e, s) {
              let i = this.parsePlaceholder("Identifier");
              if (!i) return super.parseExport(e, s);
              if (!this.isContextual(97) && !this.match(12)) return e.specifiers = [], e.source = null, e.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(e, "ExportNamedDeclaration");
              this.expectPlugin("exportDefaultFrom");
              let a = this.startNode();
              return a.exported = i, e.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(e, s);
            }
            isExportDefaultSpecifier() {
              if (this.match(65)) {
                let e = this.nextTokenStart();
                if (this.isUnparsedContextual(e, "from") && this.input.startsWith(xe(142), this.nextTokenStartSince(e + 4))) return true;
              }
              return super.isExportDefaultSpecifier();
            }
            maybeParseExportDefaultSpecifier(e) {
              return e.specifiers && e.specifiers.length > 0 ? true : super.maybeParseExportDefaultSpecifier(e);
            }
            checkExport(e) {
              let { specifiers: s } = e;
              s != null && s.length && (e.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = s;
            }
            parseImport(e) {
              let s = this.parsePlaceholder("Identifier");
              if (!s) return super.parseImport(e);
              if (e.specifiers = [], !this.isContextual(97) && !this.match(12)) return e.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
              let i = this.startNodeAtNode(s);
              return i.local = s, e.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(97), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
            }
            parseImportSource() {
              return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
            }
            assertNoSpace() {
              this.state.start > this.state.lastTokEndLoc.index && this.raise(Kr.UnexpectedSpace, { at: this.state.lastTokEndLoc });
            }
          }, mh = (t) => class extends t {
            parseV8Intrinsic() {
              if (this.match(54)) {
                let e = this.state.startLoc, s = this.startNode();
                if (this.next(), q(this.state.type)) {
                  let i = this.parseIdentifierName(), a = this.createIdentifier(s, i);
                  if (a.type = "V8IntrinsicIdentifier", this.match(10)) return a;
                }
                this.unexpected(e);
              }
            }
            parseExprAtom(e) {
              return this.parseV8Intrinsic() || super.parseExprAtom(e);
            }
          };
          function J(t, r2) {
            let [e, s] = typeof r2 == "string" ? [r2, {}] : r2, i = Object.keys(s), a = i.length === 0;
            return t.some((n) => {
              if (typeof n == "string") return a && n === e;
              {
                let [o, u] = n;
                if (o !== e) return false;
                for (let c2 of i) if (u[c2] !== s[c2]) return false;
                return true;
              }
            });
          }
          function we(t, r2, e) {
            let s = t.find((i) => Array.isArray(i) ? i[0] === r2 : i === r2);
            return s && Array.isArray(s) && s.length > 1 ? s[1][e] : null;
          }
          var Wr = ["minimal", "fsharp", "hack", "smart"], Gr = ["^^", "@@", "^", "%", "#"], Jr = ["hash", "bar"];
          function yh(t) {
            if (J(t, "decorators")) {
              if (J(t, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              let r2 = we(t, "decorators", "decoratorsBeforeExport");
              if (r2 != null && typeof r2 != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
              let e = we(t, "decorators", "allowCallParenthesized");
              if (e != null && typeof e != "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
            }
            if (J(t, "flow") && J(t, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
            if (J(t, "placeholders") && J(t, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (J(t, "pipelineOperator")) {
              let r2 = we(t, "pipelineOperator", "proposal");
              if (!Wr.includes(r2)) {
                let s = Wr.map((i) => `"${i}"`).join(", ");
                throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s}.`);
              }
              let e = J(t, ["recordAndTuple", { syntaxType: "hash" }]);
              if (r2 === "hack") {
                if (J(t, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (J(t, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                let s = we(t, "pipelineOperator", "topicToken");
                if (!Gr.includes(s)) {
                  let i = Gr.map((a) => `"${a}"`).join(", ");
                  throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i}.`);
                }
                if (s === "#" && e) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
              } else if (r2 === "smart" && e) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
            if (J(t, "moduleAttributes")) {
              if (J(t, "importAssertions")) throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
              if (we(t, "moduleAttributes", "version") !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (J(t, "recordAndTuple") && we(t, "recordAndTuple", "syntaxType") != null && !Jr.includes(we(t, "recordAndTuple", "syntaxType"))) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Jr.map((r2) => `'${r2}'`).join(", "));
            if (J(t, "asyncDoExpressions") && !J(t, "doExpressions")) {
              let r2 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              throw r2.missingPlugins = "doExpressions", r2;
            }
          }
          var Xr = { estree: el, jsx: th, flow: Zl, typescript: uh, v8intrinsic: mh, placeholders: dh }, xh = Object.keys(Xr), gh = class extends ah {
            checkProto(t, r2, e, s) {
              if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand) return;
              let i = t.key;
              if ((i.type === "Identifier" ? i.name : i.value) === "__proto__") {
                if (r2) {
                  this.raise(f.RecordNoProto, { at: i });
                  return;
                }
                e.used && (s ? s.doubleProtoLoc === null && (s.doubleProtoLoc = i.loc.start) : this.raise(f.DuplicateProto, { at: i })), e.used = true;
              }
            }
            shouldExitDescending(t, r2) {
              return t.type === "ArrowFunctionExpression" && t.start === r2;
            }
            getExpression() {
              this.enterInitialScopes(), this.nextToken();
              let t = this.parseExpression();
              return this.match(137) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.state.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
            }
            parseExpression(t, r2) {
              return t ? this.disallowInAnd(() => this.parseExpressionBase(r2)) : this.allowInAnd(() => this.parseExpressionBase(r2));
            }
            parseExpressionBase(t) {
              let r2 = this.state.startLoc, e = this.parseMaybeAssign(t);
              if (this.match(12)) {
                let s = this.startNodeAt(r2);
                for (s.expressions = [e]; this.eat(12); ) s.expressions.push(this.parseMaybeAssign(t));
                return this.toReferencedList(s.expressions), this.finishNode(s, "SequenceExpression");
              }
              return e;
            }
            parseMaybeAssignDisallowIn(t, r2) {
              return this.disallowInAnd(() => this.parseMaybeAssign(t, r2));
            }
            parseMaybeAssignAllowIn(t, r2) {
              return this.allowInAnd(() => this.parseMaybeAssign(t, r2));
            }
            setOptionalParametersError(t, r2) {
              var e;
              t.optionalParametersLoc = (e = r2 == null ? void 0 : r2.loc) != null ? e : this.state.startLoc;
            }
            parseMaybeAssign(t, r2) {
              let e = this.state.startLoc;
              if (this.isContextual(106) && this.prodParam.hasYield) {
                let n = this.parseYield();
                return r2 && (n = r2.call(this, n, e)), n;
              }
              let s;
              t ? s = false : (t = new vt(), s = true);
              let { type: i } = this.state;
              (i === 10 || q(i)) && (this.state.potentialArrowAt = this.state.start);
              let a = this.parseMaybeConditional(t);
              if (r2 && (a = r2.call(this, a, e)), Bo(this.state.type)) {
                let n = this.startNodeAt(e), o = this.state.value;
                if (n.operator = o, this.match(29)) {
                  this.toAssignable(a, true), n.left = a;
                  let u = e.index;
                  t.doubleProtoLoc != null && t.doubleProtoLoc.index >= u && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= u && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= u && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
                } else n.left = a;
                return this.next(), n.right = this.parseMaybeAssign(), this.checkLVal(a, { in: this.finishNode(n, "AssignmentExpression") }), n;
              } else s && this.checkExpressionErrors(t, true);
              return a;
            }
            parseMaybeConditional(t) {
              let r2 = this.state.startLoc, e = this.state.potentialArrowAt, s = this.parseExprOps(t);
              return this.shouldExitDescending(s, e) ? s : this.parseConditional(s, r2, t);
            }
            parseConditional(t, r2, e) {
              if (this.eat(17)) {
                let s = this.startNodeAt(r2);
                return s.test = t, s.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), s.alternate = this.parseMaybeAssign(), this.finishNode(s, "ConditionalExpression");
              }
              return t;
            }
            parseMaybeUnaryOrPrivate(t) {
              return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(t);
            }
            parseExprOps(t) {
              let r2 = this.state.startLoc, e = this.state.potentialArrowAt, s = this.parseMaybeUnaryOrPrivate(t);
              return this.shouldExitDescending(s, e) ? s : this.parseExprOp(s, r2, -1);
            }
            parseExprOp(t, r2, e) {
              if (this.isPrivateName(t)) {
                let i = this.getPrivateNameSV(t);
                (e >= at(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(f.PrivateInExpectedIn, { at: t, identifierName: i }), this.classScope.usePrivateName(i, t.loc.start);
              }
              let s = this.state.type;
              if (_o(s) && (this.prodParam.hasIn || !this.match(58))) {
                let i = at(s);
                if (i > e) {
                  if (s === 39) {
                    if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return t;
                    this.checkPipelineAtInfixOperator(t, r2);
                  }
                  let a = this.startNodeAt(r2);
                  a.left = t, a.operator = this.state.value;
                  let n = s === 41 || s === 42, o = s === 40;
                  if (o && (i = at(42)), this.next(), s === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait) throw this.raise(f.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
                  a.right = this.parseExprOpRightExpr(s, i);
                  let u = this.finishNode(a, n || o ? "LogicalExpression" : "BinaryExpression"), c2 = this.state.type;
                  if (o && (c2 === 41 || c2 === 42) || n && c2 === 40) throw this.raise(f.MixingCoalesceWithLogical, { at: this.state.startLoc });
                  return this.parseExprOp(u, r2, e);
                }
              }
              return t;
            }
            parseExprOpRightExpr(t, r2) {
              let e = this.state.startLoc;
              switch (t) {
                case 39:
                  switch (this.getPluginOption("pipelineOperator", "proposal")) {
                    case "hack":
                      return this.withTopicBindingContext(() => this.parseHackPipeBody());
                    case "smart":
                      return this.withTopicBindingContext(() => {
                        if (this.prodParam.hasYield && this.isContextual(106)) throw this.raise(f.PipeBodyIsTighter, { at: this.state.startLoc });
                        return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r2), e);
                      });
                    case "fsharp":
                      return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r2));
                  }
                default:
                  return this.parseExprOpBaseRightExpr(t, r2);
              }
            }
            parseExprOpBaseRightExpr(t, r2) {
              let e = this.state.startLoc;
              return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, $o(t) ? r2 - 1 : r2);
            }
            parseHackPipeBody() {
              var t;
              let { startLoc: r2 } = this.state, e = this.parseMaybeAssign();
              return Go.has(e.type) && !((t = e.extra) != null && t.parenthesized) && this.raise(f.PipeUnparenthesizedBody, { at: r2, type: e.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(f.PipeTopicUnused, { at: r2 }), e;
            }
            checkExponentialAfterUnary(t) {
              this.match(57) && this.raise(f.UnexpectedTokenUnaryExponentiation, { at: t.argument });
            }
            parseMaybeUnary(t, r2) {
              let e = this.state.startLoc, s = this.isContextual(96);
              if (s && this.isAwaitAllowed()) {
                this.next();
                let o = this.parseAwait(e);
                return r2 || this.checkExponentialAfterUnary(o), o;
              }
              let i = this.match(34), a = this.startNode();
              if (jo(this.state.type)) {
                a.operator = this.state.value, a.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
                let o = this.match(89);
                if (this.next(), a.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t, true), this.state.strict && o) {
                  let u = a.argument;
                  u.type === "Identifier" ? this.raise(f.StrictDelete, { at: a }) : this.hasPropertyAsPrivateName(u) && this.raise(f.DeletePrivateField, { at: a });
                }
                if (!i) return r2 || this.checkExponentialAfterUnary(a), this.finishNode(a, "UnaryExpression");
              }
              let n = this.parseUpdate(a, i, t);
              if (s) {
                let { type: o } = this.state;
                if ((this.hasPlugin("v8intrinsic") ? He(o) : He(o) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(f.AwaitNotInAsyncContext, { at: e }), this.parseAwait(e);
              }
              return n;
            }
            parseUpdate(t, r2, e) {
              if (r2) {
                let a = t;
                return this.checkLVal(a.argument, { in: this.finishNode(a, "UpdateExpression") }), t;
              }
              let s = this.state.startLoc, i = this.parseExprSubscripts(e);
              if (this.checkExpressionErrors(e, false)) return i;
              for (; Ro(this.state.type) && !this.canInsertSemicolon(); ) {
                let a = this.startNodeAt(s);
                a.operator = this.state.value, a.prefix = false, a.argument = i, this.next(), this.checkLVal(i, { in: i = this.finishNode(a, "UpdateExpression") });
              }
              return i;
            }
            parseExprSubscripts(t) {
              let r2 = this.state.startLoc, e = this.state.potentialArrowAt, s = this.parseExprAtom(t);
              return this.shouldExitDescending(s, e) ? s : this.parseSubscripts(s, r2);
            }
            parseSubscripts(t, r2, e) {
              let s = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t), stop: false };
              do
                t = this.parseSubscript(t, r2, e, s), s.maybeAsyncArrow = false;
              while (!s.stop);
              return t;
            }
            parseSubscript(t, r2, e, s) {
              let { type: i } = this.state;
              if (!e && i === 15) return this.parseBind(t, r2, e, s);
              if (nt(i)) return this.parseTaggedTemplateExpression(t, r2, s);
              let a = false;
              if (i === 18) {
                if (e && (this.raise(f.OptionalChainingNoNew, { at: this.state.startLoc }), this.lookaheadCharCode() === 40)) return s.stop = true, t;
                s.optionalChainMember = a = true, this.next();
              }
              if (!e && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(t, r2, s, a);
              {
                let n = this.eat(0);
                return n || a || this.eat(16) ? this.parseMember(t, r2, s, n, a) : (s.stop = true, t);
              }
            }
            parseMember(t, r2, e, s, i) {
              let a = this.startNodeAt(r2);
              return a.object = t, a.computed = s, s ? (a.property = this.parseExpression(), this.expect(3)) : this.match(136) ? (t.type === "Super" && this.raise(f.SuperPrivateField, { at: r2 }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(true), e.optionalChainMember ? (a.optional = i, this.finishNode(a, "OptionalMemberExpression")) : this.finishNode(a, "MemberExpression");
            }
            parseBind(t, r2, e, s) {
              let i = this.startNodeAt(r2);
              return i.object = t, this.next(), i.callee = this.parseNoCallExpr(), s.stop = true, this.parseSubscripts(this.finishNode(i, "BindExpression"), r2, e);
            }
            parseCoverCallAndAsyncArrowHead(t, r2, e, s) {
              let i = this.state.maybeInArrowParameters, a = null;
              this.state.maybeInArrowParameters = true, this.next();
              let n = this.startNodeAt(r2);
              n.callee = t;
              let { maybeAsyncArrow: o, optionalChainMember: u } = e;
              o && (this.expressionScope.enter($l()), a = new vt()), u && (n.optional = s), s ? n.arguments = this.parseCallExpressionArguments(11) : n.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", n, a);
              let c2 = this.finishCallExpression(n, u);
              return o && this.shouldParseAsyncArrow() && !s ? (e.stop = true, this.checkDestructuringPrivate(a), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r2), c2)) : (o && (this.checkExpressionErrors(a, true), this.expressionScope.exit()), this.toReferencedArguments(c2)), this.state.maybeInArrowParameters = i, c2;
            }
            toReferencedArguments(t, r2) {
              this.toReferencedListDeep(t.arguments, r2);
            }
            parseTaggedTemplateExpression(t, r2, e) {
              let s = this.startNodeAt(r2);
              return s.tag = t, s.quasi = this.parseTemplate(true), e.optionalChainMember && this.raise(f.OptionalChainingNoTemplate, { at: r2 }), this.finishNode(s, "TaggedTemplateExpression");
            }
            atPossibleAsyncArrow(t) {
              return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
            }
            finishCallExpression(t, r2) {
              if (t.callee.type === "Import") if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), t.arguments.length === 0 || t.arguments.length > 2) this.raise(f.ImportCallArity, { at: t, maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
              else for (let e of t.arguments) e.type === "SpreadElement" && this.raise(f.ImportCallSpreadArgument, { at: e });
              return this.finishNode(t, r2 ? "OptionalCallExpression" : "CallExpression");
            }
            parseCallExpressionArguments(t, r2, e, s, i) {
              let a = [], n = true, o = this.state.inFSharpPipelineDirectBody;
              for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t); ) {
                if (n) n = false;
                else if (this.expect(12), this.match(t)) {
                  r2 && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(f.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), s && this.addTrailingCommaExtraToNode(s), this.next();
                  break;
                }
                a.push(this.parseExprListItem(false, i, e));
              }
              return this.state.inFSharpPipelineDirectBody = o, a;
            }
            shouldParseAsyncArrow() {
              return this.match(19) && !this.canInsertSemicolon();
            }
            parseAsyncArrowFromCallExpression(t, r2) {
              var e;
              return this.resetPreviousNodeTrailingComments(r2), this.expect(19), this.parseArrowExpression(t, r2.arguments, true, (e = r2.extra) == null ? void 0 : e.trailingCommaLoc), r2.innerComments && Ke(t, r2.innerComments), r2.callee.trailingComments && Ke(t, r2.callee.trailingComments), t;
            }
            parseNoCallExpr() {
              let t = this.state.startLoc;
              return this.parseSubscripts(this.parseExprAtom(), t, true);
            }
            parseExprAtom(t) {
              let r2, e = null, { type: s } = this.state;
              switch (s) {
                case 79:
                  return this.parseSuper();
                case 83:
                  return r2 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r2) : (this.match(10) || this.raise(f.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(r2, "Import"));
                case 78:
                  return r2 = this.startNode(), this.next(), this.finishNode(r2, "ThisExpression");
                case 90:
                  return this.parseDo(this.startNode(), false);
                case 56:
                case 31:
                  return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
                case 132:
                  return this.parseNumericLiteral(this.state.value);
                case 133:
                  return this.parseBigIntLiteral(this.state.value);
                case 134:
                  return this.parseDecimalLiteral(this.state.value);
                case 131:
                  return this.parseStringLiteral(this.state.value);
                case 84:
                  return this.parseNullLiteral();
                case 85:
                  return this.parseBooleanLiteral(true);
                case 86:
                  return this.parseBooleanLiteral(false);
                case 10: {
                  let i = this.state.potentialArrowAt === this.state.start;
                  return this.parseParenAndDistinguishExpression(i);
                }
                case 2:
                case 1:
                  return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
                case 0:
                  return this.parseArrayLike(3, true, false, t);
                case 6:
                case 7:
                  return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
                case 5:
                  return this.parseObjectLike(8, false, false, t);
                case 68:
                  return this.parseFunctionOrFunctionSent();
                case 26:
                  e = this.parseDecorators();
                case 80:
                  return this.parseClass(this.maybeTakeDecorators(e, this.startNode()), false);
                case 77:
                  return this.parseNewOrNewTarget();
                case 25:
                case 24:
                  return this.parseTemplate(false);
                case 15: {
                  r2 = this.startNode(), this.next(), r2.object = null;
                  let i = r2.callee = this.parseNoCallExpr();
                  if (i.type === "MemberExpression") return this.finishNode(r2, "BindExpression");
                  throw this.raise(f.UnsupportedBind, { at: i });
                }
                case 136:
                  return this.raise(f.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
                case 33:
                  return this.parseTopicReferenceThenEqualsSign(54, "%");
                case 32:
                  return this.parseTopicReferenceThenEqualsSign(44, "^");
                case 37:
                case 38:
                  return this.parseTopicReference("hack");
                case 44:
                case 54:
                case 27: {
                  let i = this.getPluginOption("pipelineOperator", "proposal");
                  if (i) return this.parseTopicReference(i);
                  this.unexpected();
                  break;
                }
                case 47: {
                  let i = this.input.codePointAt(this.nextTokenStart());
                  fe(i) || i === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                  break;
                }
                default:
                  if (q(s)) {
                    if (this.isContextual(125) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) return this.parseModuleExpression();
                    let i = this.state.potentialArrowAt === this.state.start, a = this.state.containsEsc, n = this.parseIdentifier();
                    if (!a && n.name === "async" && !this.canInsertSemicolon()) {
                      let { type: o } = this.state;
                      if (o === 68) return this.resetPreviousNodeTrailingComments(n), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(n));
                      if (q(o)) return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(n)) : n;
                      if (o === 90) return this.resetPreviousNodeTrailingComments(n), this.parseDo(this.startNodeAtNode(n), true);
                    }
                    return i && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(n), [n], false)) : n;
                  } else this.unexpected();
              }
            }
            parseTopicReferenceThenEqualsSign(t, r2) {
              let e = this.getPluginOption("pipelineOperator", "proposal");
              if (e) return this.state.type = t, this.state.value = r2, this.state.pos--, this.state.end--, this.state.endLoc = Y(this.state.endLoc, -1), this.parseTopicReference(e);
              this.unexpected();
            }
            parseTopicReference(t) {
              let r2 = this.startNode(), e = this.state.startLoc, s = this.state.type;
              return this.next(), this.finishTopicReference(r2, e, t, s);
            }
            finishTopicReference(t, r2, e, s) {
              if (this.testTopicReferenceConfiguration(e, r2, s)) {
                let i = e === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
                return this.topicReferenceIsAllowedInCurrentContext() || this.raise(e === "smart" ? f.PrimaryTopicNotAllowed : f.PipeTopicUnbound, { at: r2 }), this.registerTopicReference(), this.finishNode(t, i);
              } else throw this.raise(f.PipeTopicUnconfiguredToken, { at: r2, token: xe(s) });
            }
            testTopicReferenceConfiguration(t, r2, e) {
              switch (t) {
                case "hack":
                  return this.hasPlugin(["pipelineOperator", { topicToken: xe(e) }]);
                case "smart":
                  return e === 27;
                default:
                  throw this.raise(f.PipeTopicRequiresHackPipes, { at: r2 });
              }
            }
            parseAsyncArrowUnaryFunction(t) {
              this.prodParam.enter(Tt(true, this.prodParam.hasYield));
              let r2 = [this.parseIdentifier()];
              return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(f.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(t, r2, true);
            }
            parseDo(t, r2) {
              this.expectPlugin("doExpressions"), r2 && this.expectPlugin("asyncDoExpressions"), t.async = r2, this.next();
              let e = this.state.labels;
              return this.state.labels = [], r2 ? (this.prodParam.enter(At), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = e, this.finishNode(t, "DoExpression");
            }
            parseSuper() {
              let t = this.startNode();
              return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(f.SuperNotAllowed, { at: t }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(f.UnexpectedSuper, { at: t }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(f.UnsupportedSuper, { at: t }), this.finishNode(t, "Super");
            }
            parsePrivateName() {
              let t = this.startNode(), r2 = this.startNodeAt(Y(this.state.startLoc, 1)), e = this.state.value;
              return this.next(), t.id = this.createIdentifier(r2, e), this.finishNode(t, "PrivateName");
            }
            parseFunctionOrFunctionSent() {
              let t = this.startNode();
              if (this.next(), this.prodParam.hasYield && this.match(16)) {
                let r2 = this.createIdentifier(this.startNodeAtNode(t), "function");
                return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, r2, "sent");
              }
              return this.parseFunction(t);
            }
            parseMetaProperty(t, r2, e) {
              t.meta = r2;
              let s = this.state.containsEsc;
              return t.property = this.parseIdentifier(true), (t.property.name !== e || s) && this.raise(f.UnsupportedMetaProperty, { at: t.property, target: r2.name, onlyValidPropertyName: e }), this.finishNode(t, "MetaProperty");
            }
            parseImportMetaProperty(t) {
              let r2 = this.createIdentifier(this.startNodeAtNode(t), "import");
              return this.next(), this.isContextual(100) && (this.inModule || this.raise(f.ImportMetaOutsideModule, { at: r2 }), this.sawUnambiguousESM = true), this.parseMetaProperty(t, r2, "meta");
            }
            parseLiteralAtNode(t, r2, e) {
              return this.addExtra(e, "rawValue", t), this.addExtra(e, "raw", this.input.slice(e.start, this.state.end)), e.value = t, this.next(), this.finishNode(e, r2);
            }
            parseLiteral(t, r2) {
              let e = this.startNode();
              return this.parseLiteralAtNode(t, r2, e);
            }
            parseStringLiteral(t) {
              return this.parseLiteral(t, "StringLiteral");
            }
            parseNumericLiteral(t) {
              return this.parseLiteral(t, "NumericLiteral");
            }
            parseBigIntLiteral(t) {
              return this.parseLiteral(t, "BigIntLiteral");
            }
            parseDecimalLiteral(t) {
              return this.parseLiteral(t, "DecimalLiteral");
            }
            parseRegExpLiteral(t) {
              let r2 = this.parseLiteral(t.value, "RegExpLiteral");
              return r2.pattern = t.pattern, r2.flags = t.flags, r2;
            }
            parseBooleanLiteral(t) {
              let r2 = this.startNode();
              return r2.value = t, this.next(), this.finishNode(r2, "BooleanLiteral");
            }
            parseNullLiteral() {
              let t = this.startNode();
              return this.next(), this.finishNode(t, "NullLiteral");
            }
            parseParenAndDistinguishExpression(t) {
              let r2 = this.state.startLoc, e;
              this.next(), this.expressionScope.enter(Ul());
              let s = this.state.maybeInArrowParameters, i = this.state.inFSharpPipelineDirectBody;
              this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
              let a = this.state.startLoc, n = [], o = new vt(), u = true, c2, y;
              for (; !this.match(11); ) {
                if (u) u = false;
                else if (this.expect(12, o.optionalParametersLoc === null ? null : o.optionalParametersLoc), this.match(11)) {
                  y = this.state.startLoc;
                  break;
                }
                if (this.match(21)) {
                  let C = this.state.startLoc;
                  if (c2 = this.state.startLoc, n.push(this.parseParenItem(this.parseRestBinding(), C)), !this.checkCommaAfterRest(41)) break;
                } else n.push(this.parseMaybeAssignAllowIn(o, this.parseParenItem));
              }
              let g = this.state.lastTokEndLoc;
              this.expect(11), this.state.maybeInArrowParameters = s, this.state.inFSharpPipelineDirectBody = i;
              let T = this.startNodeAt(r2);
              return t && this.shouldParseArrow(n) && (T = this.parseArrow(T)) ? (this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(T, n, false), T) : (this.expressionScope.exit(), n.length || this.unexpected(this.state.lastTokStartLoc), y && this.unexpected(y), c2 && this.unexpected(c2), this.checkExpressionErrors(o, true), this.toReferencedListDeep(n, true), n.length > 1 ? (e = this.startNodeAt(a), e.expressions = n, this.finishNode(e, "SequenceExpression"), this.resetEndLocation(e, g)) : e = n[0], this.wrapParenthesis(r2, e));
            }
            wrapParenthesis(t, r2) {
              if (!this.options.createParenthesizedExpressions) return this.addExtra(r2, "parenthesized", true), this.addExtra(r2, "parenStart", t.index), this.takeSurroundingComments(r2, t.index, this.state.lastTokEndLoc.index), r2;
              let e = this.startNodeAt(t);
              return e.expression = r2, this.finishNode(e, "ParenthesizedExpression");
            }
            shouldParseArrow(t) {
              return !this.canInsertSemicolon();
            }
            parseArrow(t) {
              if (this.eat(19)) return t;
            }
            parseParenItem(t, r2) {
              return t;
            }
            parseNewOrNewTarget() {
              let t = this.startNode();
              if (this.next(), this.match(16)) {
                let r2 = this.createIdentifier(this.startNodeAtNode(t), "new");
                this.next();
                let e = this.parseMetaProperty(t, r2, "target");
                return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(f.UnexpectedNewTarget, { at: e }), e;
              }
              return this.parseNew(t);
            }
            parseNew(t) {
              if (this.parseNewCallee(t), this.eat(10)) {
                let r2 = this.parseExprList(11);
                this.toReferencedList(r2), t.arguments = r2;
              } else t.arguments = [];
              return this.finishNode(t, "NewExpression");
            }
            parseNewCallee(t) {
              t.callee = this.parseNoCallExpr(), t.callee.type === "Import" && this.raise(f.ImportCallNotNewExpression, { at: t.callee });
            }
            parseTemplateElement(t) {
              let { start: r2, startLoc: e, end: s, value: i } = this.state, a = r2 + 1, n = this.startNodeAt(Y(e, 1));
              i === null && (t || this.raise(f.InvalidEscapeSequenceTemplate, { at: Y(this.state.firstInvalidTemplateEscapePos, 1) }));
              let o = this.match(24), u = o ? -1 : -2, c2 = s + u;
              n.value = { raw: this.input.slice(a, c2).replace(/\r\n?/g, `
`), cooked: i === null ? null : i.slice(1, u) }, n.tail = o, this.next();
              let y = this.finishNode(n, "TemplateElement");
              return this.resetEndLocation(y, Y(this.state.lastTokEndLoc, u)), y;
            }
            parseTemplate(t) {
              let r2 = this.startNode();
              r2.expressions = [];
              let e = this.parseTemplateElement(t);
              for (r2.quasis = [e]; !e.tail; ) r2.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r2.quasis.push(e = this.parseTemplateElement(t));
              return this.finishNode(r2, "TemplateLiteral");
            }
            parseTemplateSubstitution() {
              return this.parseExpression();
            }
            parseObjectLike(t, r2, e, s) {
              e && this.expectPlugin("recordAndTuple");
              let i = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              let a = /* @__PURE__ */ Object.create(null), n = true, o = this.startNode();
              for (o.properties = [], this.next(); !this.match(t); ) {
                if (n) n = false;
                else if (this.expect(12), this.match(t)) {
                  this.addTrailingCommaExtraToNode(o);
                  break;
                }
                let c2;
                r2 ? c2 = this.parseBindingProperty() : (c2 = this.parsePropertyDefinition(s), this.checkProto(c2, e, a, s)), e && !this.isObjectProperty(c2) && c2.type !== "SpreadElement" && this.raise(f.InvalidRecordProperty, { at: c2 }), c2.shorthand && this.addExtra(c2, "shorthand", true), o.properties.push(c2);
              }
              this.next(), this.state.inFSharpPipelineDirectBody = i;
              let u = "ObjectExpression";
              return r2 ? u = "ObjectPattern" : e && (u = "RecordExpression"), this.finishNode(o, u);
            }
            addTrailingCommaExtraToNode(t) {
              this.addExtra(t, "trailingComma", this.state.lastTokStart), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, false);
            }
            maybeAsyncOrAccessorProp(t) {
              return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
            }
            parsePropertyDefinition(t) {
              let r2 = [];
              if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(f.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); ) r2.push(this.parseDecorator());
              let e = this.startNode(), s = false, i = false, a;
              if (this.match(21)) return r2.length && this.unexpected(), this.parseSpread();
              r2.length && (e.decorators = r2, r2 = []), e.method = false, t && (a = this.state.startLoc);
              let n = this.eat(55);
              this.parsePropertyNamePrefixOperator(e);
              let o = this.state.containsEsc, u = this.parsePropertyName(e, t);
              if (!n && !o && this.maybeAsyncOrAccessorProp(e)) {
                let c2 = u.name;
                c2 === "async" && !this.hasPrecedingLineBreak() && (s = true, this.resetPreviousNodeTrailingComments(u), n = this.eat(55), this.parsePropertyName(e)), (c2 === "get" || c2 === "set") && (i = true, this.resetPreviousNodeTrailingComments(u), e.kind = c2, this.match(55) && (n = true, this.raise(f.AccessorIsGenerator, { at: this.state.curPosition(), kind: c2 }), this.next()), this.parsePropertyName(e));
              }
              return this.parseObjPropValue(e, a, n, s, false, i, t);
            }
            getGetterSetterExpectedParamCount(t) {
              return t.kind === "get" ? 0 : 1;
            }
            getObjectOrClassMethodParams(t) {
              return t.params;
            }
            checkGetterSetterParams(t) {
              var r2;
              let e = this.getGetterSetterExpectedParamCount(t), s = this.getObjectOrClassMethodParams(t);
              s.length !== e && this.raise(t.kind === "get" ? f.BadGetterArity : f.BadSetterArity, { at: t }), t.kind === "set" && ((r2 = s[s.length - 1]) == null ? void 0 : r2.type) === "RestElement" && this.raise(f.BadSetterRestParameter, { at: t });
            }
            parseObjectMethod(t, r2, e, s, i) {
              if (i) {
                let a = this.parseMethod(t, r2, false, false, false, "ObjectMethod");
                return this.checkGetterSetterParams(a), a;
              }
              if (e || r2 || this.match(10)) return s && this.unexpected(), t.kind = "method", t.method = true, this.parseMethod(t, r2, e, false, false, "ObjectMethod");
            }
            parseObjectProperty(t, r2, e, s) {
              if (t.shorthand = false, this.eat(14)) return t.value = e ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(s), this.finishNode(t, "ObjectProperty");
              if (!t.computed && t.key.type === "Identifier") {
                if (this.checkReservedWord(t.key.name, t.key.loc.start, true, false), e) t.value = this.parseMaybeDefault(r2, me(t.key));
                else if (this.match(29)) {
                  let i = this.state.startLoc;
                  s != null ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = i) : this.raise(f.InvalidCoverInitializedName, { at: i }), t.value = this.parseMaybeDefault(r2, me(t.key));
                } else t.value = me(t.key);
                return t.shorthand = true, this.finishNode(t, "ObjectProperty");
              }
            }
            parseObjPropValue(t, r2, e, s, i, a, n) {
              let o = this.parseObjectMethod(t, e, s, i, a) || this.parseObjectProperty(t, r2, i, n);
              return o || this.unexpected(), o;
            }
            parsePropertyName(t, r2) {
              if (this.eat(0)) t.computed = true, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
              else {
                let { type: e, value: s } = this.state, i;
                if (te(e)) i = this.parseIdentifier(true);
                else switch (e) {
                  case 132:
                    i = this.parseNumericLiteral(s);
                    break;
                  case 131:
                    i = this.parseStringLiteral(s);
                    break;
                  case 133:
                    i = this.parseBigIntLiteral(s);
                    break;
                  case 134:
                    i = this.parseDecimalLiteral(s);
                    break;
                  case 136: {
                    let a = this.state.startLoc;
                    r2 != null ? r2.privateKeyLoc === null && (r2.privateKeyLoc = a) : this.raise(f.UnexpectedPrivateField, { at: a }), i = this.parsePrivateName();
                    break;
                  }
                  default:
                    this.unexpected();
                }
                t.key = i, e !== 136 && (t.computed = false);
              }
              return t.key;
            }
            initFunction(t, r2) {
              t.id = null, t.generator = false, t.async = r2;
            }
            parseMethod(t, r2, e, s, i, a) {
              let n = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
              this.initFunction(t, e), t.generator = r2, this.scope.enter(de | ht | (n ? Ee : 0) | (i ? Pr : 0)), this.prodParam.enter(Tt(e, t.generator)), this.parseFunctionParams(t, s);
              let o = this.parseFunctionBodyAndFinish(t, a, true);
              return this.prodParam.exit(), this.scope.exit(), o;
            }
            parseArrayLike(t, r2, e, s) {
              e && this.expectPlugin("recordAndTuple");
              let i = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              let a = this.startNode();
              return this.next(), a.elements = this.parseExprList(t, !e, s, a), this.state.inFSharpPipelineDirectBody = i, this.finishNode(a, e ? "TupleExpression" : "ArrayExpression");
            }
            parseArrowExpression(t, r2, e, s) {
              this.scope.enter(de | Gt);
              let i = Tt(e, false);
              !this.match(5) && this.prodParam.hasIn && (i |= _e), this.prodParam.enter(i), this.initFunction(t, e);
              let a = this.state.maybeInArrowParameters;
              return r2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t, r2, s)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a, this.finishNode(t, "ArrowFunctionExpression");
            }
            setArrowFunctionParameters(t, r2, e) {
              this.toAssignableList(r2, e, false), t.params = r2;
            }
            parseFunctionBodyAndFinish(t, r2) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return this.parseFunctionBody(t, false, e), this.finishNode(t, r2);
            }
            parseFunctionBody(t, r2) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s = r2 && !this.match(5);
              if (this.expressionScope.enter(_r()), s) t.body = this.parseMaybeAssign(), this.checkParams(t, false, r2, false);
              else {
                let i = this.state.strict, a = this.state.labels;
                this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | jr), t.body = this.parseBlock(true, false, (n) => {
                  let o = !this.isSimpleParamList(t.params);
                  n && o && this.raise(f.IllegalLanguageModeDirective, { at: (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t });
                  let u = !i && this.state.strict;
                  this.checkParams(t, !this.state.strict && !r2 && !e && !o, r2, u), this.state.strict && t.id && this.checkIdentifier(t.id, dl, u);
                }), this.prodParam.exit(), this.state.labels = a;
              }
              this.expressionScope.exit();
            }
            isSimpleParameter(t) {
              return t.type === "Identifier";
            }
            isSimpleParamList(t) {
              for (let r2 = 0, e = t.length; r2 < e; r2++) if (!this.isSimpleParameter(t[r2])) return false;
              return true;
            }
            checkParams(t, r2, e) {
              let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, i = !r2 && /* @__PURE__ */ new Set(), a = { type: "FormalParameters" };
              for (let n of t.params) this.checkLVal(n, { in: a, binding: mt, checkClashes: i, strictModeChanged: s });
            }
            parseExprList(t, r2, e, s) {
              let i = [], a = true;
              for (; !this.eat(t); ) {
                if (a) a = false;
                else if (this.expect(12), this.match(t)) {
                  s && this.addTrailingCommaExtraToNode(s), this.next();
                  break;
                }
                i.push(this.parseExprListItem(r2, e));
              }
              return i;
            }
            parseExprListItem(t, r2, e) {
              let s;
              if (this.match(12)) t || this.raise(f.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), s = null;
              else if (this.match(21)) {
                let i = this.state.startLoc;
                s = this.parseParenItem(this.parseSpread(r2), i);
              } else if (this.match(17)) {
                this.expectPlugin("partialApplication"), e || this.raise(f.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
                let i = this.startNode();
                this.next(), s = this.finishNode(i, "ArgumentPlaceholder");
              } else s = this.parseMaybeAssignAllowIn(r2, this.parseParenItem);
              return s;
            }
            parseIdentifier(t) {
              let r2 = this.startNode(), e = this.parseIdentifierName(t);
              return this.createIdentifier(r2, e);
            }
            createIdentifier(t, r2) {
              return t.name = r2, t.loc.identifierName = r2, this.finishNode(t, "Identifier");
            }
            parseIdentifierName(t) {
              let r2, { startLoc: e, type: s } = this.state;
              te(s) ? r2 = this.state.value : this.unexpected();
              let i = ue(s);
              return t ? i && this.replaceToken(130) : this.checkReservedWord(r2, e, i, false), this.next(), r2;
            }
            checkReservedWord(t, r2, e, s) {
              if (t.length > 10 || !ul(t)) return;
              if (e && ol(t)) {
                this.raise(f.UnexpectedKeyword, { at: r2, keyword: t });
                return;
              }
              if ((this.state.strict ? s ? xr : mr : dr)(t, this.inModule)) {
                this.raise(f.UnexpectedReservedWord, { at: r2, reservedWord: t });
                return;
              } else if (t === "yield") {
                if (this.prodParam.hasYield) {
                  this.raise(f.YieldBindingIdentifier, { at: r2 });
                  return;
                }
              } else if (t === "await") {
                if (this.prodParam.hasAwait) {
                  this.raise(f.AwaitBindingIdentifier, { at: r2 });
                  return;
                }
                if (this.scope.inStaticBlock) {
                  this.raise(f.AwaitBindingIdentifierInStaticBlock, { at: r2 });
                  return;
                }
                this.expressionScope.recordAsyncArrowParametersError({ at: r2 });
              } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
                this.raise(f.ArgumentsInClass, { at: r2 });
                return;
              }
            }
            isAwaitAllowed() {
              return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
            }
            parseAwait(t) {
              let r2 = this.startNodeAt(t);
              return this.expressionScope.recordParameterInitializerError(f.AwaitExpressionFormalParameter, { at: r2 }), this.eat(55) && this.raise(f.ObsoleteAwaitStar, { at: r2 }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (r2.argument = this.parseMaybeUnary(null, true)), this.finishNode(r2, "AwaitExpression");
            }
            isAmbiguousAwait() {
              if (this.hasPrecedingLineBreak()) return true;
              let { type: t } = this.state;
              return t === 53 || t === 10 || t === 0 || nt(t) || t === 101 && !this.state.containsEsc || t === 135 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
            }
            parseYield() {
              let t = this.startNode();
              this.expressionScope.recordParameterInitializerError(f.YieldInParameter, { at: t }), this.next();
              let r2 = false, e = null;
              if (!this.hasPrecedingLineBreak()) switch (r2 = this.eat(55), this.state.type) {
                case 13:
                case 137:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                  if (!r2) break;
                default:
                  e = this.parseMaybeAssign();
              }
              return t.delegate = r2, t.argument = e, this.finishNode(t, "YieldExpression");
            }
            checkPipelineAtInfixOperator(t, r2) {
              this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t.type === "SequenceExpression" && this.raise(f.PipelineHeadSequenceExpression, { at: r2 });
            }
            parseSmartPipelineBodyInStyle(t, r2) {
              if (this.isSimpleReference(t)) {
                let e = this.startNodeAt(r2);
                return e.callee = t, this.finishNode(e, "PipelineBareFunction");
              } else {
                let e = this.startNodeAt(r2);
                return this.checkSmartPipeTopicBodyEarlyErrors(r2), e.expression = t, this.finishNode(e, "PipelineTopicExpression");
              }
            }
            isSimpleReference(t) {
              switch (t.type) {
                case "MemberExpression":
                  return !t.computed && this.isSimpleReference(t.object);
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            checkSmartPipeTopicBodyEarlyErrors(t) {
              if (this.match(19)) throw this.raise(f.PipelineBodyNoArrow, { at: this.state.startLoc });
              this.topicReferenceWasUsedInCurrentContext() || this.raise(f.PipelineTopicUnused, { at: t });
            }
            withTopicBindingContext(t) {
              let r2 = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
              try {
                return t();
              } finally {
                this.state.topicContext = r2;
              }
            }
            withSmartMixTopicForbiddingContext(t) {
              if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
                let r2 = this.state.topicContext;
                this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
                try {
                  return t();
                } finally {
                  this.state.topicContext = r2;
                }
              } else return t();
            }
            withSoloAwaitPermittingContext(t) {
              let r2 = this.state.soloAwait;
              this.state.soloAwait = true;
              try {
                return t();
              } finally {
                this.state.soloAwait = r2;
              }
            }
            allowInAnd(t) {
              let r2 = this.prodParam.currentFlags();
              if (_e & ~r2) {
                this.prodParam.enter(r2 | _e);
                try {
                  return t();
                } finally {
                  this.prodParam.exit();
                }
              }
              return t();
            }
            disallowInAnd(t) {
              let r2 = this.prodParam.currentFlags();
              if (_e & r2) {
                this.prodParam.enter(r2 & ~_e);
                try {
                  return t();
                } finally {
                  this.prodParam.exit();
                }
              }
              return t();
            }
            registerTopicReference() {
              this.state.topicContext.maxTopicIndex = 0;
            }
            topicReferenceIsAllowedInCurrentContext() {
              return this.state.topicContext.maxNumOfResolvableTopics >= 1;
            }
            topicReferenceWasUsedInCurrentContext() {
              return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
            }
            parseFSharpPipelineBody(t) {
              let r2 = this.state.startLoc;
              this.state.potentialArrowAt = this.state.start;
              let e = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = true;
              let s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r2, t);
              return this.state.inFSharpPipelineDirectBody = e, s;
            }
            parseModuleExpression() {
              this.expectPlugin("moduleBlocks");
              let t = this.startNode();
              this.next(), this.match(5) || this.unexpected(null, 5);
              let r2 = this.startNodeAt(this.state.endLoc);
              this.next();
              let e = this.initializeScopes(true);
              this.enterInitialScopes();
              try {
                t.body = this.parseProgram(r2, 8, "module");
              } finally {
                e();
              }
              return this.finishNode(t, "ModuleExpression");
            }
            parsePropertyNamePrefixOperator(t) {
            }
          }, cs = { kind: "loop" }, Ph = { kind: "switch" }, Ah = /[\uD800-\uDFFF]/u, ps = /in(?:stanceof)?/y;
          function Th(t, r2) {
            for (let e = 0; e < t.length; e++) {
              let s = t[e], { type: i } = s;
              if (typeof i == "number") {
                {
                  if (i === 136) {
                    let { loc: a, start: n, value: o, end: u } = s, c2 = n + 1, y = Y(a.start, 1);
                    t.splice(e, 1, new Ae({ type: ce(27), value: "#", start: n, end: c2, startLoc: a.start, endLoc: y }), new Ae({ type: ce(130), value: o, start: c2, end: u, startLoc: y, endLoc: a.end })), e++;
                    continue;
                  }
                  if (nt(i)) {
                    let { loc: a, start: n, value: o, end: u } = s, c2 = n + 1, y = Y(a.start, 1), g;
                    r2.charCodeAt(n) === 96 ? g = new Ae({ type: ce(22), value: "`", start: n, end: c2, startLoc: a.start, endLoc: y }) : g = new Ae({ type: ce(8), value: "}", start: n, end: c2, startLoc: a.start, endLoc: y });
                    let T, C, M, j;
                    i === 24 ? (C = u - 1, M = Y(a.end, -1), T = o === null ? null : o.slice(1, -1), j = new Ae({ type: ce(22), value: "`", start: C, end: u, startLoc: M, endLoc: a.end })) : (C = u - 2, M = Y(a.end, -2), T = o === null ? null : o.slice(1, -2), j = new Ae({ type: ce(23), value: "${", start: C, end: u, startLoc: M, endLoc: a.end })), t.splice(e, 1, g, new Ae({ type: ce(20), value: T, start: c2, end: C, startLoc: y, endLoc: M }), j), e += 2;
                    continue;
                  }
                }
                s.type = ce(i);
              }
            }
            return t;
          }
          var vh = class extends gh {
            parseTopLevel(t, r2) {
              return t.program = this.parseProgram(r2), t.comments = this.state.comments, this.options.tokens && (t.tokens = Th(this.tokens, this.input)), this.finishNode(t, "File");
            }
            parseProgram(t) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 137, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
              if (t.sourceType = e, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, true, true, r2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (let [i, a] of Array.from(this.scope.undefinedExports)) this.raise(f.ModuleExportUndefined, { at: a, localName: i });
              let s;
              return r2 === 137 ? s = this.finishNode(t, "Program") : s = this.finishNodeAt(t, "Program", Y(this.state.startLoc, -1)), s;
            }
            stmtToDirective(t) {
              let r2 = t;
              r2.type = "Directive", r2.value = r2.expression, delete r2.expression;
              let e = r2.value, s = e.value, i = this.input.slice(e.start, e.end), a = e.value = i.slice(1, -1);
              return this.addExtra(e, "raw", i), this.addExtra(e, "rawValue", a), this.addExtra(e, "expressionValue", s), e.type = "DirectiveLiteral", r2;
            }
            parseInterpreterDirective() {
              if (!this.match(28)) return null;
              let t = this.startNode();
              return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
            }
            isLet() {
              return this.isContextual(99) ? this.hasFollowingBindingAtom() : false;
            }
            chStartsBindingIdentifier(t, r2) {
              if (fe(t)) {
                if (ps.lastIndex = r2, ps.test(this.input)) {
                  let e = this.codePointAtPos(ps.lastIndex);
                  if (!De(e) && e !== 92) return false;
                }
                return true;
              } else return t === 92;
            }
            chStartsBindingPattern(t) {
              return t === 91 || t === 123;
            }
            hasFollowingBindingAtom() {
              let t = this.nextTokenStart(), r2 = this.codePointAtPos(t);
              return this.chStartsBindingPattern(r2) || this.chStartsBindingIdentifier(r2, t);
            }
            hasFollowingBindingIdentifier() {
              let t = this.nextTokenStart(), r2 = this.codePointAtPos(t);
              return this.chStartsBindingIdentifier(r2, t);
            }
            startsUsingForOf() {
              let t = this.lookahead();
              return t.type === 101 && !t.containsEsc ? false : (this.expectPlugin("explicitResourceManagement"), true);
            }
            parseModuleItem() {
              return this.parseStatementLike(15);
            }
            parseStatementListItem() {
              return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
            }
            parseStatementOrSloppyAnnexBFunctionDeclaration() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, r2 = 0;
              return this.options.annexB && !this.state.strict && (r2 |= 4, t && (r2 |= 8)), this.parseStatementLike(r2);
            }
            parseStatement() {
              return this.parseStatementLike(0);
            }
            parseStatementLike(t) {
              let r2 = null;
              return this.match(26) && (r2 = this.parseDecorators(true)), this.parseStatementContent(t, r2);
            }
            parseStatementContent(t, r2) {
              let e = this.state.type, s = this.startNode(), i = !!(t & 2), a = !!(t & 4), n = t & 1;
              switch (e) {
                case 60:
                  return this.parseBreakContinueStatement(s, true);
                case 63:
                  return this.parseBreakContinueStatement(s, false);
                case 64:
                  return this.parseDebuggerStatement(s);
                case 90:
                  return this.parseDoWhileStatement(s);
                case 91:
                  return this.parseForStatement(s);
                case 68:
                  if (this.lookaheadCharCode() === 46) break;
                  return a || this.raise(this.state.strict ? f.StrictFunction : this.options.annexB ? f.SloppyFunctionAnnexB : f.SloppyFunction, { at: this.state.startLoc }), this.parseFunctionStatement(s, false, !i && a);
                case 80:
                  return i || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r2, s), true);
                case 69:
                  return this.parseIfStatement(s);
                case 70:
                  return this.parseReturnStatement(s);
                case 71:
                  return this.parseSwitchStatement(s);
                case 72:
                  return this.parseThrowStatement(s);
                case 73:
                  return this.parseTryStatement(s);
                case 105:
                  if (this.hasFollowingLineBreak() || this.state.containsEsc || !this.hasFollowingBindingIdentifier()) break;
                  return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(f.UnexpectedUsingDeclaration, { at: this.state.startLoc }) : i || this.raise(f.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(s, "using");
                case 99: {
                  if (this.state.containsEsc) break;
                  let c2 = this.nextTokenStart(), y = this.codePointAtPos(c2);
                  if (y !== 91 && (!i && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(y, c2) && y !== 123)) break;
                }
                case 75:
                  i || this.raise(f.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
                case 74: {
                  let c2 = this.state.value;
                  return this.parseVarStatement(s, c2);
                }
                case 92:
                  return this.parseWhileStatement(s);
                case 76:
                  return this.parseWithStatement(s);
                case 5:
                  return this.parseBlock();
                case 13:
                  return this.parseEmptyStatement(s);
                case 83: {
                  let c2 = this.lookaheadCharCode();
                  if (c2 === 40 || c2 === 46) break;
                }
                case 82: {
                  !this.options.allowImportExportEverywhere && !n && this.raise(f.UnexpectedImportExport, { at: this.state.startLoc }), this.next();
                  let c2;
                  return e === 83 ? (c2 = this.parseImport(s), c2.type === "ImportDeclaration" && (!c2.importKind || c2.importKind === "value") && (this.sawUnambiguousESM = true)) : (c2 = this.parseExport(s, r2), (c2.type === "ExportNamedDeclaration" && (!c2.exportKind || c2.exportKind === "value") || c2.type === "ExportAllDeclaration" && (!c2.exportKind || c2.exportKind === "value") || c2.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(c2), c2;
                }
                default:
                  if (this.isAsyncFunction()) return i || this.raise(f.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(s, true, !i && a);
              }
              let o = this.state.value, u = this.parseExpression();
              return q(e) && u.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(s, o, u, t) : this.parseExpressionStatement(s, u, r2);
            }
            assertModuleNodeAllowed(t) {
              !this.options.allowImportExportEverywhere && !this.inModule && this.raise(f.ImportOutsideModule, { at: t });
            }
            decoratorsEnabledBeforeExport() {
              return this.hasPlugin("decorators-legacy") ? true : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
            }
            maybeTakeDecorators(t, r2, e) {
              return t && (r2.decorators && r2.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(f.DecoratorsBeforeAfterExport, { at: r2.decorators[0] }), r2.decorators.unshift(...t)) : r2.decorators = t, this.resetStartLocationFromNode(r2, t[0]), e && this.resetStartLocationFromNode(e, r2)), r2;
            }
            canHaveLeadingDecorator() {
              return this.match(80);
            }
            parseDecorators(t) {
              let r2 = [];
              do
                r2.push(this.parseDecorator());
              while (this.match(26));
              if (this.match(82)) t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(f.DecoratorExportClass, { at: this.state.startLoc });
              else if (!this.canHaveLeadingDecorator()) throw this.raise(f.UnexpectedLeadingDecorator, { at: this.state.startLoc });
              return r2;
            }
            parseDecorator() {
              this.expectOnePlugin(["decorators", "decorators-legacy"]);
              let t = this.startNode();
              if (this.next(), this.hasPlugin("decorators")) {
                let r2 = this.state.startLoc, e;
                if (this.match(10)) {
                  let s = this.state.startLoc;
                  this.next(), e = this.parseExpression(), this.expect(11), e = this.wrapParenthesis(s, e);
                  let i = this.state.startLoc;
                  t.expression = this.parseMaybeDecoratorArguments(e), this.getPluginOption("decorators", "allowCallParenthesized") === false && t.expression !== e && this.raise(f.DecoratorArgumentsOutsideParentheses, { at: i });
                } else {
                  for (e = this.parseIdentifier(false); this.eat(16); ) {
                    let s = this.startNodeAt(r2);
                    s.object = e, this.match(136) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), s.property = this.parsePrivateName()) : s.property = this.parseIdentifier(true), s.computed = false, e = this.finishNode(s, "MemberExpression");
                  }
                  t.expression = this.parseMaybeDecoratorArguments(e);
                }
              } else t.expression = this.parseExprSubscripts();
              return this.finishNode(t, "Decorator");
            }
            parseMaybeDecoratorArguments(t) {
              if (this.eat(10)) {
                let r2 = this.startNodeAtNode(t);
                return r2.callee = t, r2.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(r2.arguments), this.finishNode(r2, "CallExpression");
              }
              return t;
            }
            parseBreakContinueStatement(t, r2) {
              return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, r2), this.finishNode(t, r2 ? "BreakStatement" : "ContinueStatement");
            }
            verifyBreakContinue(t, r2) {
              let e;
              for (e = 0; e < this.state.labels.length; ++e) {
                let s = this.state.labels[e];
                if ((t.label == null || s.name === t.label.name) && (s.kind != null && (r2 || s.kind === "loop") || t.label && r2)) break;
              }
              if (e === this.state.labels.length) {
                let s = r2 ? "BreakStatement" : "ContinueStatement";
                this.raise(f.IllegalBreakContinue, { at: t, type: s });
              }
            }
            parseDebuggerStatement(t) {
              return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
            }
            parseHeaderExpression() {
              this.expect(10);
              let t = this.parseExpression();
              return this.expect(11), t;
            }
            parseDoWhileStatement(t) {
              return this.next(), this.state.labels.push(cs), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
            }
            parseForStatement(t) {
              this.next(), this.state.labels.push(cs);
              let r2 = null;
              if (this.isAwaitAllowed() && this.eatContextual(96) && (r2 = this.state.lastTokStartLoc), this.scope.enter(Fe), this.expect(10), this.match(13)) return r2 !== null && this.unexpected(r2), this.parseFor(t, null);
              let e = this.isContextual(99), s = this.isContextual(105) && !this.hasFollowingLineBreak(), i = e && this.hasFollowingBindingAtom() || s && this.hasFollowingBindingIdentifier() && this.startsUsingForOf();
              if (this.match(74) || this.match(75) || i) {
                let c2 = this.startNode(), y = this.state.value;
                this.next(), this.parseVar(c2, true, y);
                let g = this.finishNode(c2, "VariableDeclaration"), T = this.match(58);
                return T && s && this.raise(f.ForInUsing, { at: g }), (T || this.isContextual(101)) && g.declarations.length === 1 ? this.parseForIn(t, g, r2) : (r2 !== null && this.unexpected(r2), this.parseFor(t, g));
              }
              let a = this.isContextual(95), n = new vt(), o = this.parseExpression(true, n), u = this.isContextual(101);
              if (u && (e && this.raise(f.ForOfLet, { at: o }), r2 === null && a && o.type === "Identifier" && this.raise(f.ForOfAsync, { at: o })), u || this.match(58)) {
                this.checkDestructuringPrivate(n), this.toAssignable(o, true);
                let c2 = u ? "ForOfStatement" : "ForInStatement";
                return this.checkLVal(o, { in: { type: c2 } }), this.parseForIn(t, o, r2);
              } else this.checkExpressionErrors(n, true);
              return r2 !== null && this.unexpected(r2), this.parseFor(t, o);
            }
            parseFunctionStatement(t, r2, e) {
              return this.next(), this.parseFunction(t, 1 | (e ? 2 : 0) | (r2 ? 8 : 0));
            }
            parseIfStatement(t) {
              return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
            }
            parseReturnStatement(t) {
              return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(f.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
            }
            parseSwitchStatement(t) {
              this.next(), t.discriminant = this.parseHeaderExpression();
              let r2 = t.cases = [];
              this.expect(5), this.state.labels.push(Ph), this.scope.enter(Fe);
              let e;
              for (let s; !this.match(8); ) if (this.match(61) || this.match(65)) {
                let i = this.match(61);
                e && this.finishNode(e, "SwitchCase"), r2.push(e = this.startNode()), e.consequent = [], this.next(), i ? e.test = this.parseExpression() : (s && this.raise(f.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), s = true, e.test = null), this.expect(14);
              } else e ? e.consequent.push(this.parseStatementListItem()) : this.unexpected();
              return this.scope.exit(), e && this.finishNode(e, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
            }
            parseThrowStatement(t) {
              return this.next(), this.hasPrecedingLineBreak() && this.raise(f.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
            }
            parseCatchClauseParam() {
              let t = this.parseBindingAtom();
              return this.scope.enter(this.options.annexB && t.type === "Identifier" ? gr : 0), this.checkLVal(t, { in: { type: "CatchClause" }, binding: cl }), t;
            }
            parseTryStatement(t) {
              if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
                let r2 = this.startNode();
                this.next(), this.match(10) ? (this.expect(10), r2.param = this.parseCatchClauseParam(), this.expect(11)) : (r2.param = null, this.scope.enter(Fe)), r2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t.handler = this.finishNode(r2, "CatchClause");
              }
              return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(f.NoCatchOrFinally, { at: t }), this.finishNode(t, "TryStatement");
            }
            parseVarStatement(t, r2) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return this.next(), this.parseVar(t, false, r2, e), this.semicolon(), this.finishNode(t, "VariableDeclaration");
            }
            parseWhileStatement(t) {
              return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(cs), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
            }
            parseWithStatement(t) {
              return this.state.strict && this.raise(f.StrictWith, { at: this.state.startLoc }), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
            }
            parseEmptyStatement(t) {
              return this.next(), this.finishNode(t, "EmptyStatement");
            }
            parseLabeledStatement(t, r2, e, s) {
              for (let a of this.state.labels) a.name === r2 && this.raise(f.LabelRedeclaration, { at: e, labelName: r2 });
              let i = Mo(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
              for (let a = this.state.labels.length - 1; a >= 0; a--) {
                let n = this.state.labels[a];
                if (n.statementStart === t.start) n.statementStart = this.state.start, n.kind = i;
                else break;
              }
              return this.state.labels.push({ name: r2, kind: i, statementStart: this.state.start }), t.body = s & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), t.label = e, this.finishNode(t, "LabeledStatement");
            }
            parseExpressionStatement(t, r2, e) {
              return t.expression = r2, this.semicolon(), this.finishNode(t, "ExpressionStatement");
            }
            parseBlock() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, e = arguments.length > 2 ? arguments[2] : void 0, s = this.startNode();
              return t && this.state.strictErrors.clear(), this.expect(5), r2 && this.scope.enter(Fe), this.parseBlockBody(s, t, false, 8, e), r2 && this.scope.exit(), this.finishNode(s, "BlockStatement");
            }
            isValidDirective(t) {
              return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
            }
            parseBlockBody(t, r2, e, s, i) {
              let a = t.body = [], n = t.directives = [];
              this.parseBlockOrModuleBlockBody(a, r2 ? n : void 0, e, s, i);
            }
            parseBlockOrModuleBlockBody(t, r2, e, s, i) {
              let a = this.state.strict, n = false, o = false;
              for (; !this.match(s); ) {
                let u = e ? this.parseModuleItem() : this.parseStatementListItem();
                if (r2 && !o) {
                  if (this.isValidDirective(u)) {
                    let c2 = this.stmtToDirective(u);
                    r2.push(c2), !n && c2.value.value === "use strict" && (n = true, this.setStrict(true));
                    continue;
                  }
                  o = true, this.state.strictErrors.clear();
                }
                t.push(u);
              }
              i && i.call(this, n), a || this.setStrict(false), this.next();
            }
            parseFor(t, r2) {
              return t.init = r2, this.semicolon(false), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
            }
            parseForIn(t, r2, e) {
              let s = this.match(58);
              return this.next(), s ? e !== null && this.unexpected(e) : t.await = e !== null, r2.type === "VariableDeclaration" && r2.declarations[0].init != null && (!s || !this.options.annexB || this.state.strict || r2.kind !== "var" || r2.declarations[0].id.type !== "Identifier") && this.raise(f.ForInOfLoopInitializer, { at: r2, type: s ? "ForInStatement" : "ForOfStatement" }), r2.type === "AssignmentPattern" && this.raise(f.InvalidLhs, { at: r2, ancestor: { type: "ForStatement" } }), t.left = r2, t.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, s ? "ForInStatement" : "ForOfStatement");
            }
            parseVar(t, r2, e) {
              let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, i = t.declarations = [];
              for (t.kind = e; ; ) {
                let a = this.startNode();
                if (this.parseVarId(a, e), a.init = this.eat(29) ? r2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a.init === null && !s && (a.id.type !== "Identifier" && !(r2 && (this.match(58) || this.isContextual(101))) ? this.raise(f.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" }) : e === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(f.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" })), i.push(this.finishNode(a, "VariableDeclarator")), !this.eat(12)) break;
              }
              return t;
            }
            parseVarId(t, r2) {
              r2 === "using" && !this.inModule && this.match(96) && this.raise(f.AwaitInUsingBinding, { at: this.state.startLoc });
              let e = this.parseBindingAtom();
              this.checkLVal(e, { in: { type: "VariableDeclarator" }, binding: r2 === "var" ? mt : Be }), t.id = e;
            }
            parseAsyncFunctionExpression(t) {
              return this.parseFunction(t, 8);
            }
            parseFunction(t) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, e = r2 & 2, s = !!(r2 & 1), i = s && !(r2 & 4), a = !!(r2 & 8);
              this.initFunction(t, a), this.match(55) && (e && this.raise(f.GeneratorInSingleStatementContext, { at: this.state.startLoc }), this.next(), t.generator = true), s && (t.id = this.parseFunctionId(i));
              let n = this.state.maybeInArrowParameters;
              return this.state.maybeInArrowParameters = false, this.scope.enter(de), this.prodParam.enter(Tt(a, t.generator)), s || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, false), this.withSmartMixTopicForbiddingContext(() => {
                this.parseFunctionBodyAndFinish(t, s ? "FunctionDeclaration" : "FunctionExpression");
              }), this.prodParam.exit(), this.scope.exit(), s && !e && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = n, t;
            }
            parseFunctionId(t) {
              return t || q(this.state.type) ? this.parseIdentifier() : null;
            }
            parseFunctionParams(t, r2) {
              this.expect(10), this.expressionScope.enter(ql()), t.params = this.parseBindingList(11, 41, 2 | (r2 ? 4 : 0)), this.expressionScope.exit();
            }
            registerFunctionStatementId(t) {
              t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? mt : Be : Er, t.id.loc.start);
            }
            parseClass(t, r2, e) {
              this.next();
              let s = this.state.strict;
              return this.state.strict = true, this.parseClassId(t, r2, e), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, s), this.finishNode(t, r2 ? "ClassDeclaration" : "ClassExpression");
            }
            isClassProperty() {
              return this.match(29) || this.match(13) || this.match(8);
            }
            isClassMethod() {
              return this.match(10);
            }
            isNonstaticConstructor(t) {
              return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
            }
            parseClassBody(t, r2) {
              this.classScope.enter();
              let e = { hadConstructor: false, hadSuperClass: t }, s = [], i = this.startNode();
              if (i.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
                for (; !this.match(8); ) {
                  if (this.eat(13)) {
                    if (s.length > 0) throw this.raise(f.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                    continue;
                  }
                  if (this.match(26)) {
                    s.push(this.parseDecorator());
                    continue;
                  }
                  let a = this.startNode();
                  s.length && (a.decorators = s, this.resetStartLocationFromNode(a, s[0]), s = []), this.parseClassMember(i, a, e), a.kind === "constructor" && a.decorators && a.decorators.length > 0 && this.raise(f.DecoratorConstructor, { at: a });
                }
              }), this.state.strict = r2, this.next(), s.length) throw this.raise(f.TrailingDecorator, { at: this.state.startLoc });
              return this.classScope.exit(), this.finishNode(i, "ClassBody");
            }
            parseClassMemberFromModifier(t, r2) {
              let e = this.parseIdentifier(true);
              if (this.isClassMethod()) {
                let s = r2;
                return s.kind = "method", s.computed = false, s.key = e, s.static = false, this.pushClassMethod(t, s, false, false, false, false), true;
              } else if (this.isClassProperty()) {
                let s = r2;
                return s.computed = false, s.key = e, s.static = false, t.body.push(this.parseClassProperty(s)), true;
              }
              return this.resetPreviousNodeTrailingComments(e), false;
            }
            parseClassMember(t, r2, e) {
              let s = this.isContextual(104);
              if (s) {
                if (this.parseClassMemberFromModifier(t, r2)) return;
                if (this.eat(5)) {
                  this.parseClassStaticBlock(t, r2);
                  return;
                }
              }
              this.parseClassMemberWithIsStatic(t, r2, e, s);
            }
            parseClassMemberWithIsStatic(t, r2, e, s) {
              let i = r2, a = r2, n = r2, o = r2, u = r2, c2 = i, y = i;
              if (r2.static = s, this.parsePropertyNamePrefixOperator(r2), this.eat(55)) {
                c2.kind = "method";
                let j = this.match(136);
                if (this.parseClassElementName(c2), j) {
                  this.pushClassPrivateMethod(t, a, true, false);
                  return;
                }
                this.isNonstaticConstructor(i) && this.raise(f.ConstructorIsGenerator, { at: i.key }), this.pushClassMethod(t, i, true, false, false, false);
                return;
              }
              let g = q(this.state.type) && !this.state.containsEsc, T = this.match(136), C = this.parseClassElementName(r2), M = this.state.startLoc;
              if (this.parsePostMemberNameModifiers(y), this.isClassMethod()) {
                if (c2.kind = "method", T) {
                  this.pushClassPrivateMethod(t, a, false, false);
                  return;
                }
                let j = this.isNonstaticConstructor(i), K = false;
                j && (i.kind = "constructor", e.hadConstructor && !this.hasPlugin("typescript") && this.raise(f.DuplicateConstructor, { at: C }), j && this.hasPlugin("typescript") && r2.override && this.raise(f.OverrideOnConstructor, { at: C }), e.hadConstructor = true, K = e.hadSuperClass), this.pushClassMethod(t, i, false, false, j, K);
              } else if (this.isClassProperty()) T ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n);
              else if (g && C.name === "async" && !this.isLineTerminator()) {
                this.resetPreviousNodeTrailingComments(C);
                let j = this.eat(55);
                y.optional && this.unexpected(M), c2.kind = "method";
                let K = this.match(136);
                this.parseClassElementName(c2), this.parsePostMemberNameModifiers(y), K ? this.pushClassPrivateMethod(t, a, j, true) : (this.isNonstaticConstructor(i) && this.raise(f.ConstructorIsAsync, { at: i.key }), this.pushClassMethod(t, i, j, true, false, false));
              } else if (g && (C.name === "get" || C.name === "set") && !(this.match(55) && this.isLineTerminator())) {
                this.resetPreviousNodeTrailingComments(C), c2.kind = C.name;
                let j = this.match(136);
                this.parseClassElementName(i), j ? this.pushClassPrivateMethod(t, a, false, false) : (this.isNonstaticConstructor(i) && this.raise(f.ConstructorIsAccessor, { at: i.key }), this.pushClassMethod(t, i, false, false, false, false)), this.checkGetterSetterParams(i);
              } else if (g && C.name === "accessor" && !this.isLineTerminator()) {
                this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(C);
                let j = this.match(136);
                this.parseClassElementName(n), this.pushClassAccessorProperty(t, u, j);
              } else this.isLineTerminator() ? T ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n) : this.unexpected();
            }
            parseClassElementName(t) {
              let { type: r2, value: e } = this.state;
              if ((r2 === 130 || r2 === 131) && t.static && e === "prototype" && this.raise(f.StaticPrototype, { at: this.state.startLoc }), r2 === 136) {
                e === "constructor" && this.raise(f.ConstructorClassPrivateField, { at: this.state.startLoc });
                let s = this.parsePrivateName();
                return t.key = s, s;
              }
              return this.parsePropertyName(t);
            }
            parseClassStaticBlock(t, r2) {
              var e;
              this.scope.enter(Ee | ut | ht);
              let s = this.state.labels;
              this.state.labels = [], this.prodParam.enter(Me);
              let i = r2.body = [];
              this.parseBlockOrModuleBlockBody(i, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s, t.body.push(this.finishNode(r2, "StaticBlock")), (e = r2.decorators) != null && e.length && this.raise(f.DecoratorStaticBlock, { at: r2 });
            }
            pushClassProperty(t, r2) {
              !r2.computed && (r2.key.name === "constructor" || r2.key.value === "constructor") && this.raise(f.ConstructorClassField, { at: r2.key }), t.body.push(this.parseClassProperty(r2));
            }
            pushClassPrivateProperty(t, r2) {
              let e = this.parseClassPrivateProperty(r2);
              t.body.push(e), this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), ss, e.key.loc.start);
            }
            pushClassAccessorProperty(t, r2, e) {
              if (!e && !r2.computed) {
                let i = r2.key;
                (i.name === "constructor" || i.value === "constructor") && this.raise(f.ConstructorClassField, { at: i });
              }
              let s = this.parseClassAccessorProperty(r2);
              t.body.push(s), e && this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), ss, s.key.loc.start);
            }
            pushClassMethod(t, r2, e, s, i, a) {
              t.body.push(this.parseMethod(r2, e, s, i, a, "ClassMethod", true));
            }
            pushClassPrivateMethod(t, r2, e, s) {
              let i = this.parseMethod(r2, e, s, false, false, "ClassPrivateMethod", true);
              t.body.push(i);
              let a = i.kind === "get" ? i.static ? gl : Al : i.kind === "set" ? i.static ? Pl : Tl : ss;
              this.declareClassPrivateMethodInScope(i, a);
            }
            declareClassPrivateMethodInScope(t, r2) {
              this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r2, t.key.loc.start);
            }
            parsePostMemberNameModifiers(t) {
            }
            parseClassPrivateProperty(t) {
              return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
            }
            parseClassProperty(t) {
              return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
            }
            parseClassAccessorProperty(t) {
              return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
            }
            parseInitializer(t) {
              this.scope.enter(Ee | ht), this.expressionScope.enter(_r()), this.prodParam.enter(Me), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
            }
            parseClassId(t, r2, e) {
              let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : vr;
              if (q(this.state.type)) t.id = this.parseIdentifier(), r2 && this.declareNameFromIdentifier(t.id, s);
              else if (e || !r2) t.id = null;
              else throw this.raise(f.MissingClassName, { at: this.state.startLoc });
            }
            parseClassSuper(t) {
              t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
            }
            parseExport(t, r2) {
              let e = this.maybeParseExportDefaultSpecifier(t), s = !e || this.eat(12), i = s && this.eatExportStar(t), a = i && this.maybeParseExportNamespaceSpecifier(t), n = s && (!a || this.eat(12)), o = e || i;
              if (i && !a) {
                if (e && this.unexpected(), r2) throw this.raise(f.UnsupportedDecoratorExport, { at: t });
                return this.parseExportFrom(t, true), this.finishNode(t, "ExportAllDeclaration");
              }
              let u = this.maybeParseExportNamedSpecifiers(t);
              e && s && !i && !u && this.unexpected(null, 5), a && n && this.unexpected(null, 97);
              let c2;
              if (o || u) {
                if (c2 = false, r2) throw this.raise(f.UnsupportedDecoratorExport, { at: t });
                this.parseExportFrom(t, o);
              } else c2 = this.maybeParseExportDeclaration(t);
              if (o || u || c2) {
                var y;
                let g = t;
                if (this.checkExport(g, true, false, !!g.source), ((y = g.declaration) == null ? void 0 : y.type) === "ClassDeclaration") this.maybeTakeDecorators(r2, g.declaration, g);
                else if (r2) throw this.raise(f.UnsupportedDecoratorExport, { at: t });
                return this.finishNode(g, "ExportNamedDeclaration");
              }
              if (this.eat(65)) {
                let g = t, T = this.parseExportDefaultExpression();
                if (g.declaration = T, T.type === "ClassDeclaration") this.maybeTakeDecorators(r2, T, g);
                else if (r2) throw this.raise(f.UnsupportedDecoratorExport, { at: t });
                return this.checkExport(g, true, true), this.finishNode(g, "ExportDefaultDeclaration");
              }
              this.unexpected(null, 5);
            }
            eatExportStar(t) {
              return this.eat(55);
            }
            maybeParseExportDefaultSpecifier(t) {
              if (this.isExportDefaultSpecifier()) {
                this.expectPlugin("exportDefaultFrom");
                let r2 = this.startNode();
                return r2.exported = this.parseIdentifier(true), t.specifiers = [this.finishNode(r2, "ExportDefaultSpecifier")], true;
              }
              return false;
            }
            maybeParseExportNamespaceSpecifier(t) {
              if (this.isContextual(93)) {
                t.specifiers || (t.specifiers = []);
                let r2 = this.startNodeAt(this.state.lastTokStartLoc);
                return this.next(), r2.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(r2, "ExportNamespaceSpecifier")), true;
              }
              return false;
            }
            maybeParseExportNamedSpecifiers(t) {
              if (this.match(5)) {
                t.specifiers || (t.specifiers = []);
                let r2 = t.exportKind === "type";
                return t.specifiers.push(...this.parseExportSpecifiers(r2)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") && (t.assertions = []), true;
              }
              return false;
            }
            maybeParseExportDeclaration(t) {
              return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), true) : false;
            }
            isAsyncFunction() {
              if (!this.isContextual(95)) return false;
              let t = this.nextTokenStart();
              return !as.test(this.input.slice(this.state.pos, t)) && this.isUnparsedContextual(t, "function");
            }
            parseExportDefaultExpression() {
              let t = this.startNode();
              if (this.match(68)) return this.next(), this.parseFunction(t, 5);
              if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(t, 13);
              if (this.match(80)) return this.parseClass(t, true, true);
              if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(f.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
              if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(f.UnsupportedDefaultExport, { at: this.state.startLoc });
              let r2 = this.parseMaybeAssignAllowIn();
              return this.semicolon(), r2;
            }
            parseExportDeclaration(t) {
              return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
            }
            isExportDefaultSpecifier() {
              let { type: t } = this.state;
              if (q(t)) {
                if (t === 95 && !this.state.containsEsc || t === 99) return false;
                if ((t === 128 || t === 127) && !this.state.containsEsc) {
                  let { type: s } = this.lookahead();
                  if (q(s) && s !== 97 || s === 5) return this.expectOnePlugin(["flow", "typescript"]), false;
                }
              } else if (!this.match(65)) return false;
              let r2 = this.nextTokenStart(), e = this.isUnparsedContextual(r2, "from");
              if (this.input.charCodeAt(r2) === 44 || q(this.state.type) && e) return true;
              if (this.match(65) && e) {
                let s = this.input.charCodeAt(this.nextTokenStartSince(r2 + 4));
                return s === 34 || s === 39;
              }
              return false;
            }
            parseExportFrom(t, r2) {
              if (this.eatContextual(97)) {
                t.source = this.parseImportSource(), this.checkExport(t);
                let e = this.maybeParseImportAssertions();
                e && (t.assertions = e, this.checkJSONModuleImport(t));
              } else r2 && this.unexpected();
              this.semicolon();
            }
            shouldParseExportDeclaration() {
              let { type: t } = this.state;
              return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(f.DecoratorBeforeExport, { at: this.state.startLoc }), true) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
            }
            checkExport(t, r2, e, s) {
              if (r2) {
                if (e) {
                  if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
                    var i;
                    let a = t.declaration;
                    a.type === "Identifier" && a.name === "from" && a.end - a.start === 4 && !((i = a.extra) != null && i.parenthesized) && this.raise(f.ExportDefaultFromAsIdentifier, { at: a });
                  }
                } else if (t.specifiers && t.specifiers.length) for (let a of t.specifiers) {
                  let { exported: n } = a, o = n.type === "Identifier" ? n.name : n.value;
                  if (this.checkDuplicateExports(a, o), !s && a.local) {
                    let { local: u } = a;
                    u.type !== "Identifier" ? this.raise(f.ExportBindingIsString, { at: a, localName: u.value, exportName: o }) : (this.checkReservedWord(u.name, u.loc.start, true, false), this.scope.checkLocalExport(u));
                  }
                }
                else if (t.declaration) {
                  if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
                    let a = t.declaration.id;
                    if (!a) throw new Error("Assertion failure");
                    this.checkDuplicateExports(t, a.name);
                  } else if (t.declaration.type === "VariableDeclaration") for (let a of t.declaration.declarations) this.checkDeclaration(a.id);
                }
              }
            }
            checkDeclaration(t) {
              if (t.type === "Identifier") this.checkDuplicateExports(t, t.name);
              else if (t.type === "ObjectPattern") for (let r2 of t.properties) this.checkDeclaration(r2);
              else if (t.type === "ArrayPattern") for (let r2 of t.elements) r2 && this.checkDeclaration(r2);
              else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
            }
            checkDuplicateExports(t, r2) {
              this.exportedIdentifiers.has(r2) && (r2 === "default" ? this.raise(f.DuplicateDefaultExport, { at: t }) : this.raise(f.DuplicateExport, { at: t, exportName: r2 })), this.exportedIdentifiers.add(r2);
            }
            parseExportSpecifiers(t) {
              let r2 = [], e = true;
              for (this.expect(5); !this.eat(8); ) {
                if (e) e = false;
                else if (this.expect(12), this.eat(8)) break;
                let s = this.isContextual(128), i = this.match(131), a = this.startNode();
                a.local = this.parseModuleExportName(), r2.push(this.parseExportSpecifier(a, i, t, s));
              }
              return r2;
            }
            parseExportSpecifier(t, r2, e, s) {
              return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r2 ? t.exported = Kl(t.local) : t.exported || (t.exported = me(t.local)), this.finishNode(t, "ExportSpecifier");
            }
            parseModuleExportName() {
              if (this.match(131)) {
                let t = this.parseStringLiteral(this.state.value), r2 = t.value.match(Ah);
                return r2 && this.raise(f.ModuleExportNameHasLoneSurrogate, { at: t, surrogateCharCode: r2[0].charCodeAt(0) }), t;
              }
              return this.parseIdentifier(true);
            }
            isJSONModuleImport(t) {
              return t.assertions != null ? t.assertions.some((r2) => {
                let { key: e, value: s } = r2;
                return s.value === "json" && (e.type === "Identifier" ? e.name === "type" : e.value === "type");
              }) : false;
            }
            checkImportReflection(t) {
              if (t.module) {
                var r2;
                (t.specifiers.length !== 1 || t.specifiers[0].type !== "ImportDefaultSpecifier") && this.raise(f.ImportReflectionNotBinding, { at: t.specifiers[0].loc.start }), ((r2 = t.assertions) == null ? void 0 : r2.length) > 0 && this.raise(f.ImportReflectionHasAssertion, { at: t.specifiers[0].loc.start });
              }
            }
            checkJSONModuleImport(t) {
              if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
                let { specifiers: r2 } = t;
                if (r2 != null) {
                  let e = r2.find((s) => {
                    let i;
                    if (s.type === "ExportSpecifier" ? i = s.local : s.type === "ImportSpecifier" && (i = s.imported), i !== void 0) return i.type === "Identifier" ? i.name !== "default" : i.value !== "default";
                  });
                  e !== void 0 && this.raise(f.ImportJSONBindingNotDefault, { at: e.loc.start });
                }
              }
            }
            parseMaybeImportReflection(t) {
              let r2 = false;
              if (this.isContextual(125)) {
                let e = this.lookahead(), s = e.type;
                q(s) ? (s !== 97 || this.input.charCodeAt(this.nextTokenStartSince(e.end)) === 102) && (r2 = true) : s !== 12 && (r2 = true);
              }
              r2 ? (this.expectPlugin("importReflection"), this.next(), t.module = true) : this.hasPlugin("importReflection") && (t.module = false);
            }
            parseImport(t) {
              if (t.specifiers = [], !this.match(131)) {
                this.parseMaybeImportReflection(t);
                let s = !this.maybeParseDefaultImportSpecifier(t) || this.eat(12), i = s && this.maybeParseStarImportSpecifier(t);
                s && !i && this.parseNamedImportSpecifiers(t), this.expectContextual(97);
              }
              t.source = this.parseImportSource();
              let r2 = this.maybeParseImportAssertions();
              if (r2) t.assertions = r2;
              else {
                let e = this.maybeParseModuleAttributes();
                e && (t.attributes = e);
              }
              return this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
            }
            parseImportSource() {
              return this.match(131) || this.unexpected(), this.parseExprAtom();
            }
            shouldParseDefaultImport(t) {
              return q(this.state.type);
            }
            parseImportSpecifierLocal(t, r2, e) {
              r2.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r2, e));
            }
            finishImportSpecifier(t, r2) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Be;
              return this.checkLVal(t.local, { in: { type: r2 }, binding: e }), this.finishNode(t, r2);
            }
            parseAssertEntries() {
              let t = [], r2 = /* @__PURE__ */ new Set();
              do {
                if (this.match(8)) break;
                let e = this.startNode(), s = this.state.value;
                if (r2.has(s) && this.raise(f.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: s }), r2.add(s), this.match(131) ? e.key = this.parseStringLiteral(s) : e.key = this.parseIdentifier(true), this.expect(14), !this.match(131)) throw this.raise(f.ModuleAttributeInvalidValue, { at: this.state.startLoc });
                e.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(e, "ImportAttribute"));
              } while (this.eat(12));
              return t;
            }
            maybeParseModuleAttributes() {
              if (this.match(76) && !this.hasPrecedingLineBreak()) this.expectPlugin("moduleAttributes"), this.next();
              else return this.hasPlugin("moduleAttributes") ? [] : null;
              let t = [], r2 = /* @__PURE__ */ new Set();
              do {
                let e = this.startNode();
                if (e.key = this.parseIdentifier(true), e.key.name !== "type" && this.raise(f.ModuleAttributeDifferentFromType, { at: e.key }), r2.has(e.key.name) && this.raise(f.ModuleAttributesWithDuplicateKeys, { at: e.key, key: e.key.name }), r2.add(e.key.name), this.expect(14), !this.match(131)) throw this.raise(f.ModuleAttributeInvalidValue, { at: this.state.startLoc });
                e.value = this.parseStringLiteral(this.state.value), this.finishNode(e, "ImportAttribute"), t.push(e);
              } while (this.eat(12));
              return t;
            }
            maybeParseImportAssertions() {
              if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.expectPlugin("importAssertions"), this.next();
              else return this.hasPlugin("importAssertions") ? [] : null;
              this.eat(5);
              let t = this.parseAssertEntries();
              return this.eat(8), t;
            }
            maybeParseDefaultImportSpecifier(t) {
              return this.shouldParseDefaultImport(t) ? (this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), true) : false;
            }
            maybeParseStarImportSpecifier(t) {
              if (this.match(55)) {
                let r2 = this.startNode();
                return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r2, "ImportNamespaceSpecifier"), true;
              }
              return false;
            }
            parseNamedImportSpecifiers(t) {
              let r2 = true;
              for (this.expect(5); !this.eat(8); ) {
                if (r2) r2 = false;
                else {
                  if (this.eat(14)) throw this.raise(f.DestructureNamedImport, { at: this.state.startLoc });
                  if (this.expect(12), this.eat(8)) break;
                }
                let e = this.startNode(), s = this.match(131), i = this.isContextual(128);
                e.imported = this.parseModuleExportName();
                let a = this.parseImportSpecifier(e, s, t.importKind === "type" || t.importKind === "typeof", i, void 0);
                t.specifiers.push(a);
              }
            }
            parseImportSpecifier(t, r2, e, s, i) {
              if (this.eatContextual(93)) t.local = this.parseIdentifier();
              else {
                let { imported: a } = t;
                if (r2) throw this.raise(f.ImportBindingIsString, { at: t, importName: a.value });
                this.checkReservedWord(a.name, t.loc.start, true, true), t.local || (t.local = me(a));
              }
              return this.finishImportSpecifier(t, "ImportSpecifier", i);
            }
            isThisParam(t) {
              return t.type === "Identifier" && t.name === "this";
            }
          }, Yr = class extends vh {
            constructor(t, r2) {
              t = p(t), super(t, r2), this.options = t, this.initializeScopes(), this.plugins = Eh(this.options.plugins), this.filename = t.sourceFilename;
            }
            getScopeHandler() {
              return is;
            }
            parse() {
              this.enterInitialScopes();
              let t = this.startNode(), r2 = this.startNode();
              return this.nextToken(), t.errors = null, this.parseTopLevel(t, r2), t.errors = this.state.errors, t;
            }
          };
          function Eh(t) {
            let r2 = /* @__PURE__ */ new Map();
            for (let e of t) {
              let [s, i] = Array.isArray(e) ? e : [e, {}];
              r2.has(s) || r2.set(s, i || {});
            }
            return r2;
          }
          function Ch(t, r2) {
            var e;
            if (((e = r2) == null ? void 0 : e.sourceType) === "unambiguous") {
              r2 = Object.assign({}, r2);
              try {
                r2.sourceType = "module";
                let s = Xe(r2, t), i = s.parse();
                if (s.sawUnambiguousESM) return i;
                if (s.ambiguousScriptDifferentAst) try {
                  return r2.sourceType = "script", Xe(r2, t).parse();
                } catch {
                }
                else i.program.sourceType = "script";
                return i;
              } catch (s) {
                try {
                  return r2.sourceType = "script", Xe(r2, t).parse();
                } catch {
                }
                throw s;
              }
            } else return Xe(r2, t).parse();
          }
          function bh(t, r2) {
            let e = Xe(r2, t);
            return e.options.strictMode && (e.state.strict = true), e.getExpression();
          }
          function Sh(t) {
            let r2 = {};
            for (let e of Object.keys(t)) r2[e] = ce(t[e]);
            return r2;
          }
          var wh = Sh(Z);
          function Xe(t, r2) {
            let e = Yr;
            return t != null && t.plugins && (yh(t.plugins), e = Ih(t.plugins)), new e(t, r2);
          }
          var Qr = {};
          function Ih(t) {
            let r2 = xh.filter((i) => J(t, i)), e = r2.join("/"), s = Qr[e];
            if (!s) {
              s = Yr;
              for (let i of r2) s = Xr[i](s);
              Qr[e] = s;
            }
            return s;
          }
          l.parse = Ch, l.parseExpression = bh, l.tokTypes = wh;
        } }), Xf = $({ "src/language-js/parse/json.js"(l, h) {
          U();
          var p = Io(), d = lr(), x = ko(), P = Do();
          function m() {
            let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { allowComments: L = true } = w;
            return function(_) {
              let { parseExpression: G } = Fo(), N;
              try {
                N = G(_, { tokens: true, ranges: true });
              } catch (O) {
                throw P(O);
              }
              if (!L && p(N.comments)) throw v(N.comments[0], "Comment");
              return S(N), N;
            };
          }
          function v(w, L) {
            let [A, _] = [w.loc.start, w.loc.end].map((G) => {
              let { line: N, column: O } = G;
              return { line: N, column: O + 1 };
            });
            return d(`${L} is not allowed in JSON.`, { start: A, end: _ });
          }
          function S(w) {
            switch (w.type) {
              case "ArrayExpression":
                for (let L of w.elements) L !== null && S(L);
                return;
              case "ObjectExpression":
                for (let L of w.properties) S(L);
                return;
              case "ObjectProperty":
                if (w.computed) throw v(w.key, "Computed key");
                if (w.shorthand) throw v(w.key, "Shorthand property");
                w.key.type !== "Identifier" && S(w.key), S(w.value);
                return;
              case "UnaryExpression": {
                let { operator: L, argument: A } = w;
                if (L !== "+" && L !== "-") throw v(w, `Operator '${w.operator}'`);
                if (A.type === "NumericLiteral" || A.type === "Identifier" && (A.name === "Infinity" || A.name === "NaN")) return;
                throw v(A, `Operator '${L}' before '${A.type}'`);
              }
              case "Identifier":
                if (w.name !== "Infinity" && w.name !== "NaN" && w.name !== "undefined") throw v(w, `Identifier '${w.name}'`);
                return;
              case "TemplateLiteral":
                if (p(w.expressions)) throw v(w.expressions[0], "'TemplateLiteral' with expression");
                for (let L of w.quasis) S(L);
                return;
              case "NullLiteral":
              case "BooleanLiteral":
              case "NumericLiteral":
              case "StringLiteral":
              case "TemplateElement":
                return;
              default:
                throw v(w, `'${w.type}'`);
            }
          }
          var k = m(), F = { json: x({ parse: k, hasPragma() {
            return true;
          } }), json5: x(k), "json-stringify": x({ parse: m({ allowComments: false }), astFormat: "estree-json" }) };
          h.exports = F;
        } });
        U();
        var Yf = kf(), Qf = po(), Zf = Of(), Ue = ko(), ed = Do(), td = Jf(), sd = Xf(), rd = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", { decoratorsBeforeExport: false }], "importAssertions", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors"], tokens: true, ranges: true }, id = ["recordAndTuple", { syntaxType: "hash" }], no = "v8intrinsic", oo = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], he = function(l) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rd;
          return Object.assign(Object.assign({}, h), {}, { plugins: [...h.plugins, ...l] });
        }, ad = /@(?:no)?flow\b/;
        function nd(l, h) {
          if (h.filepath && h.filepath.endsWith(".js.flow")) return true;
          let p = Qf(l);
          p && (l = l.slice(p.length));
          let d = Zf(l, 0);
          return d !== false && (l = l.slice(0, d)), ad.test(l);
        }
        function od(l, h, p) {
          let d = Fo()[l], x = d(h, p), P = x.errors.find((m) => !fd.has(m.reasonCode));
          if (P) throw P;
          return x;
        }
        function $e(l) {
          for (var h = arguments.length, p = new Array(h > 1 ? h - 1 : 0), d = 1; d < h; d++) p[d - 1] = arguments[d];
          return function(x, P) {
            let m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if ((m.parser === "babel" || m.parser === "__babel_estree") && nd(x, m)) return m.parser = "babel-flow", Lo(x, P, m);
            let v = p;
            m.__babelSourceType === "script" && (v = v.map((w) => Object.assign(Object.assign({}, w), {}, { sourceType: "script" }))), /#[[{]/.test(x) && (v = v.map((w) => he([id], w)));
            let S = /%[A-Z]/.test(x);
            x.includes("|>") ? v = (S ? [...oo, no] : oo).flatMap((L) => v.map((A) => he([L], A))) : S && (v = v.map((w) => he([no], w)));
            let { result: k, error: F } = Yf(...v.map((w) => () => od(l, x, w)));
            if (!k) throw ed(F);
            return m.originalText = x, td(k, m);
          };
        }
        var ld = $e("parse", he(["jsx", "flow"])), Lo = $e("parse", he(["jsx", ["flow", { all: true, enums: true }]])), hd = $e("parse", he(["jsx", "typescript"]), he(["typescript"])), ud = $e("parse", he(["jsx", "flow", "estree"])), cd = $e("parseExpression", he(["jsx"])), pd = $e("parseExpression", he(["typescript"])), fd = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), lo = Ue(ld), ho = Ue(hd), uo = Ue(cd), dd = Ue(pd);
        Oo.exports = { parsers: Object.assign(Object.assign({ babel: lo, "babel-flow": Ue(Lo), "babel-ts": ho }, sd), {}, { __js_expression: uo, __vue_expression: uo, __vue_ts_expression: dd, __vue_event_binding: lo, __vue_ts_event_binding: ho, __babel_estree: Ue(ud) }) };
      });
      return md();
    });
  }
});

// ../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/parser-markdown.js
var require_parser_markdown = __commonJS({
  "../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/parser-markdown.js"(exports, module) {
    init_esm_shims();
    (function(e) {
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.markdown = e();
      }
    })(function() {
      var $ = (e, r2) => () => (r2 || e((r2 = { exports: {} }).exports, r2), r2.exports);
      var Fe = $((nf, yu) => {
        var tr = function(e) {
          return e && e.Math == Math && e;
        };
        yu.exports = tr(typeof globalThis == "object" && globalThis) || tr(typeof window == "object" && window) || tr(typeof self == "object" && self) || tr(typeof global == "object" && global) || /* @__PURE__ */ (function() {
          return this;
        })() || Function("return this")();
      });
      var Ae = $((af, wu) => {
        wu.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var Be = $((of, Bu) => {
        var fa = Ae();
        Bu.exports = !fa(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var nr = $((sf, ku) => {
        var pa = Ae();
        ku.exports = !pa(function() {
          var e = function() {
          }.bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var Oe = $((cf, qu) => {
        var da = nr(), ir = Function.prototype.call;
        qu.exports = da ? ir.bind(ir) : function() {
          return ir.apply(ir, arguments);
        };
      });
      var Su = $((Iu) => {
        var _u = {}.propertyIsEnumerable, Ou = Object.getOwnPropertyDescriptor, ha = Ou && !_u.call({ 1: 2 }, 1);
        Iu.f = ha ? function(r2) {
          var u = Ou(this, r2);
          return !!u && u.enumerable;
        } : _u;
      });
      var ar = $((Df, Tu) => {
        Tu.exports = function(e, r2) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r2 };
        };
      });
      var ve = $((ff, Ru) => {
        var Nu = nr(), Lu = Function.prototype, wr = Lu.call, va = Nu && Lu.bind.bind(wr, wr);
        Ru.exports = Nu ? va : function(e) {
          return function() {
            return wr.apply(e, arguments);
          };
        };
      });
      var Ve = $((pf, Pu) => {
        var ju = ve(), ma = ju({}.toString), Ea = ju("".slice);
        Pu.exports = function(e) {
          return Ea(ma(e), 8, -1);
        };
      });
      var zu = $((df, Mu) => {
        var Ca = ve(), ga = Ae(), Fa = Ve(), Br = Object, Aa = Ca("".split);
        Mu.exports = ga(function() {
          return !Br("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return Fa(e) == "String" ? Aa(e, "") : Br(e);
        } : Br;
      });
      var or = $((hf, $u) => {
        $u.exports = function(e) {
          return e == null;
        };
      });
      var kr = $((vf, Uu) => {
        var xa = or(), ba = TypeError;
        Uu.exports = function(e) {
          if (xa(e)) throw ba("Can't call method on " + e);
          return e;
        };
      });
      var sr = $((mf, Gu) => {
        var ya = zu(), wa = kr();
        Gu.exports = function(e) {
          return ya(wa(e));
        };
      });
      var _r = $((Ef, Vu) => {
        var qr = typeof document == "object" && document.all, Ba = typeof qr > "u" && qr !== void 0;
        Vu.exports = { all: qr, IS_HTMLDDA: Ba };
      });
      var de = $((Cf, Xu) => {
        var Hu = _r(), ka = Hu.all;
        Xu.exports = Hu.IS_HTMLDDA ? function(e) {
          return typeof e == "function" || e === ka;
        } : function(e) {
          return typeof e == "function";
        };
      });
      var Ie = $((gf, Yu) => {
        var Wu = de(), Ku = _r(), qa = Ku.all;
        Yu.exports = Ku.IS_HTMLDDA ? function(e) {
          return typeof e == "object" ? e !== null : Wu(e) || e === qa;
        } : function(e) {
          return typeof e == "object" ? e !== null : Wu(e);
        };
      });
      var He = $((Ff, Ju) => {
        var Or = Fe(), _a = de(), Oa = function(e) {
          return _a(e) ? e : void 0;
        };
        Ju.exports = function(e, r2) {
          return arguments.length < 2 ? Oa(Or[e]) : Or[e] && Or[e][r2];
        };
      });
      var Ir = $((Af, Zu) => {
        var Ia = ve();
        Zu.exports = Ia({}.isPrototypeOf);
      });
      var et = $((xf, Qu) => {
        var Sa = He();
        Qu.exports = Sa("navigator", "userAgent") || "";
      });
      var ot = $((bf, at) => {
        var it = Fe(), Sr = et(), rt = it.process, ut = it.Deno, tt = rt && rt.versions || ut && ut.version, nt = tt && tt.v8, me, cr;
        nt && (me = nt.split("."), cr = me[0] > 0 && me[0] < 4 ? 1 : +(me[0] + me[1]));
        !cr && Sr && (me = Sr.match(/Edge\/(\d+)/), (!me || me[1] >= 74) && (me = Sr.match(/Chrome\/(\d+)/), me && (cr = +me[1])));
        at.exports = cr;
      });
      var Tr = $((yf, ct) => {
        var st = ot(), Ta = Ae();
        ct.exports = !!Object.getOwnPropertySymbols && !Ta(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && st && st < 41;
        });
      });
      var Nr = $((wf, lt) => {
        var Na = Tr();
        lt.exports = Na && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Lr = $((Bf, Dt) => {
        var La = He(), Ra = de(), ja = Ir(), Pa = Nr(), Ma = Object;
        Dt.exports = Pa ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var r2 = La("Symbol");
          return Ra(r2) && ja(r2.prototype, Ma(e));
        };
      });
      var lr = $((kf, ft) => {
        var za = String;
        ft.exports = function(e) {
          try {
            return za(e);
          } catch {
            return "Object";
          }
        };
      });
      var Xe = $((qf, pt) => {
        var $a = de(), Ua = lr(), Ga = TypeError;
        pt.exports = function(e) {
          if ($a(e)) return e;
          throw Ga(Ua(e) + " is not a function");
        };
      });
      var Dr = $((_f, dt) => {
        var Va = Xe(), Ha = or();
        dt.exports = function(e, r2) {
          var u = e[r2];
          return Ha(u) ? void 0 : Va(u);
        };
      });
      var vt = $((Of, ht) => {
        var Rr = Oe(), jr = de(), Pr = Ie(), Xa = TypeError;
        ht.exports = function(e, r2) {
          var u, t;
          if (r2 === "string" && jr(u = e.toString) && !Pr(t = Rr(u, e)) || jr(u = e.valueOf) && !Pr(t = Rr(u, e)) || r2 !== "string" && jr(u = e.toString) && !Pr(t = Rr(u, e))) return t;
          throw Xa("Can't convert object to primitive value");
        };
      });
      var Et = $((If, mt) => {
        mt.exports = false;
      });
      var fr = $((Sf, gt) => {
        var Ct = Fe(), Wa = Object.defineProperty;
        gt.exports = function(e, r2) {
          try {
            Wa(Ct, e, { value: r2, configurable: true, writable: true });
          } catch {
            Ct[e] = r2;
          }
          return r2;
        };
      });
      var pr = $((Tf, At) => {
        var Ka = Fe(), Ya = fr(), Ft = "__core-js_shared__", Ja = Ka[Ft] || Ya(Ft, {});
        At.exports = Ja;
      });
      var Mr = $((Nf, bt) => {
        var Za = Et(), xt = pr();
        (bt.exports = function(e, r2) {
          return xt[e] || (xt[e] = r2 !== void 0 ? r2 : {});
        })("versions", []).push({ version: "3.26.1", mode: Za ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var zr = $((Lf, yt) => {
        var Qa = kr(), eo = Object;
        yt.exports = function(e) {
          return eo(Qa(e));
        };
      });
      var ke = $((Rf, wt) => {
        var ro = ve(), uo = zr(), to = ro({}.hasOwnProperty);
        wt.exports = Object.hasOwn || function(r2, u) {
          return to(uo(r2), u);
        };
      });
      var $r = $((jf, Bt) => {
        var no = ve(), io = 0, ao = Math.random(), oo = no(1 .toString);
        Bt.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + oo(++io + ao, 36);
        };
      });
      var Te = $((Pf, It) => {
        var so = Fe(), co = Mr(), kt = ke(), lo = $r(), qt = Tr(), Ot = Nr(), Le = co("wks"), Se = so.Symbol, _t = Se && Se.for, Do = Ot ? Se : Se && Se.withoutSetter || lo;
        It.exports = function(e) {
          if (!kt(Le, e) || !(qt || typeof Le[e] == "string")) {
            var r2 = "Symbol." + e;
            qt && kt(Se, e) ? Le[e] = Se[e] : Ot && _t ? Le[e] = _t(r2) : Le[e] = Do(r2);
          }
          return Le[e];
        };
      });
      var Lt = $((Mf, Nt) => {
        var fo = Oe(), St = Ie(), Tt = Lr(), po = Dr(), ho = vt(), vo = Te(), mo = TypeError, Eo = vo("toPrimitive");
        Nt.exports = function(e, r2) {
          if (!St(e) || Tt(e)) return e;
          var u = po(e, Eo), t;
          if (u) {
            if (r2 === void 0 && (r2 = "default"), t = fo(u, e, r2), !St(t) || Tt(t)) return t;
            throw mo("Can't convert object to primitive value");
          }
          return r2 === void 0 && (r2 = "number"), ho(e, r2);
        };
      });
      var dr = $((zf, Rt) => {
        var Co = Lt(), go2 = Lr();
        Rt.exports = function(e) {
          var r2 = Co(e, "string");
          return go2(r2) ? r2 : r2 + "";
        };
      });
      var Mt = $(($f, Pt) => {
        var Fo = Fe(), jt = Ie(), Ur = Fo.document, Ao = jt(Ur) && jt(Ur.createElement);
        Pt.exports = function(e) {
          return Ao ? Ur.createElement(e) : {};
        };
      });
      var Gr = $((Uf, zt) => {
        var xo = Be(), bo = Ae(), yo = Mt();
        zt.exports = !xo && !bo(function() {
          return Object.defineProperty(yo("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Vr = $((Ut) => {
        var wo = Be(), Bo = Oe(), ko = Su(), qo = ar(), _o = sr(), Oo = dr(), Io = ke(), So = Gr(), $t = Object.getOwnPropertyDescriptor;
        Ut.f = wo ? $t : function(r2, u) {
          if (r2 = _o(r2), u = Oo(u), So) try {
            return $t(r2, u);
          } catch {
          }
          if (Io(r2, u)) return qo(!Bo(ko.f, r2, u), r2[u]);
        };
      });
      var Vt = $((Vf, Gt) => {
        var To = Be(), No = Ae();
        Gt.exports = To && No(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Re = $((Hf, Ht) => {
        var Lo = Ie(), Ro = String, jo = TypeError;
        Ht.exports = function(e) {
          if (Lo(e)) return e;
          throw jo(Ro(e) + " is not an object");
        };
      });
      var We = $((Wt) => {
        var Po = Be(), Mo = Gr(), zo = Vt(), hr = Re(), Xt = dr(), $o = TypeError, Hr = Object.defineProperty, Uo = Object.getOwnPropertyDescriptor, Xr = "enumerable", Wr = "configurable", Kr = "writable";
        Wt.f = Po ? zo ? function(r2, u, t) {
          if (hr(r2), u = Xt(u), hr(t), typeof r2 == "function" && u === "prototype" && "value" in t && Kr in t && !t[Kr]) {
            var a = Uo(r2, u);
            a && a[Kr] && (r2[u] = t.value, t = { configurable: Wr in t ? t[Wr] : a[Wr], enumerable: Xr in t ? t[Xr] : a[Xr], writable: false });
          }
          return Hr(r2, u, t);
        } : Hr : function(r2, u, t) {
          if (hr(r2), u = Xt(u), hr(t), Mo) try {
            return Hr(r2, u, t);
          } catch {
          }
          if ("get" in t || "set" in t) throw $o("Accessors not supported");
          return "value" in t && (r2[u] = t.value), r2;
        };
      });
      var Yr = $((Wf, Kt) => {
        var Go = Be(), Vo = We(), Ho = ar();
        Kt.exports = Go ? function(e, r2, u) {
          return Vo.f(e, r2, Ho(1, u));
        } : function(e, r2, u) {
          return e[r2] = u, e;
        };
      });
      var Zt = $((Kf, Jt) => {
        var Jr = Be(), Xo = ke(), Yt = Function.prototype, Wo = Jr && Object.getOwnPropertyDescriptor, Zr = Xo(Yt, "name"), Ko = Zr && function() {
        }.name === "something", Yo = Zr && (!Jr || Jr && Wo(Yt, "name").configurable);
        Jt.exports = { EXISTS: Zr, PROPER: Ko, CONFIGURABLE: Yo };
      });
      var eu = $((Yf, Qt) => {
        var Jo = ve(), Zo = de(), Qr = pr(), Qo = Jo(Function.toString);
        Zo(Qr.inspectSource) || (Qr.inspectSource = function(e) {
          return Qo(e);
        });
        Qt.exports = Qr.inspectSource;
      });
      var un = $((Jf, rn) => {
        var es = Fe(), rs = de(), en = es.WeakMap;
        rn.exports = rs(en) && /native code/.test(String(en));
      });
      var an = $((Zf, nn) => {
        var us = Mr(), ts = $r(), tn = us("keys");
        nn.exports = function(e) {
          return tn[e] || (tn[e] = ts(e));
        };
      });
      var ru = $((Qf, on) => {
        on.exports = {};
      });
      var Dn = $((ep, ln) => {
        var ns = un(), cn = Fe(), is = Ie(), as = Yr(), uu = ke(), tu = pr(), os = an(), ss = ru(), sn = "Object already initialized", nu = cn.TypeError, cs = cn.WeakMap, vr, Ke, mr, ls = function(e) {
          return mr(e) ? Ke(e) : vr(e, {});
        }, Ds = function(e) {
          return function(r2) {
            var u;
            if (!is(r2) || (u = Ke(r2)).type !== e) throw nu("Incompatible receiver, " + e + " required");
            return u;
          };
        };
        ns || tu.state ? (Ee = tu.state || (tu.state = new cs()), Ee.get = Ee.get, Ee.has = Ee.has, Ee.set = Ee.set, vr = function(e, r2) {
          if (Ee.has(e)) throw nu(sn);
          return r2.facade = e, Ee.set(e, r2), r2;
        }, Ke = function(e) {
          return Ee.get(e) || {};
        }, mr = function(e) {
          return Ee.has(e);
        }) : (Ne = os("state"), ss[Ne] = true, vr = function(e, r2) {
          if (uu(e, Ne)) throw nu(sn);
          return r2.facade = e, as(e, Ne, r2), r2;
        }, Ke = function(e) {
          return uu(e, Ne) ? e[Ne] : {};
        }, mr = function(e) {
          return uu(e, Ne);
        });
        var Ee, Ne;
        ln.exports = { set: vr, get: Ke, has: mr, enforce: ls, getterFor: Ds };
      });
      var dn = $((rp, pn) => {
        var fs = Ae(), ps = de(), Er = ke(), iu = Be(), ds = Zt().CONFIGURABLE, hs = eu(), fn = Dn(), vs = fn.enforce, ms = fn.get, Cr = Object.defineProperty, Es = iu && !fs(function() {
          return Cr(function() {
          }, "length", { value: 8 }).length !== 8;
        }), Cs = String(String).split("String"), gs = pn.exports = function(e, r2, u) {
          String(r2).slice(0, 7) === "Symbol(" && (r2 = "[" + String(r2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), u && u.getter && (r2 = "get " + r2), u && u.setter && (r2 = "set " + r2), (!Er(e, "name") || ds && e.name !== r2) && (iu ? Cr(e, "name", { value: r2, configurable: true }) : e.name = r2), Es && u && Er(u, "arity") && e.length !== u.arity && Cr(e, "length", { value: u.arity });
          try {
            u && Er(u, "constructor") && u.constructor ? iu && Cr(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
          } catch {
          }
          var t = vs(e);
          return Er(t, "source") || (t.source = Cs.join(typeof r2 == "string" ? r2 : "")), e;
        };
        Function.prototype.toString = gs(function() {
          return ps(this) && ms(this).source || hs(this);
        }, "toString");
      });
      var vn = $((up, hn) => {
        var Fs = de(), As = We(), xs = dn(), bs = fr();
        hn.exports = function(e, r2, u, t) {
          t || (t = {});
          var a = t.enumerable, n = t.name !== void 0 ? t.name : r2;
          if (Fs(u) && xs(u, n, t), t.global) a ? e[r2] = u : bs(r2, u);
          else {
            try {
              t.unsafe ? e[r2] && (a = true) : delete e[r2];
            } catch {
            }
            a ? e[r2] = u : As.f(e, r2, { value: u, enumerable: false, configurable: !t.nonConfigurable, writable: !t.nonWritable });
          }
          return e;
        };
      });
      var En = $((tp, mn) => {
        var ys = Math.ceil, ws = Math.floor;
        mn.exports = Math.trunc || function(r2) {
          var u = +r2;
          return (u > 0 ? ws : ys)(u);
        };
      });
      var au = $((np, Cn) => {
        var Bs = En();
        Cn.exports = function(e) {
          var r2 = +e;
          return r2 !== r2 || r2 === 0 ? 0 : Bs(r2);
        };
      });
      var Fn = $((ip, gn) => {
        var ks = au(), qs = Math.max, _s = Math.min;
        gn.exports = function(e, r2) {
          var u = ks(e);
          return u < 0 ? qs(u + r2, 0) : _s(u, r2);
        };
      });
      var xn = $((ap, An) => {
        var Os = au(), Is = Math.min;
        An.exports = function(e) {
          return e > 0 ? Is(Os(e), 9007199254740991) : 0;
        };
      });
      var Ye = $((op, bn) => {
        var Ss = xn();
        bn.exports = function(e) {
          return Ss(e.length);
        };
      });
      var Bn = $((sp, wn) => {
        var Ts = sr(), Ns = Fn(), Ls = Ye(), yn = function(e) {
          return function(r2, u, t) {
            var a = Ts(r2), n = Ls(a), s = Ns(t, n), c2;
            if (e && u != u) {
              for (; n > s; ) if (c2 = a[s++], c2 != c2) return true;
            } else for (; n > s; s++) if ((e || s in a) && a[s] === u) return e || s || 0;
            return !e && -1;
          };
        };
        wn.exports = { includes: yn(true), indexOf: yn(false) };
      });
      var _n = $((cp, qn) => {
        var Rs = ve(), ou = ke(), js = sr(), Ps = Bn().indexOf, Ms = ru(), kn = Rs([].push);
        qn.exports = function(e, r2) {
          var u = js(e), t = 0, a = [], n;
          for (n in u) !ou(Ms, n) && ou(u, n) && kn(a, n);
          for (; r2.length > t; ) ou(u, n = r2[t++]) && (~Ps(a, n) || kn(a, n));
          return a;
        };
      });
      var In = $((lp, On) => {
        On.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var Tn = $((Sn) => {
        var zs = _n(), $s = In(), Us = $s.concat("length", "prototype");
        Sn.f = Object.getOwnPropertyNames || function(r2) {
          return zs(r2, Us);
        };
      });
      var Ln = $((Nn) => {
        Nn.f = Object.getOwnPropertySymbols;
      });
      var jn = $((pp, Rn) => {
        var Gs = He(), Vs = ve(), Hs = Tn(), Xs = Ln(), Ws = Re(), Ks = Vs([].concat);
        Rn.exports = Gs("Reflect", "ownKeys") || function(r2) {
          var u = Hs.f(Ws(r2)), t = Xs.f;
          return t ? Ks(u, t(r2)) : u;
        };
      });
      var zn = $((dp, Mn) => {
        var Pn = ke(), Ys = jn(), Js = Vr(), Zs = We();
        Mn.exports = function(e, r2, u) {
          for (var t = Ys(r2), a = Zs.f, n = Js.f, s = 0; s < t.length; s++) {
            var c2 = t[s];
            !Pn(e, c2) && !(u && Pn(u, c2)) && a(e, c2, n(r2, c2));
          }
        };
      });
      var Un = $((hp, $n) => {
        var Qs = Ae(), ec = de(), rc = /#|\.prototype\./, Je = function(e, r2) {
          var u = tc[uc(e)];
          return u == ic ? true : u == nc ? false : ec(r2) ? Qs(r2) : !!r2;
        }, uc = Je.normalize = function(e) {
          return String(e).replace(rc, ".").toLowerCase();
        }, tc = Je.data = {}, nc = Je.NATIVE = "N", ic = Je.POLYFILL = "P";
        $n.exports = Je;
      });
      var cu = $((vp, Gn) => {
        var su = Fe(), ac = Vr().f, oc = Yr(), sc = vn(), cc = fr(), lc = zn(), Dc = Un();
        Gn.exports = function(e, r2) {
          var u = e.target, t = e.global, a = e.stat, n, s, c2, i, D, o;
          if (t ? s = su : a ? s = su[u] || cc(u, {}) : s = (su[u] || {}).prototype, s) for (c2 in r2) {
            if (D = r2[c2], e.dontCallGetSet ? (o = ac(s, c2), i = o && o.value) : i = s[c2], n = Dc(t ? c2 : u + (a ? "." : "#") + c2, e.forced), !n && i !== void 0) {
              if (typeof D == typeof i) continue;
              lc(D, i);
            }
            (e.sham || i && i.sham) && oc(D, "sham", true), sc(s, c2, D, e);
          }
        };
      });
      var lu = $((mp, Vn) => {
        var fc = Ve();
        Vn.exports = Array.isArray || function(r2) {
          return fc(r2) == "Array";
        };
      });
      var Xn = $((Ep, Hn) => {
        var pc = TypeError, dc = 9007199254740991;
        Hn.exports = function(e) {
          if (e > dc) throw pc("Maximum allowed index exceeded");
          return e;
        };
      });
      var Kn = $((Cp, Wn) => {
        var hc = Ve(), vc = ve();
        Wn.exports = function(e) {
          if (hc(e) === "Function") return vc(e);
        };
      });
      var Du = $((gp, Jn) => {
        var Yn = Kn(), mc = Xe(), Ec = nr(), Cc = Yn(Yn.bind);
        Jn.exports = function(e, r2) {
          return mc(e), r2 === void 0 ? e : Ec ? Cc(e, r2) : function() {
            return e.apply(r2, arguments);
          };
        };
      });
      var ei = $((Fp, Qn) => {
        var gc = lu(), Fc = Ye(), Ac = Xn(), xc = Du(), Zn = function(e, r2, u, t, a, n, s, c2) {
          for (var i = a, D = 0, o = s ? xc(s, c2) : false, l, d; D < t; ) D in u && (l = o ? o(u[D], D, r2) : u[D], n > 0 && gc(l) ? (d = Fc(l), i = Zn(e, r2, l, d, i, n - 1) - 1) : (Ac(i + 1), e[i] = l), i++), D++;
          return i;
        };
        Qn.exports = Zn;
      });
      var ti = $((Ap, ui) => {
        var bc = Te(), yc = bc("toStringTag"), ri = {};
        ri[yc] = "z";
        ui.exports = String(ri) === "[object z]";
      });
      var fu = $((xp, ni) => {
        var wc = ti(), Bc = de(), gr = Ve(), kc = Te(), qc = kc("toStringTag"), _c = Object, Oc = gr(/* @__PURE__ */ (function() {
          return arguments;
        })()) == "Arguments", Ic = function(e, r2) {
          try {
            return e[r2];
          } catch {
          }
        };
        ni.exports = wc ? gr : function(e) {
          var r2, u, t;
          return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (u = Ic(r2 = _c(e), qc)) == "string" ? u : Oc ? gr(r2) : (t = gr(r2)) == "Object" && Bc(r2.callee) ? "Arguments" : t;
        };
      });
      var li = $((bp, ci) => {
        var Sc = ve(), Tc = Ae(), ii = de(), Nc = fu(), Lc = He(), Rc = eu(), ai = function() {
        }, jc = [], oi = Lc("Reflect", "construct"), pu = /^\s*(?:class|function)\b/, Pc = Sc(pu.exec), Mc = !pu.exec(ai), Ze = function(r2) {
          if (!ii(r2)) return false;
          try {
            return oi(ai, jc, r2), true;
          } catch {
            return false;
          }
        }, si = function(r2) {
          if (!ii(r2)) return false;
          switch (Nc(r2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Mc || !!Pc(pu, Rc(r2));
          } catch {
            return true;
          }
        };
        si.sham = true;
        ci.exports = !oi || Tc(function() {
          var e;
          return Ze(Ze.call) || !Ze(Object) || !Ze(function() {
            e = true;
          }) || e;
        }) ? si : Ze;
      });
      var di = $((yp, pi) => {
        var Di = lu(), zc = li(), $c = Ie(), Uc = Te(), Gc = Uc("species"), fi = Array;
        pi.exports = function(e) {
          var r2;
          return Di(e) && (r2 = e.constructor, zc(r2) && (r2 === fi || Di(r2.prototype)) ? r2 = void 0 : $c(r2) && (r2 = r2[Gc], r2 === null && (r2 = void 0))), r2 === void 0 ? fi : r2;
        };
      });
      var vi = $((wp, hi) => {
        var Vc = di();
        hi.exports = function(e, r2) {
          return new (Vc(e))(r2 === 0 ? 0 : r2);
        };
      });
      var mi = $(() => {
        var Hc = cu(), Xc = ei(), Wc = Xe(), Kc = zr(), Yc = Ye(), Jc = vi();
        Hc({ target: "Array", proto: true }, { flatMap: function(r2) {
          var u = Kc(this), t = Yc(u), a;
          return Wc(r2), a = Jc(u, 0), a.length = Xc(a, u, u, t, 0, 1, r2, arguments.length > 1 ? arguments[1] : void 0), a;
        } });
      });
      var du = $((qp, Ei) => {
        Ei.exports = {};
      });
      var gi = $((_p, Ci) => {
        var Zc = Te(), Qc = du(), el = Zc("iterator"), rl = Array.prototype;
        Ci.exports = function(e) {
          return e !== void 0 && (Qc.Array === e || rl[el] === e);
        };
      });
      var hu = $((Op, Ai) => {
        var ul = fu(), Fi = Dr(), tl = or(), nl = du(), il = Te(), al = il("iterator");
        Ai.exports = function(e) {
          if (!tl(e)) return Fi(e, al) || Fi(e, "@@iterator") || nl[ul(e)];
        };
      });
      var bi = $((Ip, xi) => {
        var ol = Oe(), sl = Xe(), cl = Re(), ll = lr(), Dl = hu(), fl = TypeError;
        xi.exports = function(e, r2) {
          var u = arguments.length < 2 ? Dl(e) : r2;
          if (sl(u)) return cl(ol(u, e));
          throw fl(ll(e) + " is not iterable");
        };
      });
      var Bi = $((Sp, wi) => {
        var pl = Oe(), yi = Re(), dl = Dr();
        wi.exports = function(e, r2, u) {
          var t, a;
          yi(e);
          try {
            if (t = dl(e, "return"), !t) {
              if (r2 === "throw") throw u;
              return u;
            }
            t = pl(t, e);
          } catch (n) {
            a = true, t = n;
          }
          if (r2 === "throw") throw u;
          if (a) throw t;
          return yi(t), u;
        };
      });
      var Ii = $((Tp, Oi) => {
        var hl = Du(), vl = Oe(), ml = Re(), El = lr(), Cl = gi(), gl = Ye(), ki = Ir(), Fl = bi(), Al = hu(), qi = Bi(), xl = TypeError, Fr = function(e, r2) {
          this.stopped = e, this.result = r2;
        }, _i = Fr.prototype;
        Oi.exports = function(e, r2, u) {
          var t = u && u.that, a = !!(u && u.AS_ENTRIES), n = !!(u && u.IS_RECORD), s = !!(u && u.IS_ITERATOR), c2 = !!(u && u.INTERRUPTED), i = hl(r2, t), D, o, l, d, p, g, F, E = function(f) {
            return D && qi(D, "normal", f), new Fr(true, f);
          }, b = function(f) {
            return a ? (ml(f), c2 ? i(f[0], f[1], E) : i(f[0], f[1])) : c2 ? i(f, E) : i(f);
          };
          if (n) D = e.iterator;
          else if (s) D = e;
          else {
            if (o = Al(e), !o) throw xl(El(e) + " is not iterable");
            if (Cl(o)) {
              for (l = 0, d = gl(e); d > l; l++) if (p = b(e[l]), p && ki(_i, p)) return p;
              return new Fr(false);
            }
            D = Fl(e, o);
          }
          for (g = n ? e.next : D.next; !(F = vl(g, D)).done; ) {
            try {
              p = b(F.value);
            } catch (f) {
              qi(D, "throw", f);
            }
            if (typeof p == "object" && p && ki(_i, p)) return p;
          }
          return new Fr(false);
        };
      });
      var Ti = $((Np, Si) => {
        var bl = dr(), yl = We(), wl = ar();
        Si.exports = function(e, r2, u) {
          var t = bl(r2);
          t in e ? yl.f(e, t, wl(0, u)) : e[t] = u;
        };
      });
      var Ni = $(() => {
        var Bl = cu(), kl = Ii(), ql = Ti();
        Bl({ target: "Object", stat: true }, { fromEntries: function(r2) {
          var u = {};
          return kl(r2, function(t, a) {
            ql(u, t, a);
          }, { AS_ENTRIES: true }), u;
        } });
      });
      var uf = $((jp, la) => {
        var _l = ["cliName", "cliCategory", "cliDescription"];
        function Ol(e, r3) {
          if (e == null) return {};
          var u = Il(e, r3), t, a;
          if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            for (a = 0; a < n.length; a++) t = n[a], !(r3.indexOf(t) >= 0) && Object.prototype.propertyIsEnumerable.call(e, t) && (u[t] = e[t]);
          }
          return u;
        }
        function Il(e, r3) {
          if (e == null) return {};
          var u = {}, t = Object.keys(e), a, n;
          for (n = 0; n < t.length; n++) a = t[n], !(r3.indexOf(a) >= 0) && (u[a] = e[a]);
          return u;
        }
        mi();
        Ni();
        var Sl = Object.create, Ar = Object.defineProperty, Tl = Object.getOwnPropertyDescriptor, vu = Object.getOwnPropertyNames, Nl = Object.getPrototypeOf, Ll = Object.prototype.hasOwnProperty, je = (e, r3) => function() {
          return e && (r3 = (0, e[vu(e)[0]])(e = 0)), r3;
        }, S = (e, r3) => function() {
          return r3 || (0, e[vu(e)[0]])((r3 = { exports: {} }).exports, r3), r3.exports;
        }, Pi = (e, r3) => {
          for (var u in r3) Ar(e, u, { get: r3[u], enumerable: true });
        }, Mi = (e, r3, u, t) => {
          if (r3 && typeof r3 == "object" || typeof r3 == "function") for (let a of vu(r3)) !Ll.call(e, a) && a !== u && Ar(e, a, { get: () => r3[a], enumerable: !(t = Tl(r3, a)) || t.enumerable });
          return e;
        }, Rl = (e, r3, u) => (u = e != null ? Sl(Nl(e)) : {}, Mi(!e || !e.__esModule ? Ar(u, "default", { value: e, enumerable: true }) : u, e)), zi = (e) => Mi(Ar({}, "__esModule", { value: true }), e), Qe, I = je({ "<define:process>"() {
          Qe = { env: {}, argv: [] };
        } }), Pe = S({ "node_modules/xtend/immutable.js"(e, r3) {
          I(), r3.exports = t;
          var u = Object.prototype.hasOwnProperty;
          function t() {
            for (var a = {}, n = 0; n < arguments.length; n++) {
              var s = arguments[n];
              for (var c3 in s) u.call(s, c3) && (a[c3] = s[c3]);
            }
            return a;
          }
        } }), jl = S({ "node_modules/inherits/inherits_browser.js"(e, r3) {
          I(), typeof Object.create == "function" ? r3.exports = function(t, a) {
            a && (t.super_ = a, t.prototype = Object.create(a.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
          } : r3.exports = function(t, a) {
            if (a) {
              t.super_ = a;
              var n = function() {
              };
              n.prototype = a.prototype, t.prototype = new n(), t.prototype.constructor = t;
            }
          };
        } }), Pl = S({ "node_modules/unherit/index.js"(e, r3) {
          I();
          var u = Pe(), t = jl();
          r3.exports = a;
          function a(n) {
            var s, c3, i;
            t(o, n), t(D, o), s = o.prototype;
            for (c3 in s) i = s[c3], i && typeof i == "object" && (s[c3] = "concat" in i ? i.concat() : u(i));
            return o;
            function D(l) {
              return n.apply(this, l);
            }
            function o() {
              return this instanceof o ? n.apply(this, arguments) : new D(arguments);
            }
          }
        } }), Ml = S({ "node_modules/state-toggle/index.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a, n) {
            return s;
            function s() {
              var c3 = n || this, i = c3[t];
              return c3[t] = !a, D;
              function D() {
                c3[t] = i;
              }
            }
          }
        } }), zl = S({ "node_modules/vfile-location/index.js"(e, r3) {
          I(), r3.exports = u;
          function u(t) {
            for (var a = String(t), n = [], s = /\r?\n|\r/g; s.exec(a); ) n.push(s.lastIndex);
            return n.push(a.length + 1), { toPoint: c3, toPosition: c3, toOffset: i };
            function c3(D) {
              var o = -1;
              if (D > -1 && D < n[n.length - 1]) {
                for (; ++o < n.length; ) if (n[o] > D) return { line: o + 1, column: D - (n[o - 1] || 0) + 1, offset: D };
              }
              return {};
            }
            function i(D) {
              var o = D && D.line, l = D && D.column, d;
              return !isNaN(o) && !isNaN(l) && o - 1 in n && (d = (n[o - 2] || 0) + l - 1 || 0), d > -1 && d < n[n.length - 1] ? d : -1;
            }
          }
        } }), $l = S({ "node_modules/remark-parse/lib/unescape.js"(e, r3) {
          I(), r3.exports = t;
          var u = "\\";
          function t(a, n) {
            return s;
            function s(c3) {
              for (var i = 0, D = c3.indexOf(u), o = a[n], l = [], d; D !== -1; ) l.push(c3.slice(i, D)), i = D + 1, d = c3.charAt(i), (!d || o.indexOf(d) === -1) && l.push(u), D = c3.indexOf(u, i + 1);
              return l.push(c3.slice(i)), l.join("");
            }
          }
        } }), Ul = S({ "node_modules/character-entities-legacy/index.json"(e, r3) {
          r3.exports = { AElig: "\xC6", AMP: "&", Aacute: "\xC1", Acirc: "\xC2", Agrave: "\xC0", Aring: "\xC5", Atilde: "\xC3", Auml: "\xC4", COPY: "\xA9", Ccedil: "\xC7", ETH: "\xD0", Eacute: "\xC9", Ecirc: "\xCA", Egrave: "\xC8", Euml: "\xCB", GT: ">", Iacute: "\xCD", Icirc: "\xCE", Igrave: "\xCC", Iuml: "\xCF", LT: "<", Ntilde: "\xD1", Oacute: "\xD3", Ocirc: "\xD4", Ograve: "\xD2", Oslash: "\xD8", Otilde: "\xD5", Ouml: "\xD6", QUOT: '"', REG: "\xAE", THORN: "\xDE", Uacute: "\xDA", Ucirc: "\xDB", Ugrave: "\xD9", Uuml: "\xDC", Yacute: "\xDD", aacute: "\xE1", acirc: "\xE2", acute: "\xB4", aelig: "\xE6", agrave: "\xE0", amp: "&", aring: "\xE5", atilde: "\xE3", auml: "\xE4", brvbar: "\xA6", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", eacute: "\xE9", ecirc: "\xEA", egrave: "\xE8", eth: "\xF0", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", iacute: "\xED", icirc: "\xEE", iexcl: "\xA1", igrave: "\xEC", iquest: "\xBF", iuml: "\xEF", laquo: "\xAB", lt: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", ntilde: "\xF1", oacute: "\xF3", ocirc: "\xF4", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", oslash: "\xF8", otilde: "\xF5", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', raquo: "\xBB", reg: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", thorn: "\xFE", times: "\xD7", uacute: "\xFA", ucirc: "\xFB", ugrave: "\xF9", uml: "\xA8", uuml: "\xFC", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
        } }), Gl = S({ "node_modules/character-reference-invalid/index.json"(e, r3) {
          r3.exports = { 0: "\uFFFD", 128: "\u20AC", 130: "\u201A", 131: "\u0192", 132: "\u201E", 133: "\u2026", 134: "\u2020", 135: "\u2021", 136: "\u02C6", 137: "\u2030", 138: "\u0160", 139: "\u2039", 140: "\u0152", 142: "\u017D", 145: "\u2018", 146: "\u2019", 147: "\u201C", 148: "\u201D", 149: "\u2022", 150: "\u2013", 151: "\u2014", 152: "\u02DC", 153: "\u2122", 154: "\u0161", 155: "\u203A", 156: "\u0153", 158: "\u017E", 159: "\u0178" };
        } }), Me = S({ "node_modules/is-decimal/index.js"(e, r3) {
          I(), r3.exports = u;
          function u(t) {
            var a = typeof t == "string" ? t.charCodeAt(0) : t;
            return a >= 48 && a <= 57;
          }
        } }), Vl = S({ "node_modules/is-hexadecimal/index.js"(e, r3) {
          I(), r3.exports = u;
          function u(t) {
            var a = typeof t == "string" ? t.charCodeAt(0) : t;
            return a >= 97 && a <= 102 || a >= 65 && a <= 70 || a >= 48 && a <= 57;
          }
        } }), er = S({ "node_modules/is-alphabetical/index.js"(e, r3) {
          I(), r3.exports = u;
          function u(t) {
            var a = typeof t == "string" ? t.charCodeAt(0) : t;
            return a >= 97 && a <= 122 || a >= 65 && a <= 90;
          }
        } }), Hl = S({ "node_modules/is-alphanumerical/index.js"(e, r3) {
          I();
          var u = er(), t = Me();
          r3.exports = a;
          function a(n) {
            return u(n) || t(n);
          }
        } }), Xl = S({ "node_modules/character-entities/index.json"(e, r3) {
          r3.exports = { AEli: "\xC6", AElig: "\xC6", AM: "&", AMP: "&", Aacut: "\xC1", Aacute: "\xC1", Abreve: "\u0102", Acir: "\xC2", Acirc: "\xC2", Acy: "\u0410", Afr: "\u{1D504}", Agrav: "\xC0", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\u{1D538}", ApplyFunction: "\u2061", Arin: "\xC5", Aring: "\xC5", Ascr: "\u{1D49C}", Assign: "\u2254", Atild: "\xC3", Atilde: "\xC3", Aum: "\xC4", Auml: "\xC4", Backslash: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", Bcy: "\u0411", Because: "\u2235", Bernoullis: "\u212C", Beta: "\u0392", Bfr: "\u{1D505}", Bopf: "\u{1D539}", Breve: "\u02D8", Bscr: "\u212C", Bumpeq: "\u224E", CHcy: "\u0427", COP: "\xA9", COPY: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", Cayleys: "\u212D", Ccaron: "\u010C", Ccedi: "\xC7", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", CenterDot: "\xB7", Cfr: "\u212D", Chi: "\u03A7", CircleDot: "\u2299", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", Colon: "\u2237", Colone: "\u2A74", Congruent: "\u2261", Conint: "\u222F", ContourIntegral: "\u222E", Copf: "\u2102", Coproduct: "\u2210", CounterClockwiseContourIntegral: "\u2233", Cross: "\u2A2F", Cscr: "\u{1D49E}", Cup: "\u22D3", CupCap: "\u224D", DD: "\u2145", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", Delta: "\u0394", Dfr: "\u{1D507}", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", Diamond: "\u22C4", DifferentialD: "\u2146", Dopf: "\u{1D53B}", Dot: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", Downarrow: "\u21D3", Dscr: "\u{1D49F}", Dstrok: "\u0110", ENG: "\u014A", ET: "\xD0", ETH: "\xD0", Eacut: "\xC9", Eacute: "\xC9", Ecaron: "\u011A", Ecir: "\xCA", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\u{1D508}", Egrav: "\xC8", Egrave: "\xC8", Element: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\u{1D53C}", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", Equilibrium: "\u21CC", Escr: "\u2130", Esim: "\u2A73", Eta: "\u0397", Eum: "\xCB", Euml: "\xCB", Exists: "\u2203", ExponentialE: "\u2147", Fcy: "\u0424", Ffr: "\u{1D509}", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", Fopf: "\u{1D53D}", ForAll: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", G: ">", GT: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\u{1D50A}", Gg: "\u22D9", Gopf: "\u{1D53E}", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", Gt: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", HilbertSpace: "\u210B", Hopf: "\u210D", HorizontalLine: "\u2500", Hscr: "\u210B", Hstrok: "\u0126", HumpDownHump: "\u224E", HumpEqual: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacut: "\xCD", Iacute: "\xCD", Icir: "\xCE", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Igrav: "\xCC", Igrave: "\xCC", Im: "\u2111", Imacr: "\u012A", ImaginaryI: "\u2148", Implies: "\u21D2", Int: "\u222C", Integral: "\u222B", Intersection: "\u22C2", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", Iogon: "\u012E", Iopf: "\u{1D540}", Iota: "\u0399", Iscr: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Ium: "\xCF", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\u{1D50D}", Jopf: "\u{1D541}", Jscr: "\u{1D4A5}", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\u{1D50E}", Kopf: "\u{1D542}", Kscr: "\u{1D4A6}", LJcy: "\u0409", L: "<", LT: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Larr: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", LeftRightArrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", Leftarrow: "\u21D0", Leftrightarrow: "\u21D4", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", Lfr: "\u{1D50F}", Ll: "\u22D8", Lleftarrow: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", LongLeftRightArrow: "\u27F7", LongRightArrow: "\u27F6", Longleftarrow: "\u27F8", Longleftrightarrow: "\u27FA", Longrightarrow: "\u27F9", Lopf: "\u{1D543}", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", Lscr: "\u2112", Lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", MinusPlus: "\u2213", Mopf: "\u{1D544}", Mscr: "\u2133", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, Nfr: "\u{1D511}", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", Nscr: "\u{1D4A9}", Ntild: "\xD1", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacut: "\xD3", Oacute: "\xD3", Ocir: "\xD4", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\u{1D512}", Ograv: "\xD2", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", Omicron: "\u039F", Oopf: "\u{1D546}", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", Or: "\u2A54", Oscr: "\u{1D4AA}", Oslas: "\xD8", Oslash: "\xD8", Otild: "\xD5", Otilde: "\xD5", Otimes: "\u2A37", Oum: "\xD6", Ouml: "\xD6", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", Pcy: "\u041F", Pfr: "\u{1D513}", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", Poincareplane: "\u210C", Popf: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", Prime: "\u2033", Product: "\u220F", Proportion: "\u2237", Proportional: "\u221D", Pscr: "\u{1D4AB}", Psi: "\u03A8", QUO: '"', QUOT: '"', Qfr: "\u{1D514}", Qopf: "\u211A", Qscr: "\u{1D4AC}", RBarr: "\u2910", RE: "\xAE", REG: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", Rfr: "\u211C", Rho: "\u03A1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", Rightarrow: "\u21D2", Ropf: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", Rscr: "\u211B", Rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\u{1D516}", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", Sopf: "\u{1D54A}", Sqrt: "\u221A", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", Sscr: "\u{1D4AE}", Star: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", SuchThat: "\u220B", Sum: "\u2211", Sup: "\u22D1", Superset: "\u2283", SupersetEqual: "\u2287", Supset: "\u22D1", THOR: "\xDE", THORN: "\xDE", TRADE: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "	", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\u{1D517}", Therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", Topf: "\u{1D54B}", TripleDot: "\u20DB", Tscr: "\u{1D4AF}", Tstrok: "\u0166", Uacut: "\xDA", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucir: "\xDB", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\u{1D518}", Ugrav: "\xD9", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", Uopf: "\u{1D54C}", UpArrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", UpEquilibrium: "\u296E", UpTee: "\u22A5", UpTeeArrow: "\u21A5", Uparrow: "\u21D1", Updownarrow: "\u21D5", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\u{1D4B0}", Utilde: "\u0168", Uum: "\xDC", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", Vopf: "\u{1D54D}", Vscr: "\u{1D4B1}", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", Wfr: "\u{1D51A}", Wopf: "\u{1D54E}", Wscr: "\u{1D4B2}", Xfr: "\u{1D51B}", Xi: "\u039E", Xopf: "\u{1D54F}", Xscr: "\u{1D4B3}", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacut: "\xDD", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\u{1D51C}", Yopf: "\u{1D550}", Yscr: "\u{1D4B4}", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", ZeroWidthSpace: "\u200B", Zeta: "\u0396", Zfr: "\u2128", Zopf: "\u2124", Zscr: "\u{1D4B5}", aacut: "\xE1", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acir: "\xE2", acirc: "\xE2", acut: "\xB4", acute: "\xB4", acy: "\u0430", aeli: "\xE6", aelig: "\xE6", af: "\u2061", afr: "\u{1D51E}", agrav: "\xE0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", am: "&", amp: "&", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", aogon: "\u0105", aopf: "\u{1D552}", ap: "\u2248", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", apid: "\u224B", apos: "'", approx: "\u2248", approxeq: "\u224A", arin: "\xE5", aring: "\xE5", ascr: "\u{1D4B6}", ast: "*", asymp: "\u2248", asympeq: "\u224D", atild: "\xE3", atilde: "\xE3", aum: "\xE4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", beta: "\u03B2", beth: "\u2136", between: "\u226C", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxh: "\u2500", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", bprime: "\u2035", breve: "\u02D8", brvba: "\xA6", brvbar: "\xA6", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", bumpeq: "\u224F", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", ccaps: "\u2A4D", ccaron: "\u010D", ccedi: "\xE7", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cedi: "\xB8", cedil: "\xB8", cemptyv: "\u29B2", cen: "\xA2", cent: "\xA2", centerdot: "\xB7", cfr: "\u{1D520}", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledR: "\xAE", circledS: "\u24C8", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", conint: "\u222E", copf: "\u{1D554}", coprod: "\u2210", cop: "\xA9", copy: "\xA9", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curre: "\xA4", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dArr: "\u21D3", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", darr: "\u2193", dash: "\u2010", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", dcaron: "\u010F", dcy: "\u0434", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", ddotseq: "\u2A77", de: "\xB0", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\u{1D521}", dharl: "\u21C3", dharr: "\u21C2", diam: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divid: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\u{1D555}", dot: "\u02D9", doteq: "\u2250", doteqdot: "\u2251", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", downarrow: "\u2193", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", dscr: "\u{1D4B9}", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eDDot: "\u2A77", eDot: "\u2251", eacut: "\xE9", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\xEA", ecirc: "\xEA", ecolon: "\u2255", ecy: "\u044D", edot: "\u0117", ee: "\u2147", efDot: "\u2252", efr: "\u{1D522}", eg: "\u2A9A", egrav: "\xE8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", equals: "=", equest: "\u225F", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", erarr: "\u2971", escr: "\u212F", esdot: "\u2250", esim: "\u2242", eta: "\u03B7", et: "\xF0", eth: "\xF0", eum: "\xEB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", expectation: "\u2130", exponentiale: "\u2147", fallingdotseq: "\u2252", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\u{1D523}", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\u{1D557}", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac1: "\xBC", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac3: "\xBE", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", gE: "\u2267", gEl: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gammad: "\u03DD", gap: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", ge: "\u2265", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\u{1D524}", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", gjcy: "\u0453", gl: "\u2277", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", gopf: "\u{1D558}", grave: "`", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", g: ">", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hArr: "\u21D4", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", hardcy: "\u044A", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", hbar: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", horbar: "\u2015", hscr: "\u{1D4BD}", hslash: "\u210F", hstrok: "\u0127", hybull: "\u2043", hyphen: "\u2010", iacut: "\xED", iacute: "\xED", ic: "\u2063", icir: "\xEE", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexc: "\xA1", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", igrav: "\xEC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", image: "\u2111", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", int: "\u222B", intcal: "\u22BA", integers: "\u2124", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\u{1D55A}", iota: "\u03B9", iprod: "\u2A3C", iques: "\xBF", iquest: "\xBF", iscr: "\u{1D4BE}", isin: "\u2208", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", itilde: "\u0129", iukcy: "\u0456", ium: "\xEF", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\u{1D527}", jmath: "\u0237", jopf: "\u{1D55B}", jscr: "\u{1D4BF}", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\u{1D528}", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\u{1D55C}", kscr: "\u{1D4C0}", lAarr: "\u21DA", lArr: "\u21D0", lAtail: "\u291B", lBarr: "\u290E", lE: "\u2266", lEg: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", lambda: "\u03BB", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", laqu: "\xAB", laquo: "\xAB", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lceil: "\u2308", lcub: "{", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leftarrow: "\u2190", leftarrowtail: "\u21A2", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", leftthreetimes: "\u22CB", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", lessgtr: "\u2276", lesssim: "\u2272", lfisht: "\u297C", lfloor: "\u230A", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", lstrok: "\u0142", l: "<", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", mac: "\xAF", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", measuredangle: "\u2221", mfr: "\u{1D52A}", mho: "\u2127", micr: "\xB5", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middo: "\xB7", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", mstpos: "\u223E", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nGtv: "\u226B\u0338", nLeftarrow: "\u21CD", nLeftrightarrow: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nLtv: "\u226A\u0338", nRightarrow: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nabla: "\u2207", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbs: "\xA0", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", neArr: "\u21D7", nearhk: "\u2924", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", nexist: "\u2204", nexists: "\u2204", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", ngsim: "\u2275", ngt: "\u226F", ngtr: "\u226F", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", njcy: "\u045A", nlArr: "\u21CD", nlE: "\u2266\u0338", nlarr: "\u219A", nldr: "\u2025", nle: "\u2270", nleftarrow: "\u219A", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nlsim: "\u2274", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nmid: "\u2224", nopf: "\u{1D55F}", no: "\xAC", not: "\xAC", notin: "\u2209", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", ntild: "\xF1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", oS: "\u24C8", oacut: "\xF3", oacute: "\xF3", oast: "\u229B", ocir: "\xF4", ocirc: "\xF4", ocy: "\u043E", odash: "\u229D", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\u{1D52C}", ogon: "\u02DB", ograv: "\xF2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", oopf: "\u{1D560}", opar: "\u29B7", operp: "\u29B9", oplus: "\u2295", or: "\u2228", orarr: "\u21BB", ord: "\xBA", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oscr: "\u2134", oslas: "\xF8", oslash: "\xF8", osol: "\u2298", otild: "\xF5", otilde: "\xF5", otimes: "\u2297", otimesas: "\u2A36", oum: "\xF6", ouml: "\xF6", ovbar: "\u233D", par: "\xB6", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", pfr: "\u{1D52D}", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", plusm: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", pointint: "\u2A15", popf: "\u{1D561}", poun: "\xA3", pound: "\xA3", pr: "\u227A", prE: "\u2AB3", prap: "\u2AB7", prcue: "\u227C", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", prime: "\u2032", primes: "\u2119", prnE: "\u2AB5", prnap: "\u2AB9", prnsim: "\u22E8", prod: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", pscr: "\u{1D4C5}", psi: "\u03C8", puncsp: "\u2008", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", qprime: "\u2057", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quo: '"', quot: '"', rAarr: "\u21DB", rArr: "\u21D2", rAtail: "\u291C", rBarr: "\u290F", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raqu: "\xBB", raquo: "\xBB", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rceil: "\u2309", rcub: "}", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", re: "\xAE", reg: "\xAE", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", rightarrow: "\u2192", rightarrowtail: "\u21A3", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", rightthreetimes: "\u22CC", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", rsaquo: "\u203A", rscr: "\u{1D4C7}", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", sbquo: "\u201A", sc: "\u227B", scE: "\u2AB4", scap: "\u2AB8", scaron: "\u0161", sccue: "\u227D", sce: "\u2AB0", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", scnap: "\u2ABA", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", seArr: "\u21D8", searhk: "\u2925", searr: "\u2198", searrow: "\u2198", sec: "\xA7", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shortmid: "\u2223", shortparallel: "\u2225", sh: "\xAD", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", square: "\u25A1", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", subE: "\u2AC5", subdot: "\u2ABD", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", sum: "\u2211", sung: "\u266A", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supE: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supe: "\u2287", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swarhk: "\u2926", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szli: "\xDF", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tbrk: "\u23B4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", thor: "\xFE", thorn: "\xFE", tilde: "\u02DC", time: "\xD7", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\u{1D4C9}", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", uArr: "\u21D1", uHar: "\u2963", uacut: "\xFA", uacute: "\xFA", uarr: "\u2191", ubrcy: "\u045E", ubreve: "\u016D", ucir: "\xFB", ucirc: "\xFB", ucy: "\u0443", udarr: "\u21C5", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", ufr: "\u{1D532}", ugrav: "\xF9", ugrave: "\xF9", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", um: "\xA8", uml: "\xA8", uogon: "\u0173", uopf: "\u{1D566}", uparrow: "\u2191", updownarrow: "\u2195", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", upsi: "\u03C5", upsih: "\u03D2", upsilon: "\u03C5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\u{1D4CA}", utdot: "\u22F0", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", uum: "\xFC", uuml: "\xFC", uwangle: "\u29A7", vArr: "\u21D5", vBar: "\u2AE8", vBarv: "\u2AE9", vDash: "\u22A8", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vcy: "\u0432", vdash: "\u22A2", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", vert: "|", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", wfr: "\u{1D534}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", yacut: "\xFD", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", ye: "\xA5", yen: "\xA5", yfr: "\u{1D536}", yicy: "\u0457", yopf: "\u{1D56A}", yscr: "\u{1D4CE}", yucy: "\u044E", yum: "\xFF", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeetrf: "\u2128", zeta: "\u03B6", zfr: "\u{1D537}", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
        } }), Wl = S({ "node_modules/parse-entities/decode-entity.js"(e, r3) {
          I();
          var u = Xl();
          r3.exports = a;
          var t = {}.hasOwnProperty;
          function a(n) {
            return t.call(u, n) ? u[n] : false;
          }
        } }), xr = S({ "node_modules/parse-entities/index.js"(e, r3) {
          I();
          var u = Ul(), t = Gl(), a = Me(), n = Vl(), s = Hl(), c3 = Wl();
          r3.exports = J;
          var i = {}.hasOwnProperty, D = String.fromCharCode, o = Function.prototype, l = { warning: null, reference: null, text: null, warningContext: null, referenceContext: null, textContext: null, position: {}, additional: null, attribute: false, nonTerminated: true }, d = 9, p = 10, g = 12, F = 32, E = 38, b = 59, f = 60, x = 61, v = 35, h = 88, m = 120, C = 65533, w = "named", q = "hexadecimal", L = "decimal", B = {};
          B[q] = 16, B[L] = 10;
          var O = {};
          O[w] = s, O[L] = a, O[q] = n;
          var T = 1, P = 2, A = 3, j = 4, H = 5, G = 6, X = 7, R = {};
          R[T] = "Named character references must be terminated by a semicolon", R[P] = "Numeric character references must be terminated by a semicolon", R[A] = "Named character references cannot be empty", R[j] = "Numeric character references cannot be empty", R[H] = "Named character references must be known", R[G] = "Numeric character references cannot be disallowed", R[X] = "Numeric character references cannot be outside the permissible Unicode range";
          function J(k, y) {
            var _ = {}, N, V;
            y || (y = {});
            for (V in l) N = y[V], _[V] = N == null ? l[V] : N;
            return (_.position.indent || _.position.start) && (_.indent = _.position.indent || [], _.position = _.position.start), z(k, _);
          }
          function z(k, y) {
            var _ = y.additional, N = y.nonTerminated, V = y.text, W = y.reference, K = y.warning, ee = y.textContext, Y = y.referenceContext, ue = y.warningContext, le = y.position, ce = y.indent || [], te = k.length, Z = 0, Q = -1, De = le.column || 1, ye = le.line || 1, fe = "", he = [], ae, pe, ne, re, we, oe, ie, Ce, rr, br, qe, $e, _e, xe, Fu, Ue, ur, ge, se;
            for (typeof _ == "string" && (_ = _.charCodeAt(0)), Ue = Ge(), Ce = K ? Da : o, Z--, te++; ++Z < te; ) if (we === p && (De = ce[Q] || 1), we = k.charCodeAt(Z), we === E) {
              if (ie = k.charCodeAt(Z + 1), ie === d || ie === p || ie === g || ie === F || ie === E || ie === f || ie !== ie || _ && ie === _) {
                fe += D(we), De++;
                continue;
              }
              for (_e = Z + 1, $e = _e, se = _e, ie === v ? (se = ++$e, ie = k.charCodeAt(se), ie === h || ie === m ? (xe = q, se = ++$e) : xe = L) : xe = w, ae = "", qe = "", re = "", Fu = O[xe], se--; ++se < te && (ie = k.charCodeAt(se), !!Fu(ie)); ) re += D(ie), xe === w && i.call(u, re) && (ae = re, qe = u[re]);
              ne = k.charCodeAt(se) === b, ne && (se++, pe = xe === w ? c3(re) : false, pe && (ae = re, qe = pe)), ge = 1 + se - _e, !ne && !N || (re ? xe === w ? (ne && !qe ? Ce(H, 1) : (ae !== re && (se = $e + ae.length, ge = 1 + se - $e, ne = false), ne || (rr = ae ? T : A, y.attribute ? (ie = k.charCodeAt(se), ie === x ? (Ce(rr, ge), qe = null) : s(ie) ? qe = null : Ce(rr, ge)) : Ce(rr, ge))), oe = qe) : (ne || Ce(P, ge), oe = parseInt(re, B[xe]), M(oe) ? (Ce(X, ge), oe = D(C)) : oe in t ? (Ce(G, ge), oe = t[oe]) : (br = "", U(oe) && Ce(G, ge), oe > 65535 && (oe -= 65536, br += D(oe >>> 10 | 55296), oe = 56320 | oe & 1023), oe = br + D(oe))) : xe !== w && Ce(j, ge)), oe ? (Au(), Ue = Ge(), Z = se - 1, De += se - _e + 1, he.push(oe), ur = Ge(), ur.offset++, W && W.call(Y, oe, { start: Ue, end: ur }, k.slice(_e - 1, se)), Ue = ur) : (re = k.slice(_e - 1, se), fe += re, De += re.length, Z = se - 1);
            } else we === 10 && (ye++, Q++, De = 0), we === we ? (fe += D(we), De++) : Au();
            return he.join("");
            function Ge() {
              return { line: ye, column: De, offset: Z + (le.offset || 0) };
            }
            function Da(xu, bu) {
              var yr = Ge();
              yr.column += bu, yr.offset += bu, K.call(ue, R[xu], yr, xu);
            }
            function Au() {
              fe && (he.push(fe), V && V.call(ee, fe, { start: Ue, end: Ge() }), fe = "");
            }
          }
          function M(k) {
            return k >= 55296 && k <= 57343 || k > 1114111;
          }
          function U(k) {
            return k >= 1 && k <= 8 || k === 11 || k >= 13 && k <= 31 || k >= 127 && k <= 159 || k >= 64976 && k <= 65007 || (k & 65535) === 65535 || (k & 65535) === 65534;
          }
        } }), Kl = S({ "node_modules/remark-parse/lib/decode.js"(e, r3) {
          I();
          var u = Pe(), t = xr();
          r3.exports = a;
          function a(n) {
            return c3.raw = i, c3;
            function s(o) {
              for (var l = n.offset, d = o.line, p = []; ++d && d in l; ) p.push((l[d] || 0) + 1);
              return { start: o, indent: p };
            }
            function c3(o, l, d) {
              t(o, { position: s(l), warning: D, text: d, reference: d, textContext: n, referenceContext: n });
            }
            function i(o, l, d) {
              return t(o, u(d, { position: s(l), warning: D }));
            }
            function D(o, l, d) {
              d !== 3 && n.file.message(o, l);
            }
          }
        } }), Yl = S({ "node_modules/remark-parse/lib/tokenizer.js"(e, r3) {
          I(), r3.exports = u;
          function u(s) {
            return c3;
            function c3(i, D) {
              var o = this, l = o.offset, d = [], p = o[s + "Methods"], g = o[s + "Tokenizers"], F = D.line, E = D.column, b, f, x, v, h, m;
              if (!i) return d;
              for (P.now = q, P.file = o.file, C(""); i; ) {
                for (b = -1, f = p.length, h = false; ++b < f && (v = p[b], x = g[v], !(x && (!x.onlyAtStart || o.atStart) && (!x.notInList || !o.inList) && (!x.notInBlock || !o.inBlock) && (!x.notInLink || !o.inLink) && (m = i.length, x.apply(o, [P, i]), h = m !== i.length, h))); ) ;
                h || o.file.fail(new Error("Infinite loop"), P.now());
              }
              return o.eof = q(), d;
              function C(A) {
                for (var j = -1, H = A.indexOf(`
`); H !== -1; ) F++, j = H, H = A.indexOf(`
`, H + 1);
                j === -1 ? E += A.length : E = A.length - j, F in l && (j !== -1 ? E += l[F] : E <= l[F] && (E = l[F] + 1));
              }
              function w() {
                var A = [], j = F + 1;
                return function() {
                  for (var H = F + 1; j < H; ) A.push((l[j] || 0) + 1), j++;
                  return A;
                };
              }
              function q() {
                var A = { line: F, column: E };
                return A.offset = o.toOffset(A), A;
              }
              function L(A) {
                this.start = A, this.end = q();
              }
              function B(A) {
                i.slice(0, A.length) !== A && o.file.fail(new Error("Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"), q());
              }
              function O() {
                var A = q();
                return j;
                function j(H, G) {
                  var X = H.position, R = X ? X.start : A, J = [], z = X && X.end.line, M = A.line;
                  if (H.position = new L(R), X && G && X.indent) {
                    if (J = X.indent, z < M) {
                      for (; ++z < M; ) J.push((l[z] || 0) + 1);
                      J.push(A.column);
                    }
                    G = J.concat(G);
                  }
                  return H.position.indent = G || [], H;
                }
              }
              function T(A, j) {
                var H = j ? j.children : d, G = H[H.length - 1], X;
                return G && A.type === G.type && (A.type === "text" || A.type === "blockquote") && t(G) && t(A) && (X = A.type === "text" ? a : n, A = X.call(o, G, A)), A !== G && H.push(A), o.atStart && d.length !== 0 && o.exitStart(), A;
              }
              function P(A) {
                var j = w(), H = O(), G = q();
                return B(A), X.reset = R, R.test = J, X.test = J, i = i.slice(A.length), C(A), j = j(), X;
                function X(z, M) {
                  return H(T(H(z), M), j);
                }
                function R() {
                  var z = X.apply(null, arguments);
                  return F = G.line, E = G.column, i = A + i, z;
                }
                function J() {
                  var z = H({});
                  return F = G.line, E = G.column, i = A + i, z.position;
                }
              }
            }
          }
          function t(s) {
            var c3, i;
            return s.type !== "text" || !s.position ? true : (c3 = s.position.start, i = s.position.end, c3.line !== i.line || i.column - c3.column === s.value.length);
          }
          function a(s, c3) {
            return s.value += c3.value, s;
          }
          function n(s, c3) {
            return this.options.commonmark || this.options.gfm ? c3 : (s.children = s.children.concat(c3.children), s);
          }
        } }), Jl = S({ "node_modules/markdown-escapes/index.js"(e, r3) {
          I(), r3.exports = n;
          var u = ["\\", "`", "*", "{", "}", "[", "]", "(", ")", "#", "+", "-", ".", "!", "_", ">"], t = u.concat(["~", "|"]), a = t.concat([`
`, '"', "$", "%", "&", "'", ",", "/", ":", ";", "<", "=", "?", "@", "^"]);
          n.default = u, n.gfm = t, n.commonmark = a;
          function n(s) {
            var c3 = s || {};
            return c3.commonmark ? a : c3.gfm ? t : u;
          }
        } }), Zl = S({ "node_modules/remark-parse/lib/block-elements.js"(e, r3) {
          I(), r3.exports = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "meta", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "pre", "section", "source", "title", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"];
        } }), $i = S({ "node_modules/remark-parse/lib/defaults.js"(e, r3) {
          I(), r3.exports = { position: true, gfm: true, commonmark: false, pedantic: false, blocks: Zl() };
        } }), Ql = S({ "node_modules/remark-parse/lib/set-options.js"(e, r3) {
          I();
          var u = Pe(), t = Jl(), a = $i();
          r3.exports = n;
          function n(s) {
            var c3 = this, i = c3.options, D, o;
            if (s == null) s = {};
            else if (typeof s == "object") s = u(s);
            else throw new Error("Invalid value `" + s + "` for setting `options`");
            for (D in a) {
              if (o = s[D], o == null && (o = i[D]), D !== "blocks" && typeof o != "boolean" || D === "blocks" && typeof o != "object") throw new Error("Invalid value `" + o + "` for setting `options." + D + "`");
              s[D] = o;
            }
            return c3.options = s, c3.escape = t(s), c3;
          }
        } }), eD = S({ "node_modules/unist-util-is/convert.js"(e, r3) {
          I(), r3.exports = u;
          function u(c3) {
            if (c3 == null) return s;
            if (typeof c3 == "string") return n(c3);
            if (typeof c3 == "object") return "length" in c3 ? a(c3) : t(c3);
            if (typeof c3 == "function") return c3;
            throw new Error("Expected function, string, or object as test");
          }
          function t(c3) {
            return i;
            function i(D) {
              var o;
              for (o in c3) if (D[o] !== c3[o]) return false;
              return true;
            }
          }
          function a(c3) {
            for (var i = [], D = -1; ++D < c3.length; ) i[D] = u(c3[D]);
            return o;
            function o() {
              for (var l = -1; ++l < i.length; ) if (i[l].apply(this, arguments)) return true;
              return false;
            }
          }
          function n(c3) {
            return i;
            function i(D) {
              return Boolean(D && D.type === c3);
            }
          }
          function s() {
            return true;
          }
        } }), rD = S({ "node_modules/unist-util-visit-parents/color.browser.js"(e, r3) {
          I(), r3.exports = u;
          function u(t) {
            return t;
          }
        } }), uD = S({ "node_modules/unist-util-visit-parents/index.js"(e, r3) {
          I(), r3.exports = c3;
          var u = eD(), t = rD(), a = true, n = "skip", s = false;
          c3.CONTINUE = a, c3.SKIP = n, c3.EXIT = s;
          function c3(D, o, l, d) {
            var p, g;
            typeof o == "function" && typeof l != "function" && (d = l, l = o, o = null), g = u(o), p = d ? -1 : 1, F(D, null, [])();
            function F(E, b, f) {
              var x = typeof E == "object" && E !== null ? E : {}, v;
              return typeof x.type == "string" && (v = typeof x.tagName == "string" ? x.tagName : typeof x.name == "string" ? x.name : void 0, h.displayName = "node (" + t(x.type + (v ? "<" + v + ">" : "")) + ")"), h;
              function h() {
                var m = f.concat(E), C = [], w, q;
                if ((!o || g(E, b, f[f.length - 1] || null)) && (C = i(l(E, f)), C[0] === s)) return C;
                if (E.children && C[0] !== n) for (q = (d ? E.children.length : -1) + p; q > -1 && q < E.children.length; ) {
                  if (w = F(E.children[q], q, m)(), w[0] === s) return w;
                  q = typeof w[1] == "number" ? w[1] : q + p;
                }
                return C;
              }
            }
          }
          function i(D) {
            return D !== null && typeof D == "object" && "length" in D ? D : typeof D == "number" ? [a, D] : [D];
          }
        } }), tD = S({ "node_modules/unist-util-visit/index.js"(e, r3) {
          I(), r3.exports = s;
          var u = uD(), t = u.CONTINUE, a = u.SKIP, n = u.EXIT;
          s.CONTINUE = t, s.SKIP = a, s.EXIT = n;
          function s(c3, i, D, o) {
            typeof i == "function" && typeof D != "function" && (o = D, D = i, i = null), u(c3, i, l, o);
            function l(d, p) {
              var g = p[p.length - 1], F = g ? g.children.indexOf(d) : null;
              return D(d, F, g);
            }
          }
        } }), nD = S({ "node_modules/unist-util-remove-position/index.js"(e, r3) {
          I();
          var u = tD();
          r3.exports = t;
          function t(s, c3) {
            return u(s, c3 ? a : n), s;
          }
          function a(s) {
            delete s.position;
          }
          function n(s) {
            s.position = void 0;
          }
        } }), iD = S({ "node_modules/remark-parse/lib/parse.js"(e, r3) {
          I();
          var u = Pe(), t = nD();
          r3.exports = s;
          var a = `
`, n = /\r\n|\r/g;
          function s() {
            var c3 = this, i = String(c3.file), D = { line: 1, column: 1, offset: 0 }, o = u(D), l;
            return i = i.replace(n, a), i.charCodeAt(0) === 65279 && (i = i.slice(1), o.column++, o.offset++), l = { type: "root", children: c3.tokenizeBlock(i, o), position: { start: D, end: c3.eof || u(D) } }, c3.options.position || t(l, true), l;
          }
        } }), aD = S({ "node_modules/remark-parse/lib/tokenize/blank-line.js"(e, r3) {
          I();
          var u = /^[ \t]*(\n|$)/;
          r3.exports = t;
          function t(a, n, s) {
            for (var c3, i = "", D = 0, o = n.length; D < o && (c3 = u.exec(n.slice(D)), c3 != null); ) D += c3[0].length, i += c3[0];
            if (i !== "") {
              if (s) return true;
              a(i);
            }
          }
        } }), mu = S({ "node_modules/repeat-string/index.js"(e, r3) {
          I();
          var u = "", t;
          r3.exports = a;
          function a(n, s) {
            if (typeof n != "string") throw new TypeError("expected a string");
            if (s === 1) return n;
            if (s === 2) return n + n;
            var c3 = n.length * s;
            if (t !== n || typeof t > "u") t = n, u = "";
            else if (u.length >= c3) return u.substr(0, c3);
            for (; c3 > u.length && s > 1; ) s & 1 && (u += n), s >>= 1, n += n;
            return u += n, u = u.substr(0, c3), u;
          }
        } }), Ui = S({ "node_modules/trim-trailing-lines/index.js"(e, r3) {
          I(), r3.exports = u;
          function u(t) {
            return String(t).replace(/\n+$/, "");
          }
        } }), oD = S({ "node_modules/remark-parse/lib/tokenize/code-indented.js"(e, r3) {
          I();
          var u = mu(), t = Ui();
          r3.exports = D;
          var a = `
`, n = "	", s = " ", c3 = 4, i = u(s, c3);
          function D(o, l, d) {
            for (var p = -1, g = l.length, F = "", E = "", b = "", f = "", x, v, h; ++p < g; ) if (x = l.charAt(p), h) if (h = false, F += b, E += f, b = "", f = "", x === a) b = x, f = x;
            else for (F += x, E += x; ++p < g; ) {
              if (x = l.charAt(p), !x || x === a) {
                f = x, b = x;
                break;
              }
              F += x, E += x;
            }
            else if (x === s && l.charAt(p + 1) === x && l.charAt(p + 2) === x && l.charAt(p + 3) === x) b += i, p += 3, h = true;
            else if (x === n) b += x, h = true;
            else {
              for (v = ""; x === n || x === s; ) v += x, x = l.charAt(++p);
              if (x !== a) break;
              b += v + x, f += x;
            }
            if (E) return d ? true : o(F)({ type: "code", lang: null, meta: null, value: t(E) });
          }
        } }), sD = S({ "node_modules/remark-parse/lib/tokenize/code-fenced.js"(e, r3) {
          I(), r3.exports = D;
          var u = `
`, t = "	", a = " ", n = "~", s = "`", c3 = 3, i = 4;
          function D(o, l, d) {
            var p = this, g = p.options.gfm, F = l.length + 1, E = 0, b = "", f, x, v, h, m, C, w, q, L, B, O, T, P;
            if (g) {
              for (; E < F && (v = l.charAt(E), !(v !== a && v !== t)); ) b += v, E++;
              if (T = E, v = l.charAt(E), !(v !== n && v !== s)) {
                for (E++, x = v, f = 1, b += v; E < F && (v = l.charAt(E), v === x); ) b += v, f++, E++;
                if (!(f < c3)) {
                  for (; E < F && (v = l.charAt(E), !(v !== a && v !== t)); ) b += v, E++;
                  for (h = "", w = ""; E < F && (v = l.charAt(E), !(v === u || x === s && v === x)); ) v === a || v === t ? w += v : (h += w + v, w = ""), E++;
                  if (v = l.charAt(E), !(v && v !== u)) {
                    if (d) return true;
                    P = o.now(), P.column += b.length, P.offset += b.length, b += h, h = p.decode.raw(p.unescape(h), P), w && (b += w), w = "", B = "", O = "", q = "", L = "";
                    for (var A = true; E < F; ) {
                      if (v = l.charAt(E), q += B, L += O, B = "", O = "", v !== u) {
                        q += v, O += v, E++;
                        continue;
                      }
                      for (A ? (b += v, A = false) : (B += v, O += v), w = "", E++; E < F && (v = l.charAt(E), v === a); ) w += v, E++;
                      if (B += w, O += w.slice(T), !(w.length >= i)) {
                        for (w = ""; E < F && (v = l.charAt(E), v === x); ) w += v, E++;
                        if (B += w, O += w, !(w.length < f)) {
                          for (w = ""; E < F && (v = l.charAt(E), !(v !== a && v !== t)); ) B += v, O += v, E++;
                          if (!v || v === u) break;
                        }
                      }
                    }
                    for (b += q + B, E = -1, F = h.length; ++E < F; ) if (v = h.charAt(E), v === a || v === t) m || (m = h.slice(0, E));
                    else if (m) {
                      C = h.slice(E);
                      break;
                    }
                    return o(b)({ type: "code", lang: m || h || null, meta: C || null, value: L });
                  }
                }
              }
            }
          }
        } }), ze = S({ "node_modules/trim/index.js"(e, r3) {
          I(), e = r3.exports = u;
          function u(t) {
            return t.replace(/^\s*|\s*$/g, "");
          }
          e.left = function(t) {
            return t.replace(/^\s*/, "");
          }, e.right = function(t) {
            return t.replace(/\s*$/, "");
          };
        } }), Eu = S({ "node_modules/remark-parse/lib/util/interrupt.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a, n, s) {
            for (var c3 = t.length, i = -1, D, o; ++i < c3; ) if (D = t[i], o = D[1] || {}, !(o.pedantic !== void 0 && o.pedantic !== n.options.pedantic) && !(o.commonmark !== void 0 && o.commonmark !== n.options.commonmark) && a[D[0]].apply(n, s)) return true;
            return false;
          }
        } }), cD = S({ "node_modules/remark-parse/lib/tokenize/blockquote.js"(e, r3) {
          I();
          var u = ze(), t = Eu();
          r3.exports = i;
          var a = `
`, n = "	", s = " ", c3 = ">";
          function i(D, o, l) {
            for (var d = this, p = d.offset, g = d.blockTokenizers, F = d.interruptBlockquote, E = D.now(), b = E.line, f = o.length, x = [], v = [], h = [], m, C = 0, w, q, L, B, O, T, P, A; C < f && (w = o.charAt(C), !(w !== s && w !== n)); ) C++;
            if (o.charAt(C) === c3) {
              if (l) return true;
              for (C = 0; C < f; ) {
                for (L = o.indexOf(a, C), T = C, P = false, L === -1 && (L = f); C < f && (w = o.charAt(C), !(w !== s && w !== n)); ) C++;
                if (o.charAt(C) === c3 ? (C++, P = true, o.charAt(C) === s && C++) : C = T, B = o.slice(C, L), !P && !u(B)) {
                  C = T;
                  break;
                }
                if (!P && (q = o.slice(C), t(F, g, d, [D, q, true]))) break;
                O = T === C ? B : o.slice(T, L), h.push(C - T), x.push(O), v.push(B), C = L + 1;
              }
              for (C = -1, f = h.length, m = D(x.join(a)); ++C < f; ) p[b] = (p[b] || 0) + h[C], b++;
              return A = d.enterBlock(), v = d.tokenizeBlock(v.join(a), E), A(), m({ type: "blockquote", children: v });
            }
          }
        } }), lD = S({ "node_modules/remark-parse/lib/tokenize/heading-atx.js"(e, r3) {
          I(), r3.exports = c3;
          var u = `
`, t = "	", a = " ", n = "#", s = 6;
          function c3(i, D, o) {
            for (var l = this, d = l.options.pedantic, p = D.length + 1, g = -1, F = i.now(), E = "", b = "", f, x, v; ++g < p; ) {
              if (f = D.charAt(g), f !== a && f !== t) {
                g--;
                break;
              }
              E += f;
            }
            for (v = 0; ++g <= p; ) {
              if (f = D.charAt(g), f !== n) {
                g--;
                break;
              }
              E += f, v++;
            }
            if (!(v > s) && !(!v || !d && D.charAt(g + 1) === n)) {
              for (p = D.length + 1, x = ""; ++g < p; ) {
                if (f = D.charAt(g), f !== a && f !== t) {
                  g--;
                  break;
                }
                x += f;
              }
              if (!(!d && x.length === 0 && f && f !== u)) {
                if (o) return true;
                for (E += x, x = "", b = ""; ++g < p && (f = D.charAt(g), !(!f || f === u)); ) {
                  if (f !== a && f !== t && f !== n) {
                    b += x + f, x = "";
                    continue;
                  }
                  for (; f === a || f === t; ) x += f, f = D.charAt(++g);
                  if (!d && b && !x && f === n) {
                    b += f;
                    continue;
                  }
                  for (; f === n; ) x += f, f = D.charAt(++g);
                  for (; f === a || f === t; ) x += f, f = D.charAt(++g);
                  g--;
                }
                return F.column += E.length, F.offset += E.length, E += b + x, i(E)({ type: "heading", depth: v, children: l.tokenizeInline(b, F) });
              }
            }
          }
        } }), DD = S({ "node_modules/remark-parse/lib/tokenize/thematic-break.js"(e, r3) {
          I(), r3.exports = D;
          var u = "	", t = `
`, a = " ", n = "*", s = "-", c3 = "_", i = 3;
          function D(o, l, d) {
            for (var p = -1, g = l.length + 1, F = "", E, b, f, x; ++p < g && (E = l.charAt(p), !(E !== u && E !== a)); ) F += E;
            if (!(E !== n && E !== s && E !== c3)) for (b = E, F += E, f = 1, x = ""; ++p < g; ) if (E = l.charAt(p), E === b) f++, F += x + b, x = "";
            else if (E === a) x += E;
            else return f >= i && (!E || E === t) ? (F += x, d ? true : o(F)({ type: "thematicBreak" })) : void 0;
          }
        } }), Gi = S({ "node_modules/remark-parse/lib/util/get-indentation.js"(e, r3) {
          I(), r3.exports = s;
          var u = "	", t = " ", a = 1, n = 4;
          function s(c3) {
            for (var i = 0, D = 0, o = c3.charAt(i), l = {}, d, p = 0; o === u || o === t; ) {
              for (d = o === u ? n : a, D += d, d > 1 && (D = Math.floor(D / d) * d); p < D; ) l[++p] = i;
              o = c3.charAt(++i);
            }
            return { indent: D, stops: l };
          }
        } }), fD = S({ "node_modules/remark-parse/lib/util/remove-indentation.js"(e, r3) {
          I();
          var u = ze(), t = mu(), a = Gi();
          r3.exports = i;
          var n = `
`, s = " ", c3 = "!";
          function i(D, o) {
            var l = D.split(n), d = l.length + 1, p = 1 / 0, g = [], F, E, b;
            for (l.unshift(t(s, o) + c3); d--; ) if (E = a(l[d]), g[d] = E.stops, u(l[d]).length !== 0) if (E.indent) E.indent > 0 && E.indent < p && (p = E.indent);
            else {
              p = 1 / 0;
              break;
            }
            if (p !== 1 / 0) for (d = l.length; d--; ) {
              for (b = g[d], F = p; F && !(F in b); ) F--;
              l[d] = l[d].slice(b[F] + 1);
            }
            return l.shift(), l.join(n);
          }
        } }), pD = S({ "node_modules/remark-parse/lib/tokenize/list.js"(e, r3) {
          I();
          var u = ze(), t = mu(), a = Me(), n = Gi(), s = fD(), c3 = Eu();
          r3.exports = w;
          var i = "*", D = "_", o = "+", l = "-", d = ".", p = " ", g = `
`, F = "	", E = ")", b = "x", f = 4, x = /\n\n(?!\s*$)/, v = /^\[([ X\tx])][ \t]/, h = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/, m = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/, C = /^( {1,4}|\t)?/gm;
          function w(O, T, P) {
            for (var A = this, j = A.options.commonmark, H = A.options.pedantic, G = A.blockTokenizers, X = A.interruptList, R = 0, J = T.length, z = null, M, U, k, y, _, N, V, W, K, ee, Y, ue, le, ce, te, Z, Q, De, ye, fe = false, he, ae, pe, ne; R < J && (y = T.charAt(R), !(y !== F && y !== p)); ) R++;
            if (y = T.charAt(R), y === i || y === o || y === l) _ = y, k = false;
            else {
              for (k = true, U = ""; R < J && (y = T.charAt(R), !!a(y)); ) U += y, R++;
              if (y = T.charAt(R), !U || !(y === d || j && y === E) || P && U !== "1") return;
              z = parseInt(U, 10), _ = y;
            }
            if (y = T.charAt(++R), !(y !== p && y !== F && (H || y !== g && y !== ""))) {
              if (P) return true;
              for (R = 0, ce = [], te = [], Z = []; R < J; ) {
                for (N = T.indexOf(g, R), V = R, W = false, ne = false, N === -1 && (N = J), M = 0; R < J; ) {
                  if (y = T.charAt(R), y === F) M += f - M % f;
                  else if (y === p) M++;
                  else break;
                  R++;
                }
                if (Q && M >= Q.indent && (ne = true), y = T.charAt(R), K = null, !ne) {
                  if (y === i || y === o || y === l) K = y, R++, M++;
                  else {
                    for (U = ""; R < J && (y = T.charAt(R), !!a(y)); ) U += y, R++;
                    y = T.charAt(R), R++, U && (y === d || j && y === E) && (K = y, M += U.length + 1);
                  }
                  if (K) if (y = T.charAt(R), y === F) M += f - M % f, R++;
                  else if (y === p) {
                    for (pe = R + f; R < pe && T.charAt(R) === p; ) R++, M++;
                    R === pe && T.charAt(R) === p && (R -= f - 1, M -= f - 1);
                  } else y !== g && y !== "" && (K = null);
                }
                if (K) {
                  if (!H && _ !== K) break;
                  W = true;
                } else !j && !ne && T.charAt(V) === p ? ne = true : j && Q && (ne = M >= Q.indent || M > f), W = false, R = V;
                if (Y = T.slice(V, N), ee = V === R ? Y : T.slice(R, N), (K === i || K === D || K === l) && G.thematicBreak.call(A, O, Y, true)) break;
                if (ue = le, le = !W && !u(ee).length, ne && Q) Q.value = Q.value.concat(Z, Y), te = te.concat(Z, Y), Z = [];
                else if (W) Z.length !== 0 && (fe = true, Q.value.push(""), Q.trail = Z.concat()), Q = { value: [Y], indent: M, trail: [] }, ce.push(Q), te = te.concat(Z, Y), Z = [];
                else if (le) {
                  if (ue && !j) break;
                  Z.push(Y);
                } else {
                  if (ue || c3(X, G, A, [O, Y, true])) break;
                  Q.value = Q.value.concat(Z, Y), te = te.concat(Z, Y), Z = [];
                }
                R = N + 1;
              }
              for (he = O(te.join(g)).reset({ type: "list", ordered: k, start: z, spread: fe, children: [] }), De = A.enterList(), ye = A.enterBlock(), R = -1, J = ce.length; ++R < J; ) Q = ce[R].value.join(g), ae = O.now(), O(Q)(q(A, Q, ae), he), Q = ce[R].trail.join(g), R !== J - 1 && (Q += g), O(Q);
              return De(), ye(), he;
            }
          }
          function q(O, T, P) {
            var A = O.offset, j = O.options.pedantic ? L : B, H = null, G, X;
            return T = j.apply(null, arguments), O.options.gfm && (G = T.match(v), G && (X = G[0].length, H = G[1].toLowerCase() === b, A[P.line] += X, T = T.slice(X))), { type: "listItem", spread: x.test(T), checked: H, children: O.tokenizeBlock(T, P) };
          }
          function L(O, T, P) {
            var A = O.offset, j = P.line;
            return T = T.replace(m, H), j = P.line, T.replace(C, H);
            function H(G) {
              return A[j] = (A[j] || 0) + G.length, j++, "";
            }
          }
          function B(O, T, P) {
            var A = O.offset, j = P.line, H, G, X, R, J, z, M;
            for (T = T.replace(h, U), R = T.split(g), J = s(T, n(H).indent).split(g), J[0] = X, A[j] = (A[j] || 0) + G.length, j++, z = 0, M = R.length; ++z < M; ) A[j] = (A[j] || 0) + R[z].length - J[z].length, j++;
            return J.join(g);
            function U(k, y, _, N, V) {
              return G = y + _ + N, X = V, Number(_) < 10 && G.length % 2 === 1 && (_ = p + _), H = y + t(p, _.length) + N, H + X;
            }
          }
        } }), dD = S({ "node_modules/remark-parse/lib/tokenize/heading-setext.js"(e, r3) {
          I(), r3.exports = o;
          var u = `
`, t = "	", a = " ", n = "=", s = "-", c3 = 3, i = 1, D = 2;
          function o(l, d, p) {
            for (var g = this, F = l.now(), E = d.length, b = -1, f = "", x, v, h, m, C; ++b < E; ) {
              if (h = d.charAt(b), h !== a || b >= c3) {
                b--;
                break;
              }
              f += h;
            }
            for (x = "", v = ""; ++b < E; ) {
              if (h = d.charAt(b), h === u) {
                b--;
                break;
              }
              h === a || h === t ? v += h : (x += v + h, v = "");
            }
            if (F.column += f.length, F.offset += f.length, f += x + v, h = d.charAt(++b), m = d.charAt(++b), !(h !== u || m !== n && m !== s)) {
              for (f += h, v = m, C = m === n ? i : D; ++b < E; ) {
                if (h = d.charAt(b), h !== m) {
                  if (h !== u) return;
                  b--;
                  break;
                }
                v += h;
              }
              return p ? true : l(f + v)({ type: "heading", depth: C, children: g.tokenizeInline(x, F) });
            }
          }
        } }), Vi = S({ "node_modules/remark-parse/lib/util/html.js"(e) {
          I();
          var r3 = "[a-zA-Z_:][a-zA-Z0-9:._-]*", u = "[^\"'=<>`\\u0000-\\u0020]+", t = "'[^']*'", a = '"[^"]*"', n = "(?:" + u + "|" + t + "|" + a + ")", s = "(?:\\s+" + r3 + "(?:\\s*=\\s*" + n + ")?)", c3 = "<[A-Za-z][A-Za-z0-9\\-]*" + s + "*\\s*\\/?>", i = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", D = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", o = "<[?].*?[?]>", l = "<![A-Za-z]+\\s+[^>]*>", d = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
          e.openCloseTag = new RegExp("^(?:" + c3 + "|" + i + ")"), e.tag = new RegExp("^(?:" + c3 + "|" + i + "|" + D + "|" + o + "|" + l + "|" + d + ")");
        } }), hD = S({ "node_modules/remark-parse/lib/tokenize/html-block.js"(e, r3) {
          I();
          var u = Vi().openCloseTag;
          r3.exports = x;
          var t = "	", a = " ", n = `
`, s = "<", c3 = /^<(script|pre|style)(?=(\s|>|$))/i, i = /<\/(script|pre|style)>/i, D = /^<!--/, o = /-->/, l = /^<\?/, d = /\?>/, p = /^<![A-Za-z]/, g = />/, F = /^<!\[CDATA\[/, E = /]]>/, b = /^$/, f = new RegExp(u.source + "\\s*$");
          function x(v, h, m) {
            for (var C = this, w = C.options.blocks.join("|"), q = new RegExp("^</?(" + w + ")(?=(\\s|/?>|$))", "i"), L = h.length, B = 0, O, T, P, A, j, H, G, X = [[c3, i, true], [D, o, true], [l, d, true], [p, g, true], [F, E, true], [q, b, true], [f, b, false]]; B < L && (A = h.charAt(B), !(A !== t && A !== a)); ) B++;
            if (h.charAt(B) === s) {
              for (O = h.indexOf(n, B + 1), O = O === -1 ? L : O, T = h.slice(B, O), P = -1, j = X.length; ++P < j; ) if (X[P][0].test(T)) {
                H = X[P];
                break;
              }
              if (H) {
                if (m) return H[2];
                if (B = O, !H[1].test(T)) for (; B < L; ) {
                  if (O = h.indexOf(n, B + 1), O = O === -1 ? L : O, T = h.slice(B + 1, O), H[1].test(T)) {
                    T && (B = O);
                    break;
                  }
                  B = O;
                }
                return G = h.slice(0, B), v(G)({ type: "html", value: G });
              }
            }
          }
        } }), be = S({ "node_modules/is-whitespace-character/index.js"(e, r3) {
          I(), r3.exports = a;
          var u = String.fromCharCode, t = /\s/;
          function a(n) {
            return t.test(typeof n == "number" ? u(n) : n.charAt(0));
          }
        } }), vD = S({ "node_modules/collapse-white-space/index.js"(e, r3) {
          I(), r3.exports = u;
          function u(t) {
            return String(t).replace(/\s+/g, " ");
          }
        } }), Hi = S({ "node_modules/remark-parse/lib/util/normalize.js"(e, r3) {
          I();
          var u = vD();
          r3.exports = t;
          function t(a) {
            return u(a).toLowerCase();
          }
        } }), mD = S({ "node_modules/remark-parse/lib/tokenize/definition.js"(e, r3) {
          I();
          var u = be(), t = Hi();
          r3.exports = b;
          var a = '"', n = "'", s = "\\", c3 = `
`, i = "	", D = " ", o = "[", l = "]", d = "(", p = ")", g = ":", F = "<", E = ">";
          function b(v, h, m) {
            for (var C = this, w = C.options.commonmark, q = 0, L = h.length, B = "", O, T, P, A, j, H, G, X; q < L && (A = h.charAt(q), !(A !== D && A !== i)); ) B += A, q++;
            if (A = h.charAt(q), A === o) {
              for (q++, B += A, P = ""; q < L && (A = h.charAt(q), A !== l); ) A === s && (P += A, q++, A = h.charAt(q)), P += A, q++;
              if (!(!P || h.charAt(q) !== l || h.charAt(q + 1) !== g)) {
                for (H = P, B += P + l + g, q = B.length, P = ""; q < L && (A = h.charAt(q), !(A !== i && A !== D && A !== c3)); ) B += A, q++;
                if (A = h.charAt(q), P = "", O = B, A === F) {
                  for (q++; q < L && (A = h.charAt(q), !!f(A)); ) P += A, q++;
                  if (A = h.charAt(q), A === f.delimiter) B += F + P + A, q++;
                  else {
                    if (w) return;
                    q -= P.length + 1, P = "";
                  }
                }
                if (!P) {
                  for (; q < L && (A = h.charAt(q), !!x(A)); ) P += A, q++;
                  B += P;
                }
                if (P) {
                  for (G = P, P = ""; q < L && (A = h.charAt(q), !(A !== i && A !== D && A !== c3)); ) P += A, q++;
                  if (A = h.charAt(q), j = null, A === a ? j = a : A === n ? j = n : A === d && (j = p), !j) P = "", q = B.length;
                  else if (P) {
                    for (B += P + A, q = B.length, P = ""; q < L && (A = h.charAt(q), A !== j); ) {
                      if (A === c3) {
                        if (q++, A = h.charAt(q), A === c3 || A === j) return;
                        P += c3;
                      }
                      P += A, q++;
                    }
                    if (A = h.charAt(q), A !== j) return;
                    T = B, B += P + A, q++, X = P, P = "";
                  } else return;
                  for (; q < L && (A = h.charAt(q), !(A !== i && A !== D)); ) B += A, q++;
                  if (A = h.charAt(q), !A || A === c3) return m ? true : (O = v(O).test().end, G = C.decode.raw(C.unescape(G), O, { nonTerminated: false }), X && (T = v(T).test().end, X = C.decode.raw(C.unescape(X), T)), v(B)({ type: "definition", identifier: t(H), label: H, title: X || null, url: G }));
                }
              }
            }
          }
          function f(v) {
            return v !== E && v !== o && v !== l;
          }
          f.delimiter = E;
          function x(v) {
            return v !== o && v !== l && !u(v);
          }
        } }), ED = S({ "node_modules/remark-parse/lib/tokenize/table.js"(e, r3) {
          I();
          var u = be();
          r3.exports = F;
          var t = "	", a = `
`, n = " ", s = "-", c3 = ":", i = "\\", D = "|", o = 1, l = 2, d = "left", p = "center", g = "right";
          function F(E, b, f) {
            var x = this, v, h, m, C, w, q, L, B, O, T, P, A, j, H, G, X, R, J, z, M, U, k;
            if (x.options.gfm) {
              for (v = 0, X = 0, q = b.length + 1, L = []; v < q; ) {
                if (M = b.indexOf(a, v), U = b.indexOf(D, v + 1), M === -1 && (M = b.length), U === -1 || U > M) {
                  if (X < l) return;
                  break;
                }
                L.push(b.slice(v, M)), X++, v = M + 1;
              }
              for (C = L.join(a), h = L.splice(1, 1)[0] || [], v = 0, q = h.length, X--, m = false, P = []; v < q; ) {
                if (O = h.charAt(v), O === D) {
                  if (T = null, m === false) {
                    if (k === false) return;
                  } else P.push(m), m = false;
                  k = false;
                } else if (O === s) T = true, m = m || null;
                else if (O === c3) m === d ? m = p : T && m === null ? m = g : m = d;
                else if (!u(O)) return;
                v++;
              }
              if (m !== false && P.push(m), !(P.length < o)) {
                if (f) return true;
                for (G = -1, J = [], z = E(C).reset({ type: "table", align: P, children: J }); ++G < X; ) {
                  for (R = L[G], w = { type: "tableRow", children: [] }, G && E(a), E(R).reset(w, z), q = R.length + 1, v = 0, B = "", A = "", j = true; v < q; ) {
                    if (O = R.charAt(v), O === t || O === n) {
                      A ? B += O : E(O), v++;
                      continue;
                    }
                    O === "" || O === D ? j ? E(O) : ((A || O) && !j && (C = A, B.length > 1 && (O ? (C += B.slice(0, -1), B = B.charAt(B.length - 1)) : (C += B, B = "")), H = E.now(), E(C)({ type: "tableCell", children: x.tokenizeInline(A, H) }, w)), E(B + O), B = "", A = "") : (B && (A += B, B = ""), A += O, O === i && v !== q - 2 && (A += R.charAt(v + 1), v++)), j = false, v++;
                  }
                  G || E(a + h);
                }
                return z;
              }
            }
          }
        } }), CD = S({ "node_modules/remark-parse/lib/tokenize/paragraph.js"(e, r3) {
          I();
          var u = ze(), t = Ui(), a = Eu();
          r3.exports = D;
          var n = "	", s = `
`, c3 = " ", i = 4;
          function D(o, l, d) {
            for (var p = this, g = p.options, F = g.commonmark, E = p.blockTokenizers, b = p.interruptParagraph, f = l.indexOf(s), x = l.length, v, h, m, C, w; f < x; ) {
              if (f === -1) {
                f = x;
                break;
              }
              if (l.charAt(f + 1) === s) break;
              if (F) {
                for (C = 0, v = f + 1; v < x; ) {
                  if (m = l.charAt(v), m === n) {
                    C = i;
                    break;
                  } else if (m === c3) C++;
                  else break;
                  v++;
                }
                if (C >= i && m !== s) {
                  f = l.indexOf(s, f + 1);
                  continue;
                }
              }
              if (h = l.slice(f + 1), a(b, E, p, [o, h, true])) break;
              if (v = f, f = l.indexOf(s, f + 1), f !== -1 && u(l.slice(v, f)) === "") {
                f = v;
                break;
              }
            }
            return h = l.slice(0, f), d ? true : (w = o.now(), h = t(h), o(h)({ type: "paragraph", children: p.tokenizeInline(h, w) }));
          }
        } }), gD = S({ "node_modules/remark-parse/lib/locate/escape.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a) {
            return t.indexOf("\\", a);
          }
        } }), FD = S({ "node_modules/remark-parse/lib/tokenize/escape.js"(e, r3) {
          I();
          var u = gD();
          r3.exports = n, n.locator = u;
          var t = `
`, a = "\\";
          function n(s, c3, i) {
            var D = this, o, l;
            if (c3.charAt(0) === a && (o = c3.charAt(1), D.escape.indexOf(o) !== -1)) return i ? true : (o === t ? l = { type: "break" } : l = { type: "text", value: o }, s(a + o)(l));
          }
        } }), Xi = S({ "node_modules/remark-parse/lib/locate/tag.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a) {
            return t.indexOf("<", a);
          }
        } }), AD = S({ "node_modules/remark-parse/lib/tokenize/auto-link.js"(e, r3) {
          I();
          var u = be(), t = xr(), a = Xi();
          r3.exports = l, l.locator = a, l.notInLink = true;
          var n = "<", s = ">", c3 = "@", i = "/", D = "mailto:", o = D.length;
          function l(d, p, g) {
            var F = this, E = "", b = p.length, f = 0, x = "", v = false, h = "", m, C, w, q, L;
            if (p.charAt(0) === n) {
              for (f++, E = n; f < b && (m = p.charAt(f), !(u(m) || m === s || m === c3 || m === ":" && p.charAt(f + 1) === i)); ) x += m, f++;
              if (x) {
                if (h += x, x = "", m = p.charAt(f), h += m, f++, m === c3) v = true;
                else {
                  if (m !== ":" || p.charAt(f + 1) !== i) return;
                  h += i, f++;
                }
                for (; f < b && (m = p.charAt(f), !(u(m) || m === s)); ) x += m, f++;
                if (m = p.charAt(f), !(!x || m !== s)) return g ? true : (h += x, w = h, E += h + m, C = d.now(), C.column++, C.offset++, v && (h.slice(0, o).toLowerCase() === D ? (w = w.slice(o), C.column += o, C.offset += o) : h = D + h), q = F.inlineTokenizers, F.inlineTokenizers = { text: q.text }, L = F.enterLink(), w = F.tokenizeInline(w, C), F.inlineTokenizers = q, L(), d(E)({ type: "link", title: null, url: t(h, { nonTerminated: false }), children: w }));
              }
            }
          }
        } }), xD = S({ "node_modules/ccount/index.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a) {
            var n = String(t), s = 0, c3;
            if (typeof a != "string") throw new Error("Expected character");
            for (c3 = n.indexOf(a); c3 !== -1; ) s++, c3 = n.indexOf(a, c3 + a.length);
            return s;
          }
        } }), bD = S({ "node_modules/remark-parse/lib/locate/url.js"(e, r3) {
          I(), r3.exports = t;
          var u = ["www.", "http://", "https://"];
          function t(a, n) {
            var s = -1, c3, i, D;
            if (!this.options.gfm) return s;
            for (i = u.length, c3 = -1; ++c3 < i; ) D = a.indexOf(u[c3], n), D !== -1 && (s === -1 || D < s) && (s = D);
            return s;
          }
        } }), yD = S({ "node_modules/remark-parse/lib/tokenize/url.js"(e, r3) {
          I();
          var u = xD(), t = xr(), a = Me(), n = er(), s = be(), c3 = bD();
          r3.exports = C, C.locator = c3, C.notInLink = true;
          var i = 33, D = 38, o = 41, l = 42, d = 44, p = 45, g = 46, F = 58, E = 59, b = 63, f = 60, x = 95, v = 126, h = "(", m = ")";
          function C(w, q, L) {
            var B = this, O = B.options.gfm, T = B.inlineTokenizers, P = q.length, A = -1, j = false, H, G, X, R, J, z, M, U, k, y, _, N, V, W;
            if (O) {
              if (q.slice(0, 4) === "www.") j = true, R = 4;
              else if (q.slice(0, 7).toLowerCase() === "http://") R = 7;
              else if (q.slice(0, 8).toLowerCase() === "https://") R = 8;
              else return;
              for (A = R - 1, X = R, H = []; R < P; ) {
                if (M = q.charCodeAt(R), M === g) {
                  if (A === R - 1) break;
                  H.push(R), A = R, R++;
                  continue;
                }
                if (a(M) || n(M) || M === p || M === x) {
                  R++;
                  continue;
                }
                break;
              }
              if (M === g && (H.pop(), R--), H[0] !== void 0 && (G = H.length < 2 ? X : H[H.length - 2] + 1, q.slice(G, R).indexOf("_") === -1)) {
                if (L) return true;
                for (U = R, J = R; R < P && (M = q.charCodeAt(R), !(s(M) || M === f)); ) R++, M === i || M === l || M === d || M === g || M === F || M === b || M === x || M === v || (U = R);
                if (R = U, q.charCodeAt(R - 1) === o) for (z = q.slice(J, R), k = u(z, h), y = u(z, m); y > k; ) R = J + z.lastIndexOf(m), z = q.slice(J, R), y--;
                if (q.charCodeAt(R - 1) === E && (R--, n(q.charCodeAt(R - 1)))) {
                  for (U = R - 2; n(q.charCodeAt(U)); ) U--;
                  q.charCodeAt(U) === D && (R = U);
                }
                return _ = q.slice(0, R), V = t(_, { nonTerminated: false }), j && (V = "http://" + V), W = B.enterLink(), B.inlineTokenizers = { text: T.text }, N = B.tokenizeInline(_, w.now()), B.inlineTokenizers = T, W(), w(_)({ type: "link", title: null, url: V, children: N });
              }
            }
          }
        } }), wD = S({ "node_modules/remark-parse/lib/locate/email.js"(e, r3) {
          I();
          var u = Me(), t = er(), a = 43, n = 45, s = 46, c3 = 95;
          r3.exports = i;
          function i(o, l) {
            var d = this, p, g;
            if (!this.options.gfm || (p = o.indexOf("@", l), p === -1)) return -1;
            if (g = p, g === l || !D(o.charCodeAt(g - 1))) return i.call(d, o, p + 1);
            for (; g > l && D(o.charCodeAt(g - 1)); ) g--;
            return g;
          }
          function D(o) {
            return u(o) || t(o) || o === a || o === n || o === s || o === c3;
          }
        } }), BD = S({ "node_modules/remark-parse/lib/tokenize/email.js"(e, r3) {
          I();
          var u = xr(), t = Me(), a = er(), n = wD();
          r3.exports = l, l.locator = n, l.notInLink = true;
          var s = 43, c3 = 45, i = 46, D = 64, o = 95;
          function l(d, p, g) {
            var F = this, E = F.options.gfm, b = F.inlineTokenizers, f = 0, x = p.length, v = -1, h, m, C, w;
            if (E) {
              for (h = p.charCodeAt(f); t(h) || a(h) || h === s || h === c3 || h === i || h === o; ) h = p.charCodeAt(++f);
              if (f !== 0 && h === D) {
                for (f++; f < x; ) {
                  if (h = p.charCodeAt(f), t(h) || a(h) || h === c3 || h === i || h === o) {
                    f++, v === -1 && h === i && (v = f);
                    continue;
                  }
                  break;
                }
                if (!(v === -1 || v === f || h === c3 || h === o)) return h === i && f--, m = p.slice(0, f), g ? true : (w = F.enterLink(), F.inlineTokenizers = { text: b.text }, C = F.tokenizeInline(m, d.now()), F.inlineTokenizers = b, w(), d(m)({ type: "link", title: null, url: "mailto:" + u(m, { nonTerminated: false }), children: C }));
              }
            }
          }
        } }), kD = S({ "node_modules/remark-parse/lib/tokenize/html-inline.js"(e, r3) {
          I();
          var u = er(), t = Xi(), a = Vi().tag;
          r3.exports = l, l.locator = t;
          var n = "<", s = "?", c3 = "!", i = "/", D = /^<a /i, o = /^<\/a>/i;
          function l(d, p, g) {
            var F = this, E = p.length, b, f;
            if (!(p.charAt(0) !== n || E < 3) && (b = p.charAt(1), !(!u(b) && b !== s && b !== c3 && b !== i) && (f = p.match(a), !!f))) return g ? true : (f = f[0], !F.inLink && D.test(f) ? F.inLink = true : F.inLink && o.test(f) && (F.inLink = false), d(f)({ type: "html", value: f }));
          }
        } }), Wi = S({ "node_modules/remark-parse/lib/locate/link.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a) {
            var n = t.indexOf("[", a), s = t.indexOf("![", a);
            return s === -1 || n < s ? n : s;
          }
        } }), qD = S({ "node_modules/remark-parse/lib/tokenize/link.js"(e, r3) {
          I();
          var u = be(), t = Wi();
          r3.exports = E, E.locator = t;
          var a = `
`, n = "!", s = '"', c3 = "'", i = "(", D = ")", o = "<", l = ">", d = "[", p = "\\", g = "]", F = "`";
          function E(b, f, x) {
            var v = this, h = "", m = 0, C = f.charAt(0), w = v.options.pedantic, q = v.options.commonmark, L = v.options.gfm, B, O, T, P, A, j, H, G, X, R, J, z, M, U, k, y, _, N;
            if (C === n && (G = true, h = C, C = f.charAt(++m)), C === d && !(!G && v.inLink)) {
              for (h += C, U = "", m++, J = f.length, y = b.now(), M = 0, y.column += m, y.offset += m; m < J; ) {
                if (C = f.charAt(m), j = C, C === F) {
                  for (O = 1; f.charAt(m + 1) === F; ) j += C, m++, O++;
                  T ? O >= T && (T = 0) : T = O;
                } else if (C === p) m++, j += f.charAt(m);
                else if ((!T || L) && C === d) M++;
                else if ((!T || L) && C === g) if (M) M--;
                else {
                  if (f.charAt(m + 1) !== i) return;
                  j += i, B = true, m++;
                  break;
                }
                U += j, j = "", m++;
              }
              if (B) {
                for (X = U, h += U + j, m++; m < J && (C = f.charAt(m), !!u(C)); ) h += C, m++;
                if (C = f.charAt(m), U = "", P = h, C === o) {
                  for (m++, P += o; m < J && (C = f.charAt(m), C !== l); ) {
                    if (q && C === a) return;
                    U += C, m++;
                  }
                  if (f.charAt(m) !== l) return;
                  h += o + U + l, k = U, m++;
                } else {
                  for (C = null, j = ""; m < J && (C = f.charAt(m), !(j && (C === s || C === c3 || q && C === i))); ) {
                    if (u(C)) {
                      if (!w) break;
                      j += C;
                    } else {
                      if (C === i) M++;
                      else if (C === D) {
                        if (M === 0) break;
                        M--;
                      }
                      U += j, j = "", C === p && (U += p, C = f.charAt(++m)), U += C;
                    }
                    m++;
                  }
                  h += U, k = U, m = h.length;
                }
                for (U = ""; m < J && (C = f.charAt(m), !!u(C)); ) U += C, m++;
                if (C = f.charAt(m), h += U, U && (C === s || C === c3 || q && C === i)) if (m++, h += C, U = "", R = C === i ? D : C, A = h, q) {
                  for (; m < J && (C = f.charAt(m), C !== R); ) C === p && (U += p, C = f.charAt(++m)), m++, U += C;
                  if (C = f.charAt(m), C !== R) return;
                  for (z = U, h += U + C, m++; m < J && (C = f.charAt(m), !!u(C)); ) h += C, m++;
                } else for (j = ""; m < J; ) {
                  if (C = f.charAt(m), C === R) H && (U += R + j, j = ""), H = true;
                  else if (!H) U += C;
                  else if (C === D) {
                    h += U + R + j, z = U;
                    break;
                  } else u(C) ? j += C : (U += R + j + C, j = "", H = false);
                  m++;
                }
                if (f.charAt(m) === D) return x ? true : (h += D, k = v.decode.raw(v.unescape(k), b(P).test().end, { nonTerminated: false }), z && (A = b(A).test().end, z = v.decode.raw(v.unescape(z), A)), N = { type: G ? "image" : "link", title: z || null, url: k }, G ? N.alt = v.decode.raw(v.unescape(X), y) || null : (_ = v.enterLink(), N.children = v.tokenizeInline(X, y), _()), b(h)(N));
              }
            }
          }
        } }), _D = S({ "node_modules/remark-parse/lib/tokenize/reference.js"(e, r3) {
          I();
          var u = be(), t = Wi(), a = Hi();
          r3.exports = g, g.locator = t;
          var n = "link", s = "image", c3 = "shortcut", i = "collapsed", D = "full", o = "!", l = "[", d = "\\", p = "]";
          function g(F, E, b) {
            var f = this, x = f.options.commonmark, v = E.charAt(0), h = 0, m = E.length, C = "", w = "", q = n, L = c3, B, O, T, P, A, j, H, G;
            if (v === o && (q = s, w = v, v = E.charAt(++h)), v === l) {
              for (h++, w += v, j = "", G = 0; h < m; ) {
                if (v = E.charAt(h), v === l) H = true, G++;
                else if (v === p) {
                  if (!G) break;
                  G--;
                }
                v === d && (j += d, v = E.charAt(++h)), j += v, h++;
              }
              if (C = j, B = j, v = E.charAt(h), v === p) {
                if (h++, C += v, j = "", !x) for (; h < m && (v = E.charAt(h), !!u(v)); ) j += v, h++;
                if (v = E.charAt(h), v === l) {
                  for (O = "", j += v, h++; h < m && (v = E.charAt(h), !(v === l || v === p)); ) v === d && (O += d, v = E.charAt(++h)), O += v, h++;
                  v = E.charAt(h), v === p ? (L = O ? D : i, j += O + v, h++) : O = "", C += j, j = "";
                } else {
                  if (!B) return;
                  O = B;
                }
                if (!(L !== D && H)) return C = w + C, q === n && f.inLink ? null : b ? true : (T = F.now(), T.column += w.length, T.offset += w.length, O = L === D ? O : B, P = { type: q + "Reference", identifier: a(O), label: O, referenceType: L }, q === n ? (A = f.enterLink(), P.children = f.tokenizeInline(B, T), A()) : P.alt = f.decode.raw(f.unescape(B), T) || null, F(C)(P));
              }
            }
          }
        } }), OD = S({ "node_modules/remark-parse/lib/locate/strong.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a) {
            var n = t.indexOf("**", a), s = t.indexOf("__", a);
            return s === -1 ? n : n === -1 || s < n ? s : n;
          }
        } }), ID = S({ "node_modules/remark-parse/lib/tokenize/strong.js"(e, r3) {
          I();
          var u = ze(), t = be(), a = OD();
          r3.exports = i, i.locator = a;
          var n = "\\", s = "*", c3 = "_";
          function i(D, o, l) {
            var d = this, p = 0, g = o.charAt(p), F, E, b, f, x, v, h;
            if (!(g !== s && g !== c3 || o.charAt(++p) !== g) && (E = d.options.pedantic, b = g, x = b + b, v = o.length, p++, f = "", g = "", !(E && t(o.charAt(p))))) for (; p < v; ) {
              if (h = g, g = o.charAt(p), g === b && o.charAt(p + 1) === b && (!E || !t(h)) && (g = o.charAt(p + 2), g !== b)) return u(f) ? l ? true : (F = D.now(), F.column += 2, F.offset += 2, D(x + f + x)({ type: "strong", children: d.tokenizeInline(f, F) })) : void 0;
              !E && g === n && (f += g, g = o.charAt(++p)), f += g, p++;
            }
          }
        } }), SD = S({ "node_modules/is-word-character/index.js"(e, r3) {
          I(), r3.exports = a;
          var u = String.fromCharCode, t = /\w/;
          function a(n) {
            return t.test(typeof n == "number" ? u(n) : n.charAt(0));
          }
        } }), TD = S({ "node_modules/remark-parse/lib/locate/emphasis.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a) {
            var n = t.indexOf("*", a), s = t.indexOf("_", a);
            return s === -1 ? n : n === -1 || s < n ? s : n;
          }
        } }), ND = S({ "node_modules/remark-parse/lib/tokenize/emphasis.js"(e, r3) {
          I();
          var u = ze(), t = SD(), a = be(), n = TD();
          r3.exports = D, D.locator = n;
          var s = "*", c3 = "_", i = "\\";
          function D(o, l, d) {
            var p = this, g = 0, F = l.charAt(g), E, b, f, x, v, h, m;
            if (!(F !== s && F !== c3) && (b = p.options.pedantic, v = F, f = F, h = l.length, g++, x = "", F = "", !(b && a(l.charAt(g))))) for (; g < h; ) {
              if (m = F, F = l.charAt(g), F === f && (!b || !a(m))) {
                if (F = l.charAt(++g), F !== f) {
                  if (!u(x) || m === f) return;
                  if (!b && f === c3 && t(F)) {
                    x += f;
                    continue;
                  }
                  return d ? true : (E = o.now(), E.column++, E.offset++, o(v + x + f)({ type: "emphasis", children: p.tokenizeInline(x, E) }));
                }
                x += f;
              }
              !b && F === i && (x += F, F = l.charAt(++g)), x += F, g++;
            }
          }
        } }), LD = S({ "node_modules/remark-parse/lib/locate/delete.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a) {
            return t.indexOf("~~", a);
          }
        } }), RD = S({ "node_modules/remark-parse/lib/tokenize/delete.js"(e, r3) {
          I();
          var u = be(), t = LD();
          r3.exports = s, s.locator = t;
          var a = "~", n = "~~";
          function s(c3, i, D) {
            var o = this, l = "", d = "", p = "", g = "", F, E, b;
            if (!(!o.options.gfm || i.charAt(0) !== a || i.charAt(1) !== a || u(i.charAt(2)))) for (F = 1, E = i.length, b = c3.now(), b.column += 2, b.offset += 2; ++F < E; ) {
              if (l = i.charAt(F), l === a && d === a && (!p || !u(p))) return D ? true : c3(n + g + n)({ type: "delete", children: o.tokenizeInline(g, b) });
              g += d, p = d, d = l;
            }
          }
        } }), jD = S({ "node_modules/remark-parse/lib/locate/code-inline.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a) {
            return t.indexOf("`", a);
          }
        } }), PD = S({ "node_modules/remark-parse/lib/tokenize/code-inline.js"(e, r3) {
          I();
          var u = jD();
          r3.exports = s, s.locator = u;
          var t = 10, a = 32, n = 96;
          function s(c3, i, D) {
            for (var o = i.length, l = 0, d, p, g, F, E, b; l < o && i.charCodeAt(l) === n; ) l++;
            if (!(l === 0 || l === o)) {
              for (d = l, E = i.charCodeAt(l); l < o; ) {
                if (F = E, E = i.charCodeAt(l + 1), F === n) {
                  if (p === void 0 && (p = l), g = l + 1, E !== n && g - p === d) {
                    b = true;
                    break;
                  }
                } else p !== void 0 && (p = void 0, g = void 0);
                l++;
              }
              if (b) {
                if (D) return true;
                if (l = d, o = p, F = i.charCodeAt(l), E = i.charCodeAt(o - 1), b = false, o - l > 2 && (F === a || F === t) && (E === a || E === t)) {
                  for (l++, o--; l < o; ) {
                    if (F = i.charCodeAt(l), F !== a && F !== t) {
                      b = true;
                      break;
                    }
                    l++;
                  }
                  b === true && (d++, p--);
                }
                return c3(i.slice(0, g))({ type: "inlineCode", value: i.slice(d, p) });
              }
            }
          }
        } }), MD = S({ "node_modules/remark-parse/lib/locate/break.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a) {
            for (var n = t.indexOf(`
`, a); n > a && t.charAt(n - 1) === " "; ) n--;
            return n;
          }
        } }), zD = S({ "node_modules/remark-parse/lib/tokenize/break.js"(e, r3) {
          I();
          var u = MD();
          r3.exports = s, s.locator = u;
          var t = " ", a = `
`, n = 2;
          function s(c3, i, D) {
            for (var o = i.length, l = -1, d = "", p; ++l < o; ) {
              if (p = i.charAt(l), p === a) return l < n ? void 0 : D ? true : (d += p, c3(d)({ type: "break" }));
              if (p !== t) return;
              d += p;
            }
          }
        } }), $D = S({ "node_modules/remark-parse/lib/tokenize/text.js"(e, r3) {
          I(), r3.exports = u;
          function u(t, a, n) {
            var s = this, c3, i, D, o, l, d, p, g, F, E;
            if (n) return true;
            for (c3 = s.inlineMethods, o = c3.length, i = s.inlineTokenizers, D = -1, F = a.length; ++D < o; ) g = c3[D], !(g === "text" || !i[g]) && (p = i[g].locator, p || t.file.fail("Missing locator: `" + g + "`"), d = p.call(s, a, 1), d !== -1 && d < F && (F = d));
            l = a.slice(0, F), E = t.now(), s.decode(l, E, b);
            function b(f, x, v) {
              t(v || f)({ type: "text", value: f });
            }
          }
        } }), UD = S({ "node_modules/remark-parse/lib/parser.js"(e, r3) {
          I();
          var u = Pe(), t = Ml(), a = zl(), n = $l(), s = Kl(), c3 = Yl();
          r3.exports = i;
          function i(l, d) {
            this.file = d, this.offset = {}, this.options = u(this.options), this.setOptions({}), this.inList = false, this.inBlock = false, this.inLink = false, this.atStart = true, this.toOffset = a(d).toOffset, this.unescape = n(this, "escape"), this.decode = s(this);
          }
          var D = i.prototype;
          D.setOptions = Ql(), D.parse = iD(), D.options = $i(), D.exitStart = t("atStart", true), D.enterList = t("inList", false), D.enterLink = t("inLink", false), D.enterBlock = t("inBlock", false), D.interruptParagraph = [["thematicBreak"], ["list"], ["atxHeading"], ["fencedCode"], ["blockquote"], ["html"], ["setextHeading", { commonmark: false }], ["definition", { commonmark: false }]], D.interruptList = [["atxHeading", { pedantic: false }], ["fencedCode", { pedantic: false }], ["thematicBreak", { pedantic: false }], ["definition", { commonmark: false }]], D.interruptBlockquote = [["indentedCode", { commonmark: true }], ["fencedCode", { commonmark: true }], ["atxHeading", { commonmark: true }], ["setextHeading", { commonmark: true }], ["thematicBreak", { commonmark: true }], ["html", { commonmark: true }], ["list", { commonmark: true }], ["definition", { commonmark: false }]], D.blockTokenizers = { blankLine: aD(), indentedCode: oD(), fencedCode: sD(), blockquote: cD(), atxHeading: lD(), thematicBreak: DD(), list: pD(), setextHeading: dD(), html: hD(), definition: mD(), table: ED(), paragraph: CD() }, D.inlineTokenizers = { escape: FD(), autoLink: AD(), url: yD(), email: BD(), html: kD(), link: qD(), reference: _D(), strong: ID(), emphasis: ND(), deletion: RD(), code: PD(), break: zD(), text: $D() }, D.blockMethods = o(D.blockTokenizers), D.inlineMethods = o(D.inlineTokenizers), D.tokenizeBlock = c3("block"), D.tokenizeInline = c3("inline"), D.tokenizeFactory = c3;
          function o(l) {
            var d = [], p;
            for (p in l) d.push(p);
            return d;
          }
        } }), GD = S({ "node_modules/remark-parse/index.js"(e, r3) {
          I();
          var u = Pl(), t = Pe(), a = UD();
          r3.exports = n, n.Parser = a;
          function n(s) {
            var c3 = this.data("settings"), i = u(a);
            i.prototype.options = t(i.prototype.options, c3, s), this.Parser = i;
          }
        } }), VD = S({ "node_modules/bail/index.js"(e, r3) {
          I(), r3.exports = u;
          function u(t) {
            if (t) throw t;
          }
        } }), Ki = S({ "node_modules/is-buffer/index.js"(e, r3) {
          I(), r3.exports = function(t) {
            return t != null && t.constructor != null && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t);
          };
        } }), HD = S({ "node_modules/extend/index.js"(e, r3) {
          I();
          var u = Object.prototype.hasOwnProperty, t = Object.prototype.toString, a = Object.defineProperty, n = Object.getOwnPropertyDescriptor, s = function(l) {
            return typeof Array.isArray == "function" ? Array.isArray(l) : t.call(l) === "[object Array]";
          }, c3 = function(l) {
            if (!l || t.call(l) !== "[object Object]") return false;
            var d = u.call(l, "constructor"), p = l.constructor && l.constructor.prototype && u.call(l.constructor.prototype, "isPrototypeOf");
            if (l.constructor && !d && !p) return false;
            var g;
            for (g in l) ;
            return typeof g > "u" || u.call(l, g);
          }, i = function(l, d) {
            a && d.name === "__proto__" ? a(l, d.name, { enumerable: true, configurable: true, value: d.newValue, writable: true }) : l[d.name] = d.newValue;
          }, D = function(l, d) {
            if (d === "__proto__") if (u.call(l, d)) {
              if (n) return n(l, d).value;
            } else return;
            return l[d];
          };
          r3.exports = function o() {
            var l, d, p, g, F, E, b = arguments[0], f = 1, x = arguments.length, v = false;
            for (typeof b == "boolean" && (v = b, b = arguments[1] || {}, f = 2), (b == null || typeof b != "object" && typeof b != "function") && (b = {}); f < x; ++f) if (l = arguments[f], l != null) for (d in l) p = D(b, d), g = D(l, d), b !== g && (v && g && (c3(g) || (F = s(g))) ? (F ? (F = false, E = p && s(p) ? p : []) : E = p && c3(p) ? p : {}, i(b, { name: d, newValue: o(v, E, g) })) : typeof g < "u" && i(b, { name: d, newValue: g }));
            return b;
          };
        } }), XD = S({ "node_modules/is-plain-obj/index.js"(e, r3) {
          I(), r3.exports = (u) => {
            if (Object.prototype.toString.call(u) !== "[object Object]") return false;
            let t = Object.getPrototypeOf(u);
            return t === null || t === Object.prototype;
          };
        } }), WD = S({ "node_modules/trough/wrap.js"(e, r3) {
          I();
          var u = [].slice;
          r3.exports = t;
          function t(a, n) {
            var s;
            return c3;
            function c3() {
              var o = u.call(arguments, 0), l = a.length > o.length, d;
              l && o.push(i);
              try {
                d = a.apply(null, o);
              } catch (p) {
                if (l && s) throw p;
                return i(p);
              }
              l || (d && typeof d.then == "function" ? d.then(D, i) : d instanceof Error ? i(d) : D(d));
            }
            function i() {
              s || (s = true, n.apply(null, arguments));
            }
            function D(o) {
              i(null, o);
            }
          }
        } }), KD = S({ "node_modules/trough/index.js"(e, r3) {
          I();
          var u = WD();
          r3.exports = a, a.wrap = u;
          var t = [].slice;
          function a() {
            var n = [], s = {};
            return s.run = c3, s.use = i, s;
            function c3() {
              var D = -1, o = t.call(arguments, 0, -1), l = arguments[arguments.length - 1];
              if (typeof l != "function") throw new Error("Expected function as last argument, not " + l);
              d.apply(null, [null].concat(o));
              function d(p) {
                var g = n[++D], F = t.call(arguments, 0), E = F.slice(1), b = o.length, f = -1;
                if (p) {
                  l(p);
                  return;
                }
                for (; ++f < b; ) (E[f] === null || E[f] === void 0) && (E[f] = o[f]);
                o = E, g ? u(g, d).apply(null, o) : l.apply(null, [null].concat(o));
              }
            }
            function i(D) {
              if (typeof D != "function") throw new Error("Expected `fn` to be a function, not " + D);
              return n.push(D), s;
            }
          }
        } }), YD = S({ "node_modules/unist-util-stringify-position/index.js"(e, r3) {
          I();
          var u = {}.hasOwnProperty;
          r3.exports = t;
          function t(c3) {
            return !c3 || typeof c3 != "object" ? "" : u.call(c3, "position") || u.call(c3, "type") ? n(c3.position) : u.call(c3, "start") || u.call(c3, "end") ? n(c3) : u.call(c3, "line") || u.call(c3, "column") ? a(c3) : "";
          }
          function a(c3) {
            return (!c3 || typeof c3 != "object") && (c3 = {}), s(c3.line) + ":" + s(c3.column);
          }
          function n(c3) {
            return (!c3 || typeof c3 != "object") && (c3 = {}), a(c3.start) + "-" + a(c3.end);
          }
          function s(c3) {
            return c3 && typeof c3 == "number" ? c3 : 1;
          }
        } }), JD = S({ "node_modules/vfile-message/index.js"(e, r3) {
          I();
          var u = YD();
          r3.exports = n;
          function t() {
          }
          t.prototype = Error.prototype, n.prototype = new t();
          var a = n.prototype;
          a.file = "", a.name = "", a.reason = "", a.message = "", a.stack = "", a.fatal = null, a.column = null, a.line = null;
          function n(c3, i, D) {
            var o, l, d;
            typeof i == "string" && (D = i, i = null), o = s(D), l = u(i) || "1:1", d = { start: { line: null, column: null }, end: { line: null, column: null } }, i && i.position && (i = i.position), i && (i.start ? (d = i, i = i.start) : d.start = i), c3.stack && (this.stack = c3.stack, c3 = c3.message), this.message = c3, this.name = l, this.reason = c3, this.line = i ? i.line : null, this.column = i ? i.column : null, this.location = d, this.source = o[0], this.ruleId = o[1];
          }
          function s(c3) {
            var i = [null, null], D;
            return typeof c3 == "string" && (D = c3.indexOf(":"), D === -1 ? i[1] = c3 : (i[0] = c3.slice(0, D), i[1] = c3.slice(D + 1))), i;
          }
        } }), ZD = S({ "node_modules/vfile/lib/minpath.browser.js"(e) {
          I(), e.basename = r3, e.dirname = u, e.extname = t, e.join = a, e.sep = "/";
          function r3(i, D) {
            var o = 0, l = -1, d, p, g, F;
            if (D !== void 0 && typeof D != "string") throw new TypeError('"ext" argument must be a string');
            if (c3(i), d = i.length, D === void 0 || !D.length || D.length > i.length) {
              for (; d--; ) if (i.charCodeAt(d) === 47) {
                if (g) {
                  o = d + 1;
                  break;
                }
              } else l < 0 && (g = true, l = d + 1);
              return l < 0 ? "" : i.slice(o, l);
            }
            if (D === i) return "";
            for (p = -1, F = D.length - 1; d--; ) if (i.charCodeAt(d) === 47) {
              if (g) {
                o = d + 1;
                break;
              }
            } else p < 0 && (g = true, p = d + 1), F > -1 && (i.charCodeAt(d) === D.charCodeAt(F--) ? F < 0 && (l = d) : (F = -1, l = p));
            return o === l ? l = p : l < 0 && (l = i.length), i.slice(o, l);
          }
          function u(i) {
            var D, o, l;
            if (c3(i), !i.length) return ".";
            for (D = -1, l = i.length; --l; ) if (i.charCodeAt(l) === 47) {
              if (o) {
                D = l;
                break;
              }
            } else o || (o = true);
            return D < 0 ? i.charCodeAt(0) === 47 ? "/" : "." : D === 1 && i.charCodeAt(0) === 47 ? "//" : i.slice(0, D);
          }
          function t(i) {
            var D = -1, o = 0, l = -1, d = 0, p, g, F;
            for (c3(i), F = i.length; F--; ) {
              if (g = i.charCodeAt(F), g === 47) {
                if (p) {
                  o = F + 1;
                  break;
                }
                continue;
              }
              l < 0 && (p = true, l = F + 1), g === 46 ? D < 0 ? D = F : d !== 1 && (d = 1) : D > -1 && (d = -1);
            }
            return D < 0 || l < 0 || d === 0 || d === 1 && D === l - 1 && D === o + 1 ? "" : i.slice(D, l);
          }
          function a() {
            for (var i = -1, D; ++i < arguments.length; ) c3(arguments[i]), arguments[i] && (D = D === void 0 ? arguments[i] : D + "/" + arguments[i]);
            return D === void 0 ? "." : n(D);
          }
          function n(i) {
            var D, o;
            return c3(i), D = i.charCodeAt(0) === 47, o = s(i, !D), !o.length && !D && (o = "."), o.length && i.charCodeAt(i.length - 1) === 47 && (o += "/"), D ? "/" + o : o;
          }
          function s(i, D) {
            for (var o = "", l = 0, d = -1, p = 0, g = -1, F, E; ++g <= i.length; ) {
              if (g < i.length) F = i.charCodeAt(g);
              else {
                if (F === 47) break;
                F = 47;
              }
              if (F === 47) {
                if (!(d === g - 1 || p === 1)) if (d !== g - 1 && p === 2) {
                  if (o.length < 2 || l !== 2 || o.charCodeAt(o.length - 1) !== 46 || o.charCodeAt(o.length - 2) !== 46) {
                    if (o.length > 2) {
                      if (E = o.lastIndexOf("/"), E !== o.length - 1) {
                        E < 0 ? (o = "", l = 0) : (o = o.slice(0, E), l = o.length - 1 - o.lastIndexOf("/")), d = g, p = 0;
                        continue;
                      }
                    } else if (o.length) {
                      o = "", l = 0, d = g, p = 0;
                      continue;
                    }
                  }
                  D && (o = o.length ? o + "/.." : "..", l = 2);
                } else o.length ? o += "/" + i.slice(d + 1, g) : o = i.slice(d + 1, g), l = g - d - 1;
                d = g, p = 0;
              } else F === 46 && p > -1 ? p++ : p = -1;
            }
            return o;
          }
          function c3(i) {
            if (typeof i != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(i));
          }
        } }), QD = S({ "node_modules/vfile/lib/minproc.browser.js"(e) {
          I(), e.cwd = r3;
          function r3() {
            return "/";
          }
        } }), e2 = S({ "node_modules/vfile/lib/core.js"(e, r3) {
          I();
          var u = ZD(), t = QD(), a = Ki();
          r3.exports = c3;
          var n = {}.hasOwnProperty, s = ["history", "path", "basename", "stem", "extname", "dirname"];
          c3.prototype.toString = f, Object.defineProperty(c3.prototype, "path", { get: i, set: D }), Object.defineProperty(c3.prototype, "dirname", { get: o, set: l }), Object.defineProperty(c3.prototype, "basename", { get: d, set: p }), Object.defineProperty(c3.prototype, "extname", { get: g, set: F }), Object.defineProperty(c3.prototype, "stem", { get: E, set: b });
          function c3(m) {
            var C, w;
            if (!m) m = {};
            else if (typeof m == "string" || a(m)) m = { contents: m };
            else if ("message" in m && "messages" in m) return m;
            if (!(this instanceof c3)) return new c3(m);
            for (this.data = {}, this.messages = [], this.history = [], this.cwd = t.cwd(), w = -1; ++w < s.length; ) C = s[w], n.call(m, C) && (this[C] = m[C]);
            for (C in m) s.indexOf(C) < 0 && (this[C] = m[C]);
          }
          function i() {
            return this.history[this.history.length - 1];
          }
          function D(m) {
            v(m, "path"), this.path !== m && this.history.push(m);
          }
          function o() {
            return typeof this.path == "string" ? u.dirname(this.path) : void 0;
          }
          function l(m) {
            h(this.path, "dirname"), this.path = u.join(m || "", this.basename);
          }
          function d() {
            return typeof this.path == "string" ? u.basename(this.path) : void 0;
          }
          function p(m) {
            v(m, "basename"), x(m, "basename"), this.path = u.join(this.dirname || "", m);
          }
          function g() {
            return typeof this.path == "string" ? u.extname(this.path) : void 0;
          }
          function F(m) {
            if (x(m, "extname"), h(this.path, "extname"), m) {
              if (m.charCodeAt(0) !== 46) throw new Error("`extname` must start with `.`");
              if (m.indexOf(".", 1) > -1) throw new Error("`extname` cannot contain multiple dots");
            }
            this.path = u.join(this.dirname, this.stem + (m || ""));
          }
          function E() {
            return typeof this.path == "string" ? u.basename(this.path, this.extname) : void 0;
          }
          function b(m) {
            v(m, "stem"), x(m, "stem"), this.path = u.join(this.dirname || "", m + (this.extname || ""));
          }
          function f(m) {
            return (this.contents || "").toString(m);
          }
          function x(m, C) {
            if (m && m.indexOf(u.sep) > -1) throw new Error("`" + C + "` cannot be a path: did not expect `" + u.sep + "`");
          }
          function v(m, C) {
            if (!m) throw new Error("`" + C + "` cannot be empty");
          }
          function h(m, C) {
            if (!m) throw new Error("Setting `" + C + "` requires `path` to be set too");
          }
        } }), r2 = S({ "node_modules/vfile/lib/index.js"(e, r3) {
          I();
          var u = JD(), t = e2();
          r3.exports = t, t.prototype.message = a, t.prototype.info = s, t.prototype.fail = n;
          function a(c3, i, D) {
            var o = new u(c3, i, D);
            return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = false, this.messages.push(o), o;
          }
          function n() {
            var c3 = this.message.apply(this, arguments);
            throw c3.fatal = true, c3;
          }
          function s() {
            var c3 = this.message.apply(this, arguments);
            return c3.fatal = null, c3;
          }
        } }), u2 = S({ "node_modules/vfile/index.js"(e, r3) {
          I(), r3.exports = r2();
        } }), t2 = S({ "node_modules/unified/index.js"(e, r3) {
          I();
          var u = VD(), t = Ki(), a = HD(), n = XD(), s = KD(), c3 = u2();
          r3.exports = g().freeze();
          var i = [].slice, D = {}.hasOwnProperty, o = s().use(l).use(d).use(p);
          function l(m, C) {
            C.tree = m.parse(C.file);
          }
          function d(m, C, w) {
            m.run(C.tree, C.file, q);
            function q(L, B, O) {
              L ? w(L) : (C.tree = B, C.file = O, w());
            }
          }
          function p(m, C) {
            var w = m.stringify(C.tree, C.file);
            w == null || (typeof w == "string" || t(w) ? C.file.contents = w : C.file.result = w);
          }
          function g() {
            var m = [], C = s(), w = {}, q = -1, L;
            return B.data = T, B.freeze = O, B.attachers = m, B.use = P, B.parse = j, B.stringify = X, B.run = H, B.runSync = G, B.process = R, B.processSync = J, B;
            function B() {
              for (var z = g(), M = -1; ++M < m.length; ) z.use.apply(null, m[M]);
              return z.data(a(true, {}, w)), z;
            }
            function O() {
              var z, M;
              if (L) return B;
              for (; ++q < m.length; ) z = m[q], z[1] !== false && (z[1] === true && (z[1] = void 0), M = z[0].apply(B, z.slice(1)), typeof M == "function" && C.use(M));
              return L = true, q = 1 / 0, B;
            }
            function T(z, M) {
              return typeof z == "string" ? arguments.length === 2 ? (x("data", L), w[z] = M, B) : D.call(w, z) && w[z] || null : z ? (x("data", L), w = z, B) : w;
            }
            function P(z) {
              var M;
              if (x("use", L), z != null) if (typeof z == "function") _.apply(null, arguments);
              else if (typeof z == "object") "length" in z ? y(z) : U(z);
              else throw new Error("Expected usable value, not `" + z + "`");
              return M && (w.settings = a(w.settings || {}, M)), B;
              function U(N) {
                y(N.plugins), N.settings && (M = a(M || {}, N.settings));
              }
              function k(N) {
                if (typeof N == "function") _(N);
                else if (typeof N == "object") "length" in N ? _.apply(null, N) : U(N);
                else throw new Error("Expected usable value, not `" + N + "`");
              }
              function y(N) {
                var V = -1;
                if (N != null) if (typeof N == "object" && "length" in N) for (; ++V < N.length; ) k(N[V]);
                else throw new Error("Expected a list of plugins, not `" + N + "`");
              }
              function _(N, V) {
                var W = A(N);
                W ? (n(W[1]) && n(V) && (V = a(true, W[1], V)), W[1] = V) : m.push(i.call(arguments));
              }
            }
            function A(z) {
              for (var M = -1; ++M < m.length; ) if (m[M][0] === z) return m[M];
            }
            function j(z) {
              var M = c3(z), U;
              return O(), U = B.Parser, b("parse", U), F(U, "parse") ? new U(String(M), M).parse() : U(String(M), M);
            }
            function H(z, M, U) {
              if (v(z), O(), !U && typeof M == "function" && (U = M, M = null), !U) return new Promise(k);
              k(null, U);
              function k(y, _) {
                C.run(z, c3(M), N);
                function N(V, W, K) {
                  W = W || z, V ? _(V) : y ? y(W) : U(null, W, K);
                }
              }
            }
            function G(z, M) {
              var U, k;
              return H(z, M, y), h("runSync", "run", k), U;
              function y(_, N) {
                k = true, U = N, u(_);
              }
            }
            function X(z, M) {
              var U = c3(M), k;
              return O(), k = B.Compiler, f("stringify", k), v(z), F(k, "compile") ? new k(z, U).compile() : k(z, U);
            }
            function R(z, M) {
              if (O(), b("process", B.Parser), f("process", B.Compiler), !M) return new Promise(U);
              U(null, M);
              function U(k, y) {
                var _ = c3(z);
                o.run(B, { file: _ }, N);
                function N(V) {
                  V ? y(V) : k ? k(_) : M(null, _);
                }
              }
            }
            function J(z) {
              var M, U;
              return O(), b("processSync", B.Parser), f("processSync", B.Compiler), M = c3(z), R(M, k), h("processSync", "process", U), M;
              function k(y) {
                U = true, u(y);
              }
            }
          }
          function F(m, C) {
            return typeof m == "function" && m.prototype && (E(m.prototype) || C in m.prototype);
          }
          function E(m) {
            var C;
            for (C in m) return true;
            return false;
          }
          function b(m, C) {
            if (typeof C != "function") throw new Error("Cannot `" + m + "` without `Parser`");
          }
          function f(m, C) {
            if (typeof C != "function") throw new Error("Cannot `" + m + "` without `Compiler`");
          }
          function x(m, C) {
            if (C) throw new Error("Cannot invoke `" + m + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
          }
          function v(m) {
            if (!m || typeof m.type != "string") throw new Error("Expected node, got `" + m + "`");
          }
          function h(m, C, w) {
            if (!w) throw new Error("`" + m + "` finished async. Use `" + C + "` instead");
          }
        } }), Yi = S({ "node_modules/remark-math/util.js"(e) {
          I(), e.isRemarkParser = r3, e.isRemarkCompiler = u;
          function r3(t) {
            return Boolean(t && t.prototype && t.prototype.blockTokenizers);
          }
          function u(t) {
            return Boolean(t && t.prototype && t.prototype.visitors);
          }
        } }), n2 = S({ "node_modules/remark-math/inline.js"(e, r3) {
          I();
          var u = Yi();
          r3.exports = l;
          var t = 9, a = 32, n = 36, s = 48, c3 = 57, i = 92, D = ["math", "math-inline"], o = "math-display";
          function l(g) {
            let F = this.Parser, E = this.Compiler;
            u.isRemarkParser(F) && d(F, g), u.isRemarkCompiler(E) && p(E);
          }
          function d(g, F) {
            let E = g.prototype, b = E.inlineMethods;
            x.locator = f, E.inlineTokenizers.math = x, b.splice(b.indexOf("text"), 0, "math");
            function f(v, h) {
              return v.indexOf("$", h);
            }
            function x(v, h, m) {
              let C = h.length, w = false, q = false, L = 0, B, O, T, P, A, j, H;
              if (h.charCodeAt(L) === i && (q = true, L++), h.charCodeAt(L) === n) {
                if (L++, q) return m ? true : v(h.slice(0, L))({ type: "text", value: "$" });
                if (h.charCodeAt(L) === n && (w = true, L++), T = h.charCodeAt(L), !(T === a || T === t)) {
                  for (P = L; L < C; ) {
                    if (O = T, T = h.charCodeAt(L + 1), O === n) {
                      if (B = h.charCodeAt(L - 1), B !== a && B !== t && (T !== T || T < s || T > c3) && (!w || T === n)) {
                        A = L - 1, L++, w && L++, j = L;
                        break;
                      }
                    } else O === i && (L++, T = h.charCodeAt(L + 1));
                    L++;
                  }
                  if (j !== void 0) return m ? true : (H = h.slice(P, A + 1), v(h.slice(0, j))({ type: "inlineMath", value: H, data: { hName: "span", hProperties: { className: D.concat(w && F.inlineMathDouble ? [o] : []) }, hChildren: [{ type: "text", value: H }] } }));
                }
              }
            }
          }
          function p(g) {
            let F = g.prototype;
            F.visitors.inlineMath = E;
            function E(b) {
              let f = "$";
              return (b.data && b.data.hProperties && b.data.hProperties.className || []).includes(o) && (f = "$$"), f + b.value + f;
            }
          }
        } }), i2 = S({ "node_modules/remark-math/block.js"(e, r3) {
          I();
          var u = Yi();
          r3.exports = o;
          var t = 10, a = 32, n = 36, s = `
`, c3 = "$", i = 2, D = ["math", "math-display"];
          function o() {
            let p = this.Parser, g = this.Compiler;
            u.isRemarkParser(p) && l(p), u.isRemarkCompiler(g) && d(g);
          }
          function l(p) {
            let g = p.prototype, F = g.blockMethods, E = g.interruptParagraph, b = g.interruptList, f = g.interruptBlockquote;
            g.blockTokenizers.math = x, F.splice(F.indexOf("fencedCode") + 1, 0, "math"), E.splice(E.indexOf("fencedCode") + 1, 0, ["math"]), b.splice(b.indexOf("fencedCode") + 1, 0, ["math"]), f.splice(f.indexOf("fencedCode") + 1, 0, ["math"]);
            function x(v, h, m) {
              var C = h.length, w = 0;
              let q, L, B, O, T, P, A, j, H, G, X;
              for (; w < C && h.charCodeAt(w) === a; ) w++;
              for (T = w; w < C && h.charCodeAt(w) === n; ) w++;
              if (P = w - T, !(P < i)) {
                for (; w < C && h.charCodeAt(w) === a; ) w++;
                for (A = w; w < C; ) {
                  if (q = h.charCodeAt(w), q === n) return;
                  if (q === t) break;
                  w++;
                }
                if (h.charCodeAt(w) === t) {
                  if (m) return true;
                  for (L = [], A !== w && L.push(h.slice(A, w)), w++, B = h.indexOf(s, w + 1), B = B === -1 ? C : B; w < C; ) {
                    for (j = false, G = w, X = B, O = B, H = 0; O > G && h.charCodeAt(O - 1) === a; ) O--;
                    for (; O > G && h.charCodeAt(O - 1) === n; ) H++, O--;
                    for (P <= H && h.indexOf(c3, G) === O && (j = true, X = O); G <= X && G - w < T && h.charCodeAt(G) === a; ) G++;
                    if (j) for (; X > G && h.charCodeAt(X - 1) === a; ) X--;
                    if ((!j || G !== X) && L.push(h.slice(G, X)), j) break;
                    w = B + 1, B = h.indexOf(s, w + 1), B = B === -1 ? C : B;
                  }
                  return L = L.join(`
`), v(h.slice(0, B))({ type: "math", value: L, data: { hName: "div", hProperties: { className: D.concat() }, hChildren: [{ type: "text", value: L }] } });
                }
              }
            }
          }
          function d(p) {
            let g = p.prototype;
            g.visitors.math = F;
            function F(E) {
              return `$$
` + E.value + `
$$`;
            }
          }
        } }), a2 = S({ "node_modules/remark-math/index.js"(e, r3) {
          I();
          var u = n2(), t = i2();
          r3.exports = a;
          function a(n) {
            var s = n || {};
            t.call(this, s), u.call(this, s);
          }
        } }), o2 = S({ "node_modules/remark-footnotes/index.js"(e, r3) {
          I(), r3.exports = g;
          var u = 9, t = 10, a = 32, n = 33, s = 58, c3 = 91, i = 92, D = 93, o = 94, l = 96, d = 4, p = 1024;
          function g(h) {
            var m = this.Parser, C = this.Compiler;
            F(m) && b(m, h), E(C) && f(C);
          }
          function F(h) {
            return Boolean(h && h.prototype && h.prototype.blockTokenizers);
          }
          function E(h) {
            return Boolean(h && h.prototype && h.prototype.visitors);
          }
          function b(h, m) {
            for (var C = m || {}, w = h.prototype, q = w.blockTokenizers, L = w.inlineTokenizers, B = w.blockMethods, O = w.inlineMethods, T = q.definition, P = L.reference, A = [], j = -1, H = B.length, G; ++j < H; ) G = B[j], !(G === "newline" || G === "indentedCode" || G === "paragraph" || G === "footnoteDefinition") && A.push([G]);
            A.push(["footnoteDefinition"]), C.inlineNotes && (x(O, "reference", "inlineNote"), L.inlineNote = J), x(B, "definition", "footnoteDefinition"), x(O, "reference", "footnoteCall"), q.definition = M, q.footnoteDefinition = X, L.footnoteCall = R, L.reference = z, w.interruptFootnoteDefinition = A, z.locator = P.locator, R.locator = U, J.locator = k;
            function X(y, _, N) {
              for (var V = this, W = V.interruptFootnoteDefinition, K = V.offset, ee = _.length + 1, Y = 0, ue = [], le, ce, te, Z, Q, De, ye, fe, he, ae, pe, ne, re; Y < ee && (Z = _.charCodeAt(Y), !(Z !== u && Z !== a)); ) Y++;
              if (_.charCodeAt(Y++) === c3 && _.charCodeAt(Y++) === o) {
                for (ce = Y; Y < ee; ) {
                  if (Z = _.charCodeAt(Y), Z !== Z || Z === t || Z === u || Z === a) return;
                  if (Z === D) {
                    te = Y, Y++;
                    break;
                  }
                  Y++;
                }
                if (!(te === void 0 || ce === te || _.charCodeAt(Y++) !== s)) {
                  if (N) return true;
                  for (le = _.slice(ce, te), Q = y.now(), he = 0, ae = 0, pe = Y, ne = []; Y < ee; ) {
                    if (Z = _.charCodeAt(Y), Z !== Z || Z === t) re = { start: he, contentStart: pe || Y, contentEnd: Y, end: Y }, ne.push(re), Z === t && (he = Y + 1, ae = 0, pe = void 0, re.end = he);
                    else if (ae !== void 0) if (Z === a || Z === u) ae += Z === a ? 1 : d - ae % d, ae > d && (ae = void 0, pe = Y);
                    else {
                      if (ae < d && re && (re.contentStart === re.contentEnd || v(W, q, V, [y, _.slice(Y, p), true]))) break;
                      ae = void 0, pe = Y;
                    }
                    Y++;
                  }
                  for (Y = -1, ee = ne.length; ee > 0 && (re = ne[ee - 1], re.contentStart === re.contentEnd); ) ee--;
                  for (De = y(_.slice(0, re.contentEnd)); ++Y < ee; ) re = ne[Y], K[Q.line + Y] = (K[Q.line + Y] || 0) + (re.contentStart - re.start), ue.push(_.slice(re.contentStart, re.end));
                  return ye = V.enterBlock(), fe = V.tokenizeBlock(ue.join(""), Q), ye(), De({ type: "footnoteDefinition", identifier: le.toLowerCase(), label: le, children: fe });
                }
              }
            }
            function R(y, _, N) {
              var V = _.length + 1, W = 0, K, ee, Y, ue;
              if (_.charCodeAt(W++) === c3 && _.charCodeAt(W++) === o) {
                for (ee = W; W < V; ) {
                  if (ue = _.charCodeAt(W), ue !== ue || ue === t || ue === u || ue === a) return;
                  if (ue === D) {
                    Y = W, W++;
                    break;
                  }
                  W++;
                }
                if (!(Y === void 0 || ee === Y)) return N ? true : (K = _.slice(ee, Y), y(_.slice(0, W))({ type: "footnoteReference", identifier: K.toLowerCase(), label: K }));
              }
            }
            function J(y, _, N) {
              var V = this, W = _.length + 1, K = 0, ee = 0, Y, ue, le, ce, te, Z, Q;
              if (_.charCodeAt(K++) === o && _.charCodeAt(K++) === c3) {
                for (le = K; K < W; ) {
                  if (ue = _.charCodeAt(K), ue !== ue) return;
                  if (Z === void 0) if (ue === i) K += 2;
                  else if (ue === c3) ee++, K++;
                  else if (ue === D) if (ee === 0) {
                    ce = K, K++;
                    break;
                  } else ee--, K++;
                  else if (ue === l) {
                    for (te = K, Z = 1; _.charCodeAt(te + Z) === l; ) Z++;
                    K += Z;
                  } else K++;
                  else if (ue === l) {
                    for (te = K, Q = 1; _.charCodeAt(te + Q) === l; ) Q++;
                    K += Q, Z === Q && (Z = void 0), Q = void 0;
                  } else K++;
                }
                if (ce !== void 0) return N ? true : (Y = y.now(), Y.column += 2, Y.offset += 2, y(_.slice(0, K))({ type: "footnote", children: V.tokenizeInline(_.slice(le, ce), Y) }));
              }
            }
            function z(y, _, N) {
              var V = 0;
              if (_.charCodeAt(V) === n && V++, _.charCodeAt(V) === c3 && _.charCodeAt(V + 1) !== o) return P.call(this, y, _, N);
            }
            function M(y, _, N) {
              for (var V = 0, W = _.charCodeAt(V); W === a || W === u; ) W = _.charCodeAt(++V);
              if (W === c3 && _.charCodeAt(V + 1) !== o) return T.call(this, y, _, N);
            }
            function U(y, _) {
              return y.indexOf("[", _);
            }
            function k(y, _) {
              return y.indexOf("^[", _);
            }
          }
          function f(h) {
            var m = h.prototype.visitors, C = "    ";
            m.footnote = w, m.footnoteReference = q, m.footnoteDefinition = L;
            function w(B) {
              return "^[" + this.all(B).join("") + "]";
            }
            function q(B) {
              return "[^" + (B.label || B.identifier) + "]";
            }
            function L(B) {
              for (var O = this.all(B).join(`

`).split(`
`), T = 0, P = O.length, A; ++T < P; ) A = O[T], A !== "" && (O[T] = C + A);
              return "[^" + (B.label || B.identifier) + "]: " + O.join(`
`);
            }
          }
          function x(h, m, C) {
            h.splice(h.indexOf(m), 0, C);
          }
          function v(h, m, C, w) {
            for (var q = h.length, L = -1; ++L < q; ) if (m[h[L][0]].apply(C, w)) return true;
            return false;
          }
        } }), Ji = S({ "src/utils/front-matter/parse.js"(e, r3) {
          I();
          var u = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function t(a) {
            let n = a.match(u);
            if (!n) return { content: a };
            let { startDelimiter: s, language: c3, value: i = "", endDelimiter: D } = n.groups, o = c3.trim() || "yaml";
            if (s === "+++" && (o = "toml"), o !== "yaml" && s !== D) return { content: a };
            let [l] = n;
            return { frontMatter: { type: "front-matter", lang: o, value: i, startDelimiter: s, endDelimiter: D, raw: l.replace(/\n$/, "") }, content: l.replace(/[^\n]/g, " ") + a.slice(l.length) };
          }
          r3.exports = t;
        } }), s2 = S({ "src/language-markdown/pragma.js"(e, r3) {
          I();
          var u = Ji(), t = ["format", "prettier"];
          function a(n) {
            let s = `@(${t.join("|")})`, c3 = new RegExp([`<!--\\s*${s}\\s*-->`, `{\\s*\\/\\*\\s*${s}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${s}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), i = n.match(c3);
            return (i == null ? void 0 : i.index) === 0;
          }
          r3.exports = { startWithPragma: a, hasPragma: (n) => a(u(n).content.trimStart()), insertPragma: (n) => {
            let s = u(n), c3 = `<!-- @${t[0]} -->`;
            return s.frontMatter ? `${s.frontMatter.raw}

${c3}

${s.content}` : `${c3}

${s.content}`;
          } };
        } }), Zi = S({ "src/language-markdown/loc.js"(e, r3) {
          I();
          function u(a) {
            return a.position.start.offset;
          }
          function t(a) {
            return a.position.end.offset;
          }
          r3.exports = { locStart: u, locEnd: t };
        } }), Qi = S({ "src/language-markdown/mdx.js"(e, r3) {
          I();
          var u = /^import\s/, t = /^export\s/, a = "[a-z][a-z0-9]*(\\.[a-z][a-z0-9]*)*|", n = /<!---->|<!---?[^>-](?:-?[^-])*-->/, s = /^{\s*\/\*(.*)\*\/\s*}/, c3 = `

`, i = (p) => u.test(p), D = (p) => t.test(p), o = (p, g) => {
            let F = g.indexOf(c3), E = g.slice(0, F);
            if (D(E) || i(E)) return p(E)({ type: D(E) ? "export" : "import", value: E });
          }, l = (p, g) => {
            let F = s.exec(g);
            if (F) return p(F[0])({ type: "esComment", value: F[1].trim() });
          };
          o.locator = (p) => D(p) || i(p) ? -1 : 1, l.locator = (p, g) => p.indexOf("{", g);
          function d() {
            let { Parser: p } = this, { blockTokenizers: g, blockMethods: F, inlineTokenizers: E, inlineMethods: b } = p.prototype;
            g.esSyntax = o, E.esComment = l, F.splice(F.indexOf("paragraph"), 0, "esSyntax"), b.splice(b.indexOf("text"), 0, "esComment");
          }
          r3.exports = { esSyntax: d, BLOCKS_REGEX: a, COMMENT_REGEX: n };
        } }), ea = {};
        Pi(ea, { default: () => c2 });
        function c2(e) {
          if (typeof e != "string") throw new TypeError("Expected a string");
          return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var l2 = je({ "node_modules/escape-string-regexp/index.js"() {
          I();
        } }), D2 = S({ "src/utils/get-last.js"(e, r3) {
          I();
          var u = (t) => t[t.length - 1];
          r3.exports = u;
        } }), ra = S({ "node_modules/semver/internal/debug.js"(e, r3) {
          I();
          var u = typeof Qe == "object" && Qe.env && Qe.env.NODE_DEBUG && /\bsemver\b/i.test(Qe.env.NODE_DEBUG) ? function() {
            for (var t = arguments.length, a = new Array(t), n = 0; n < t; n++) a[n] = arguments[n];
            return console.error("SEMVER", ...a);
          } : () => {
          };
          r3.exports = u;
        } }), ua = S({ "node_modules/semver/internal/constants.js"(e, r3) {
          I();
          var u = "2.0.0", t = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
          r3.exports = { SEMVER_SPEC_VERSION: u, MAX_LENGTH: t, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: n };
        } }), f2 = S({ "node_modules/semver/internal/re.js"(e, r3) {
          I();
          var { MAX_SAFE_COMPONENT_LENGTH: u } = ua(), t = ra();
          e = r3.exports = {};
          var a = e.re = [], n = e.src = [], s = e.t = {}, c3 = 0, i = (D, o, l) => {
            let d = c3++;
            t(D, d, o), s[D] = d, n[d] = o, a[d] = new RegExp(o, l ? "g" : void 0);
          };
          i("NUMERICIDENTIFIER", "0|[1-9]\\d*"), i("NUMERICIDENTIFIERLOOSE", "[0-9]+"), i("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), i("MAINVERSION", `(${n[s.NUMERICIDENTIFIER]})\\.(${n[s.NUMERICIDENTIFIER]})\\.(${n[s.NUMERICIDENTIFIER]})`), i("MAINVERSIONLOOSE", `(${n[s.NUMERICIDENTIFIERLOOSE]})\\.(${n[s.NUMERICIDENTIFIERLOOSE]})\\.(${n[s.NUMERICIDENTIFIERLOOSE]})`), i("PRERELEASEIDENTIFIER", `(?:${n[s.NUMERICIDENTIFIER]}|${n[s.NONNUMERICIDENTIFIER]})`), i("PRERELEASEIDENTIFIERLOOSE", `(?:${n[s.NUMERICIDENTIFIERLOOSE]}|${n[s.NONNUMERICIDENTIFIER]})`), i("PRERELEASE", `(?:-(${n[s.PRERELEASEIDENTIFIER]}(?:\\.${n[s.PRERELEASEIDENTIFIER]})*))`), i("PRERELEASELOOSE", `(?:-?(${n[s.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[s.PRERELEASEIDENTIFIERLOOSE]})*))`), i("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), i("BUILD", `(?:\\+(${n[s.BUILDIDENTIFIER]}(?:\\.${n[s.BUILDIDENTIFIER]})*))`), i("FULLPLAIN", `v?${n[s.MAINVERSION]}${n[s.PRERELEASE]}?${n[s.BUILD]}?`), i("FULL", `^${n[s.FULLPLAIN]}$`), i("LOOSEPLAIN", `[v=\\s]*${n[s.MAINVERSIONLOOSE]}${n[s.PRERELEASELOOSE]}?${n[s.BUILD]}?`), i("LOOSE", `^${n[s.LOOSEPLAIN]}$`), i("GTLT", "((?:<|>)?=?)"), i("XRANGEIDENTIFIERLOOSE", `${n[s.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), i("XRANGEIDENTIFIER", `${n[s.NUMERICIDENTIFIER]}|x|X|\\*`), i("XRANGEPLAIN", `[v=\\s]*(${n[s.XRANGEIDENTIFIER]})(?:\\.(${n[s.XRANGEIDENTIFIER]})(?:\\.(${n[s.XRANGEIDENTIFIER]})(?:${n[s.PRERELEASE]})?${n[s.BUILD]}?)?)?`), i("XRANGEPLAINLOOSE", `[v=\\s]*(${n[s.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[s.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[s.XRANGEIDENTIFIERLOOSE]})(?:${n[s.PRERELEASELOOSE]})?${n[s.BUILD]}?)?)?`), i("XRANGE", `^${n[s.GTLT]}\\s*${n[s.XRANGEPLAIN]}$`), i("XRANGELOOSE", `^${n[s.GTLT]}\\s*${n[s.XRANGEPLAINLOOSE]}$`), i("COERCE", `(^|[^\\d])(\\d{1,${u}})(?:\\.(\\d{1,${u}}))?(?:\\.(\\d{1,${u}}))?(?:$|[^\\d])`), i("COERCERTL", n[s.COERCE], true), i("LONETILDE", "(?:~>?)"), i("TILDETRIM", `(\\s*)${n[s.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", i("TILDE", `^${n[s.LONETILDE]}${n[s.XRANGEPLAIN]}$`), i("TILDELOOSE", `^${n[s.LONETILDE]}${n[s.XRANGEPLAINLOOSE]}$`), i("LONECARET", "(?:\\^)"), i("CARETTRIM", `(\\s*)${n[s.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", i("CARET", `^${n[s.LONECARET]}${n[s.XRANGEPLAIN]}$`), i("CARETLOOSE", `^${n[s.LONECARET]}${n[s.XRANGEPLAINLOOSE]}$`), i("COMPARATORLOOSE", `^${n[s.GTLT]}\\s*(${n[s.LOOSEPLAIN]})$|^$`), i("COMPARATOR", `^${n[s.GTLT]}\\s*(${n[s.FULLPLAIN]})$|^$`), i("COMPARATORTRIM", `(\\s*)${n[s.GTLT]}\\s*(${n[s.LOOSEPLAIN]}|${n[s.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", i("HYPHENRANGE", `^\\s*(${n[s.XRANGEPLAIN]})\\s+-\\s+(${n[s.XRANGEPLAIN]})\\s*$`), i("HYPHENRANGELOOSE", `^\\s*(${n[s.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[s.XRANGEPLAINLOOSE]})\\s*$`), i("STAR", "(<|>)?=?\\s*\\*"), i("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), i("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), p2 = S({ "node_modules/semver/internal/parse-options.js"(e, r3) {
          I();
          var u = ["includePrerelease", "loose", "rtl"], t = (a) => a ? typeof a != "object" ? { loose: true } : u.filter((n) => a[n]).reduce((n, s) => (n[s] = true, n), {}) : {};
          r3.exports = t;
        } }), d2 = S({ "node_modules/semver/internal/identifiers.js"(e, r3) {
          I();
          var u = /^[0-9]+$/, t = (n, s) => {
            let c3 = u.test(n), i = u.test(s);
            return c3 && i && (n = +n, s = +s), n === s ? 0 : c3 && !i ? -1 : i && !c3 ? 1 : n < s ? -1 : 1;
          }, a = (n, s) => t(s, n);
          r3.exports = { compareIdentifiers: t, rcompareIdentifiers: a };
        } }), h2 = S({ "node_modules/semver/classes/semver.js"(e, r3) {
          I();
          var u = ra(), { MAX_LENGTH: t, MAX_SAFE_INTEGER: a } = ua(), { re: n, t: s } = f2(), c3 = p2(), { compareIdentifiers: i } = d2(), D = class {
            constructor(o, l) {
              if (l = c3(l), o instanceof D) {
                if (o.loose === !!l.loose && o.includePrerelease === !!l.includePrerelease) return o;
                o = o.version;
              } else if (typeof o != "string") throw new TypeError(`Invalid Version: ${o}`);
              if (o.length > t) throw new TypeError(`version is longer than ${t} characters`);
              u("SemVer", o, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
              let d = o.trim().match(l.loose ? n[s.LOOSE] : n[s.FULL]);
              if (!d) throw new TypeError(`Invalid Version: ${o}`);
              if (this.raw = o, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > a || this.major < 0) throw new TypeError("Invalid major version");
              if (this.minor > a || this.minor < 0) throw new TypeError("Invalid minor version");
              if (this.patch > a || this.patch < 0) throw new TypeError("Invalid patch version");
              d[4] ? this.prerelease = d[4].split(".").map((p) => {
                if (/^[0-9]+$/.test(p)) {
                  let g = +p;
                  if (g >= 0 && g < a) return g;
                }
                return p;
              }) : this.prerelease = [], this.build = d[5] ? d[5].split(".") : [], this.format();
            }
            format() {
              return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
            }
            toString() {
              return this.version;
            }
            compare(o) {
              if (u("SemVer.compare", this.version, this.options, o), !(o instanceof D)) {
                if (typeof o == "string" && o === this.version) return 0;
                o = new D(o, this.options);
              }
              return o.version === this.version ? 0 : this.compareMain(o) || this.comparePre(o);
            }
            compareMain(o) {
              return o instanceof D || (o = new D(o, this.options)), i(this.major, o.major) || i(this.minor, o.minor) || i(this.patch, o.patch);
            }
            comparePre(o) {
              if (o instanceof D || (o = new D(o, this.options)), this.prerelease.length && !o.prerelease.length) return -1;
              if (!this.prerelease.length && o.prerelease.length) return 1;
              if (!this.prerelease.length && !o.prerelease.length) return 0;
              let l = 0;
              do {
                let d = this.prerelease[l], p = o.prerelease[l];
                if (u("prerelease compare", l, d, p), d === void 0 && p === void 0) return 0;
                if (p === void 0) return 1;
                if (d === void 0) return -1;
                if (d === p) continue;
                return i(d, p);
              } while (++l);
            }
            compareBuild(o) {
              o instanceof D || (o = new D(o, this.options));
              let l = 0;
              do {
                let d = this.build[l], p = o.build[l];
                if (u("prerelease compare", l, d, p), d === void 0 && p === void 0) return 0;
                if (p === void 0) return 1;
                if (d === void 0) return -1;
                if (d === p) continue;
                return i(d, p);
              } while (++l);
            }
            inc(o, l) {
              switch (o) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", l), this.inc("pre", l);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", l), this.inc("pre", l);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0) this.prerelease = [0];
                  else {
                    let d = this.prerelease.length;
                    for (; --d >= 0; ) typeof this.prerelease[d] == "number" && (this.prerelease[d]++, d = -2);
                    d === -1 && this.prerelease.push(0);
                  }
                  l && (i(this.prerelease[0], l) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [l, 0]) : this.prerelease = [l, 0]);
                  break;
                default:
                  throw new Error(`invalid increment argument: ${o}`);
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          r3.exports = D;
        } }), Cu = S({ "node_modules/semver/functions/compare.js"(e, r3) {
          I();
          var u = h2(), t = (a, n, s) => new u(a, s).compare(new u(n, s));
          r3.exports = t;
        } }), v2 = S({ "node_modules/semver/functions/lt.js"(e, r3) {
          I();
          var u = Cu(), t = (a, n, s) => u(a, n, s) < 0;
          r3.exports = t;
        } }), m2 = S({ "node_modules/semver/functions/gte.js"(e, r3) {
          I();
          var u = Cu(), t = (a, n, s) => u(a, n, s) >= 0;
          r3.exports = t;
        } }), E2 = S({ "src/utils/arrayify.js"(e, r3) {
          I(), r3.exports = (u, t) => Object.entries(u).map((a) => {
            let [n, s] = a;
            return Object.assign({ [t]: n }, s);
          });
        } }), C2 = S({ "package.json"(e, r3) {
          r3.exports = { version: "2.8.8" };
        } }), g2 = S({ "node_modules/outdent/lib/index.js"(e, r3) {
          I(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
          function u() {
            for (var f = [], x = 0; x < arguments.length; x++) f[x] = arguments[x];
          }
          function t() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
          }
          function a() {
            return { add: u, delete: u, get: u, set: u, has: function(f) {
              return false;
            } };
          }
          var n = Object.prototype.hasOwnProperty, s = function(f, x) {
            return n.call(f, x);
          };
          function c3(f, x) {
            for (var v in x) s(x, v) && (f[v] = x[v]);
            return f;
          }
          var i = /^[ \t]*(?:\r\n|\r|\n)/, D = /(?:\r\n|\r|\n)[ \t]*$/, o = /^(?:[\r\n]|$)/, l = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, d = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function p(f, x, v) {
            var h = 0, m = f[0].match(l);
            m && (h = m[1].length);
            var C = "(\\r\\n|\\r|\\n).{0," + h + "}", w = new RegExp(C, "g");
            x && (f = f.slice(1));
            var q = v.newline, L = v.trimLeadingNewline, B = v.trimTrailingNewline, O = typeof q == "string", T = f.length, P = f.map(function(A, j) {
              return A = A.replace(w, "$1"), j === 0 && L && (A = A.replace(i, "")), j === T - 1 && B && (A = A.replace(D, "")), O && (A = A.replace(/\r\n|\n|\r/g, function(H) {
                return q;
              })), A;
            });
            return P;
          }
          function g(f, x) {
            for (var v = "", h = 0, m = f.length; h < m; h++) v += f[h], h < m - 1 && (v += x[h]);
            return v;
          }
          function F(f) {
            return s(f, "raw") && s(f, "length");
          }
          function E(f) {
            var x = t(), v = t();
            function h(C) {
              for (var w = [], q = 1; q < arguments.length; q++) w[q - 1] = arguments[q];
              if (F(C)) {
                var L = C, B = (w[0] === h || w[0] === b) && d.test(L[0]) && o.test(L[1]), O = B ? v : x, T = O.get(L);
                if (T || (T = p(L, B, f), O.set(L, T)), w.length === 0) return T[0];
                var P = g(T, B ? w.slice(1) : w);
                return P;
              } else return E(c3(c3({}, f), C || {}));
            }
            var m = c3(h, { string: function(C) {
              return p([C], false, f)[0];
            } });
            return m;
          }
          var b = E({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e.outdent = b, e.default = b, typeof r3 < "u") try {
            r3.exports = b, Object.defineProperty(b, "__esModule", { value: true }), b.default = b, b.outdent = b;
          } catch {
          }
        } }), F2 = S({ "src/main/core-options.js"(e, r3) {
          I();
          var { outdent: u } = g2(), t = "Config", a = "Editor", n = "Format", s = "Other", c3 = "Output", i = "Global", D = "Special", o = { cursorOffset: { since: "1.4.0", category: D, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: u`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: i, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: u`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: D, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: s, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: D, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: s }, parser: { since: "0.0.10", category: i, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (l) => typeof l == "string" || typeof l == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: i, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (l) => typeof l == "string" || typeof l == "object", cliName: "plugin", cliCategory: t }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: i, description: u`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (l) => typeof l == "string" || typeof l == "object", cliName: "plugin-search-dir", cliCategory: t }, printWidth: { since: "0.0.0", category: i, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: D, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: u`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: D, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: u`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: D, type: "boolean", default: false, description: u`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: s }, tabWidth: { type: "int", category: i, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: i, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: i, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          r3.exports = { CATEGORY_CONFIG: t, CATEGORY_EDITOR: a, CATEGORY_FORMAT: n, CATEGORY_OTHER: s, CATEGORY_OUTPUT: c3, CATEGORY_GLOBAL: i, CATEGORY_SPECIAL: D, options: o };
        } }), A2 = S({ "src/main/support.js"(e, r3) {
          I();
          var u = { compare: Cu(), lt: v2(), gte: m2() }, t = E2(), a = C2().version, n = F2().options;
          function s() {
            let { plugins: i = [], showUnreleased: D = false, showDeprecated: o = false, showInternal: l = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, d = a.split("-", 1)[0], p = i.flatMap((f) => f.languages || []).filter(F), g = t(Object.assign({}, ...i.map((f) => {
              let { options: x } = f;
              return x;
            }), n), "name").filter((f) => F(f) && E(f)).sort((f, x) => f.name === x.name ? 0 : f.name < x.name ? -1 : 1).map(b).map((f) => {
              f = Object.assign({}, f), Array.isArray(f.default) && (f.default = f.default.length === 1 ? f.default[0].value : f.default.filter(F).sort((v, h) => u.compare(h.since, v.since))[0].value), Array.isArray(f.choices) && (f.choices = f.choices.filter((v) => F(v) && E(v)), f.name === "parser" && c3(f, p, i));
              let x = Object.fromEntries(i.filter((v) => v.defaultOptions && v.defaultOptions[f.name] !== void 0).map((v) => [v.name, v.defaultOptions[f.name]]));
              return Object.assign(Object.assign({}, f), {}, { pluginDefaults: x });
            });
            return { languages: p, options: g };
            function F(f) {
              return D || !("since" in f) || f.since && u.gte(d, f.since);
            }
            function E(f) {
              return o || !("deprecated" in f) || f.deprecated && u.lt(d, f.deprecated);
            }
            function b(f) {
              if (l) return f;
              let { cliName: x, cliCategory: v, cliDescription: h } = f;
              return Ol(f, _l);
            }
          }
          function c3(i, D, o) {
            let l = new Set(i.choices.map((d) => d.value));
            for (let d of D) if (d.parsers) {
              for (let p of d.parsers) if (!l.has(p)) {
                l.add(p);
                let g = o.find((E) => E.parsers && E.parsers[p]), F = d.name;
                g && g.name && (F += ` (plugin: ${g.name})`), i.choices.push({ value: p, description: F });
              }
            }
          }
          r3.exports = { getSupportInfo: s };
        } }), x2 = S({ "src/utils/is-non-empty-array.js"(e, r3) {
          I();
          function u(t) {
            return Array.isArray(t) && t.length > 0;
          }
          r3.exports = u;
        } });
        function b2() {
          let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r3 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(r3, e ? void 0 : "g");
        }
        var y2 = je({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          I();
        } });
        function w2(e) {
          if (typeof e != "string") throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
          return e.replace(b2(), "");
        }
        var B2 = je({ "node_modules/strip-ansi/index.js"() {
          I(), y2();
        } });
        function k2(e) {
          return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
        }
        var q2 = je({ "node_modules/is-fullwidth-code-point/index.js"() {
          I();
        } }), _2 = S({ "node_modules/emoji-regex/index.js"(e, r3) {
          I(), r3.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), ta = {};
        Pi(ta, { default: () => O2 });
        function O2(e) {
          if (typeof e != "string" || e.length === 0 || (e = w2(e), e.length === 0)) return 0;
          e = e.replace((0, na.default)(), "  ");
          let r3 = 0;
          for (let u = 0; u < e.length; u++) {
            let t = e.codePointAt(u);
            t <= 31 || t >= 127 && t <= 159 || t >= 768 && t <= 879 || (t > 65535 && u++, r3 += k2(t) ? 2 : 1);
          }
          return r3;
        }
        var na, I2 = je({ "node_modules/string-width/index.js"() {
          I(), B2(), q2(), na = Rl(_2());
        } }), S2 = S({ "src/utils/get-string-width.js"(e, r3) {
          I();
          var u = (I2(), zi(ta)).default, t = /[^\x20-\x7F]/;
          function a(n) {
            return n ? t.test(n) ? u(n) : n.length : 0;
          }
          r3.exports = a;
        } }), gu = S({ "src/utils/text/skip.js"(e, r3) {
          I();
          function u(c3) {
            return (i, D, o) => {
              let l = o && o.backwards;
              if (D === false) return false;
              let { length: d } = i, p = D;
              for (; p >= 0 && p < d; ) {
                let g = i.charAt(p);
                if (c3 instanceof RegExp) {
                  if (!c3.test(g)) return p;
                } else if (!c3.includes(g)) return p;
                l ? p-- : p++;
              }
              return p === -1 || p === d ? p : false;
            };
          }
          var t = u(/\s/), a = u(" 	"), n = u(",; 	"), s = u(/[^\n\r]/);
          r3.exports = { skipWhitespace: t, skipSpaces: a, skipToLineEnd: n, skipEverythingButNewLine: s };
        } }), ia = S({ "src/utils/text/skip-inline-comment.js"(e, r3) {
          I();
          function u(t, a) {
            if (a === false) return false;
            if (t.charAt(a) === "/" && t.charAt(a + 1) === "*") {
              for (let n = a + 2; n < t.length; ++n) if (t.charAt(n) === "*" && t.charAt(n + 1) === "/") return n + 2;
            }
            return a;
          }
          r3.exports = u;
        } }), aa = S({ "src/utils/text/skip-trailing-comment.js"(e, r3) {
          I();
          var { skipEverythingButNewLine: u } = gu();
          function t(a, n) {
            return n === false ? false : a.charAt(n) === "/" && a.charAt(n + 1) === "/" ? u(a, n) : n;
          }
          r3.exports = t;
        } }), oa = S({ "src/utils/text/skip-newline.js"(e, r3) {
          I();
          function u(t, a, n) {
            let s = n && n.backwards;
            if (a === false) return false;
            let c3 = t.charAt(a);
            if (s) {
              if (t.charAt(a - 1) === "\r" && c3 === `
`) return a - 2;
              if (c3 === `
` || c3 === "\r" || c3 === "\u2028" || c3 === "\u2029") return a - 1;
            } else {
              if (c3 === "\r" && t.charAt(a + 1) === `
`) return a + 2;
              if (c3 === `
` || c3 === "\r" || c3 === "\u2028" || c3 === "\u2029") return a + 1;
            }
            return a;
          }
          r3.exports = u;
        } }), T2 = S({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r3) {
          I();
          var u = ia(), t = oa(), a = aa(), { skipSpaces: n } = gu();
          function s(c3, i) {
            let D = null, o = i;
            for (; o !== D; ) D = o, o = n(c3, o), o = u(c3, o), o = a(c3, o), o = t(c3, o);
            return o;
          }
          r3.exports = s;
        } }), N2 = S({ "src/common/util.js"(e, r3) {
          I();
          var { default: u } = (l2(), zi(ea)), t = D2(), { getSupportInfo: a } = A2(), n = x2(), s = S2(), { skipWhitespace: c3, skipSpaces: i, skipToLineEnd: D, skipEverythingButNewLine: o } = gu(), l = ia(), d = aa(), p = oa(), g = T2(), F = (k) => k[k.length - 2];
          function E(k) {
            return (y, _, N) => {
              let V = N && N.backwards;
              if (_ === false) return false;
              let { length: W } = y, K = _;
              for (; K >= 0 && K < W; ) {
                let ee = y.charAt(K);
                if (k instanceof RegExp) {
                  if (!k.test(ee)) return K;
                } else if (!k.includes(ee)) return K;
                V ? K-- : K++;
              }
              return K === -1 || K === W ? K : false;
            };
          }
          function b(k, y) {
            let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N = i(k, _.backwards ? y - 1 : y, _), V = p(k, N, _);
            return N !== V;
          }
          function f(k, y, _) {
            for (let N = y; N < _; ++N) if (k.charAt(N) === `
`) return true;
            return false;
          }
          function x(k, y, _) {
            let N = _(y) - 1;
            N = i(k, N, { backwards: true }), N = p(k, N, { backwards: true }), N = i(k, N, { backwards: true });
            let V = p(k, N, { backwards: true });
            return N !== V;
          }
          function v(k, y) {
            let _ = null, N = y;
            for (; N !== _; ) _ = N, N = D(k, N), N = l(k, N), N = i(k, N);
            return N = d(k, N), N = p(k, N), N !== false && b(k, N);
          }
          function h(k, y, _) {
            return v(k, _(y));
          }
          function m(k, y, _) {
            return g(k, _(y));
          }
          function C(k, y, _) {
            return k.charAt(m(k, y, _));
          }
          function w(k, y) {
            let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return i(k, _.backwards ? y - 1 : y, _) !== y;
          }
          function q(k, y) {
            let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, N = 0;
            for (let V = _; V < k.length; ++V) k[V] === "	" ? N = N + y - N % y : N++;
            return N;
          }
          function L(k, y) {
            let _ = k.lastIndexOf(`
`);
            return _ === -1 ? 0 : q(k.slice(_ + 1).match(/^[\t ]*/)[0], y);
          }
          function B(k, y) {
            let _ = { quote: '"', regex: /"/g, escaped: "&quot;" }, N = { quote: "'", regex: /'/g, escaped: "&apos;" }, V = y === "'" ? N : _, W = V === N ? _ : N, K = V;
            if (k.includes(V.quote) || k.includes(W.quote)) {
              let ee = (k.match(V.regex) || []).length, Y = (k.match(W.regex) || []).length;
              K = ee > Y ? W : V;
            }
            return K;
          }
          function O(k, y) {
            let _ = k.slice(1, -1), N = y.parser === "json" || y.parser === "json5" && y.quoteProps === "preserve" && !y.singleQuote ? '"' : y.__isInHtmlAttribute ? "'" : B(_, y.singleQuote ? "'" : '"').quote;
            return T(_, N, !(y.parser === "css" || y.parser === "less" || y.parser === "scss" || y.__embeddedInHtml));
          }
          function T(k, y, _) {
            let N = y === '"' ? "'" : '"', V = /\\(.)|(["'])/gs, W = k.replace(V, (K, ee, Y) => ee === N ? ee : Y === y ? "\\" + Y : Y || (_ && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(ee) ? ee : "\\" + ee));
            return y + W + y;
          }
          function P(k) {
            return k.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function A(k, y) {
            let _ = k.match(new RegExp(`(${u(y)})+`, "g"));
            return _ === null ? 0 : _.reduce((N, V) => Math.max(N, V.length / y.length), 0);
          }
          function j(k, y) {
            let _ = k.match(new RegExp(`(${u(y)})+`, "g"));
            if (_ === null) return 0;
            let N = /* @__PURE__ */ new Map(), V = 0;
            for (let W of _) {
              let K = W.length / y.length;
              N.set(K, true), K > V && (V = K);
            }
            for (let W = 1; W < V; W++) if (!N.get(W)) return W;
            return V + 1;
          }
          function H(k, y) {
            (k.comments || (k.comments = [])).push(y), y.printed = false, y.nodeDescription = U(k);
          }
          function G(k, y) {
            y.leading = true, y.trailing = false, H(k, y);
          }
          function X(k, y, _) {
            y.leading = false, y.trailing = false, _ && (y.marker = _), H(k, y);
          }
          function R(k, y) {
            y.leading = false, y.trailing = true, H(k, y);
          }
          function J(k, y) {
            let { languages: _ } = a({ plugins: y.plugins }), N = _.find((V) => {
              let { name: W } = V;
              return W.toLowerCase() === k;
            }) || _.find((V) => {
              let { aliases: W } = V;
              return Array.isArray(W) && W.includes(k);
            }) || _.find((V) => {
              let { extensions: W } = V;
              return Array.isArray(W) && W.includes(`.${k}`);
            });
            return N && N.parsers[0];
          }
          function z(k) {
            return k && k.type === "front-matter";
          }
          function M(k) {
            let y = /* @__PURE__ */ new WeakMap();
            return function(_) {
              return y.has(_) || y.set(_, Symbol(k)), y.get(_);
            };
          }
          function U(k) {
            let y = k.type || k.kind || "(unknown type)", _ = String(k.name || k.id && (typeof k.id == "object" ? k.id.name : k.id) || k.key && (typeof k.key == "object" ? k.key.name : k.key) || k.value && (typeof k.value == "object" ? "" : String(k.value)) || k.operator || "");
            return _.length > 20 && (_ = _.slice(0, 19) + "\u2026"), y + (_ ? " " + _ : "");
          }
          r3.exports = { inferParserByLanguage: J, getStringWidth: s, getMaxContinuousCount: A, getMinNotPresentContinuousCount: j, getPenultimate: F, getLast: t, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: g, getNextNonSpaceNonCommentCharacterIndex: m, getNextNonSpaceNonCommentCharacter: C, skip: E, skipWhitespace: c3, skipSpaces: i, skipToLineEnd: D, skipEverythingButNewLine: o, skipInlineComment: l, skipTrailingComment: d, skipNewline: p, isNextLineEmptyAfterIndex: v, isNextLineEmpty: h, isPreviousLineEmpty: x, hasNewline: b, hasNewlineInRange: f, hasSpaces: w, getAlignmentSize: q, getIndentSize: L, getPreferredQuote: B, printString: O, printNumber: P, makeString: T, addLeadingComment: G, addDanglingComment: X, addTrailingComment: R, isFrontMatterNode: z, isNonEmptyArray: n, createGroupIdMapper: M };
        } }), L2 = S({ "src/language-markdown/constants.evaluate.js"(e, r3) {
          r3.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), R2 = S({ "src/language-markdown/utils.js"(e, r3) {
          I();
          var { getLast: u } = N2(), { locStart: t, locEnd: a } = Zi(), { cjkPattern: n, kPattern: s, punctuationPattern: c3 } = L2(), i = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], D = [...i, "tableCell", "paragraph", "heading"], o = new RegExp(s), l = new RegExp(c3);
          function d(f, x) {
            let v = "non-cjk", h = "cj-letter", m = "k-letter", C = "cjk-punctuation", w = [], q = (x.proseWrap === "preserve" ? f : f.replace(new RegExp(`(${n})
(${n})`, "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [B, O] of q.entries()) {
              if (B % 2 === 1) {
                w.push({ type: "whitespace", value: /\n/.test(O) ? `
` : " " });
                continue;
              }
              if ((B === 0 || B === q.length - 1) && O === "") continue;
              let T = O.split(new RegExp(`(${n})`));
              for (let [P, A] of T.entries()) if (!((P === 0 || P === T.length - 1) && A === "")) {
                if (P % 2 === 0) {
                  A !== "" && L({ type: "word", value: A, kind: v, hasLeadingPunctuation: l.test(A[0]), hasTrailingPunctuation: l.test(u(A)) });
                  continue;
                }
                L(l.test(A) ? { type: "word", value: A, kind: C, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: A, kind: o.test(A) ? m : h, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
              }
            }
            return w;
            function L(B) {
              let O = u(w);
              O && O.type === "word" && (O.kind === v && B.kind === h && !O.hasTrailingPunctuation || O.kind === h && B.kind === v && !B.hasLeadingPunctuation ? w.push({ type: "whitespace", value: " " }) : !T(v, C) && ![O.value, B.value].some((P) => /\u3000/.test(P)) && w.push({ type: "whitespace", value: "" })), w.push(B);
              function T(P, A) {
                return O.kind === P && B.kind === A || O.kind === A && B.kind === P;
              }
            }
          }
          function p(f, x) {
            let [, v, h, m] = x.slice(f.position.start.offset, f.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: v, marker: h, leadingSpaces: m };
          }
          function g(f, x) {
            if (!f.ordered || f.children.length < 2) return false;
            let v = Number(p(f.children[0], x.originalText).numberText), h = Number(p(f.children[1], x.originalText).numberText);
            if (v === 0 && f.children.length > 2) {
              let m = Number(p(f.children[2], x.originalText).numberText);
              return h === 1 && m === 1;
            }
            return h === 1;
          }
          function F(f, x) {
            let { value: v } = f;
            return f.position.end.offset === x.length && v.endsWith(`
`) && x.endsWith(`
`) ? v.slice(0, -1) : v;
          }
          function E(f, x) {
            return (function v(h, m, C) {
              let w = Object.assign({}, x(h, m, C));
              return w.children && (w.children = w.children.map((q, L) => v(q, L, [w, ...C]))), w;
            })(f, null, []);
          }
          function b(f) {
            if ((f == null ? void 0 : f.type) !== "link" || f.children.length !== 1) return false;
            let [x] = f.children;
            return t(f) === t(x) && a(f) === a(x);
          }
          r3.exports = { mapAst: E, splitText: d, punctuationPattern: c3, getFencedCodeBlockValue: F, getOrderedListItemInfo: p, hasGitDiffFriendlyOrderedList: g, INLINE_NODE_TYPES: i, INLINE_NODE_WRAPPER_TYPES: D, isAutolink: b };
        } }), j2 = S({ "src/language-markdown/unified-plugins/html-to-jsx.js"(e, r3) {
          I();
          var u = Qi(), { mapAst: t, INLINE_NODE_WRAPPER_TYPES: a } = R2();
          function n() {
            return (s) => t(s, (c3, i, D) => {
              let [o] = D;
              return c3.type !== "html" || u.COMMENT_REGEX.test(c3.value) || a.includes(o.type) ? c3 : Object.assign(Object.assign({}, c3), {}, { type: "jsx" });
            });
          }
          r3.exports = n;
        } }), P2 = S({ "src/language-markdown/unified-plugins/front-matter.js"(e, r3) {
          I();
          var u = Ji();
          function t() {
            let a = this.Parser.prototype;
            a.blockMethods = ["frontMatter", ...a.blockMethods], a.blockTokenizers.frontMatter = n;
            function n(s, c3) {
              let i = u(c3);
              if (i.frontMatter) return s(i.frontMatter.raw)(i.frontMatter);
            }
            n.onlyAtStart = true;
          }
          r3.exports = t;
        } }), M2 = S({ "src/language-markdown/unified-plugins/liquid.js"(e, r3) {
          I();
          function u() {
            let t = this.Parser.prototype, a = t.inlineMethods;
            a.splice(a.indexOf("text"), 0, "liquid"), t.inlineTokenizers.liquid = n;
            function n(s, c3) {
              let i = c3.match(/^({%.*?%}|{{.*?}})/s);
              if (i) return s(i[0])({ type: "liquidNode", value: i[0] });
            }
            n.locator = function(s, c3) {
              return s.indexOf("{", c3);
            };
          }
          r3.exports = u;
        } }), z2 = S({ "src/language-markdown/unified-plugins/wiki-link.js"(e, r3) {
          I();
          function u() {
            let t = "wikiLink", a = /^\[\[(?<linkContents>.+?)]]/s, n = this.Parser.prototype, s = n.inlineMethods;
            s.splice(s.indexOf("link"), 0, t), n.inlineTokenizers.wikiLink = c3;
            function c3(i, D) {
              let o = a.exec(D);
              if (o) {
                let l = o.groups.linkContents.trim();
                return i(o[0])({ type: t, value: l });
              }
            }
            c3.locator = function(i, D) {
              return i.indexOf("[", D);
            };
          }
          r3.exports = u;
        } }), $2 = S({ "src/language-markdown/unified-plugins/loose-items.js"(e, r3) {
          I();
          function u() {
            let t = this.Parser.prototype, a = t.blockTokenizers.list;
            function n(s, c3, i) {
              return c3.type === "listItem" && (c3.loose = c3.spread || s.charAt(s.length - 1) === `
`, c3.loose && (i.loose = true)), c3;
            }
            t.blockTokenizers.list = function(c3, i, D) {
              function o(l) {
                let d = c3(l);
                function p(g, F) {
                  return d(n(l, g, F), F);
                }
                return p.reset = function(g, F) {
                  return d.reset(n(l, g, F), F);
                }, p;
              }
              return o.now = c3.now, a.call(this, o, i, D);
            };
          }
          r3.exports = u;
        } });
        I();
        var U2 = GD(), G2 = t2(), V2 = a2(), H2 = o2(), X2 = s2(), { locStart: W2, locEnd: K2 } = Zi(), Li = Qi(), Y2 = j2(), J2 = P2(), Z2 = M2(), Q2 = z2(), ef = $2();
        function sa(e) {
          let { isMDX: r3 } = e;
          return (u) => {
            let t = G2().use(U2, Object.assign({ commonmark: true }, r3 && { blocks: [Li.BLOCKS_REGEX] })).use(H2).use(J2).use(V2).use(r3 ? Li.esSyntax : Ri).use(Z2).use(r3 ? Y2 : Ri).use(Q2).use(ef);
            return t.runSync(t.parse(u));
          };
        }
        function Ri(e) {
          return e;
        }
        var ca = { astFormat: "mdast", hasPragma: X2.hasPragma, locStart: W2, locEnd: K2 }, ji = Object.assign(Object.assign({}, ca), {}, { parse: sa({ isMDX: false }) }), rf = Object.assign(Object.assign({}, ca), {}, { parse: sa({ isMDX: true }) });
        la.exports = { parsers: { remark: ji, markdown: ji, mdx: rf } };
      });
      return uf();
    });
  }
});

// ../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/parser-postcss.js
var require_parser_postcss = __commonJS({
  "../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/parser-postcss.js"(exports, module) {
    init_esm_shims();
    (function(e) {
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.postcss = e();
      }
    })(function() {
      var U = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);
      var pe = U((wp, Gt) => {
        var er = function(e) {
          return e && e.Math == Math && e;
        };
        Gt.exports = er(typeof globalThis == "object" && globalThis) || er(typeof window == "object" && window) || er(typeof self == "object" && self) || er(typeof global == "object" && global) || /* @__PURE__ */ (function() {
          return this;
        })() || Function("return this")();
      });
      var be = U((_p, Ht) => {
        Ht.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var Oe = U((bp, Jt) => {
        var _a = be();
        Jt.exports = !_a(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var Tr = U((xp, Kt) => {
        var ba = be();
        Kt.exports = !ba(function() {
          var e = function() {
          }.bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var tr = U((Sp, Qt) => {
        var xa = Tr(), rr = Function.prototype.call;
        Qt.exports = xa ? rr.bind(rr) : function() {
          return rr.apply(rr, arguments);
        };
      });
      var en = U((Zt) => {
        var Yt = {}.propertyIsEnumerable, Xt = Object.getOwnPropertyDescriptor, Sa = Xt && !Yt.call({ 1: 2 }, 1);
        Zt.f = Sa ? function(n) {
          var i = Xt(this, n);
          return !!i && i.enumerable;
        } : Yt;
      });
      var Er = U((Op, rn) => {
        rn.exports = function(e, n) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: n };
        };
      });
      var xe = U((Tp, sn) => {
        var tn = Tr(), nn = Function.prototype, qr = nn.call, ka = tn && nn.bind.bind(qr, qr);
        sn.exports = tn ? ka : function(e) {
          return function() {
            return qr.apply(e, arguments);
          };
        };
      });
      var un = U((Ep, an) => {
        var on = xe(), Oa = on({}.toString), Ta = on("".slice);
        an.exports = function(e) {
          return Ta(Oa(e), 8, -1);
        };
      });
      var ln = U((qp, cn) => {
        var Ea = xe(), qa = be(), Aa = un(), Ar = Object, Pa = Ea("".split);
        cn.exports = qa(function() {
          return !Ar("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return Aa(e) == "String" ? Pa(e, "") : Ar(e);
        } : Ar;
      });
      var Pr = U((Ap, fn) => {
        fn.exports = function(e) {
          return e == null;
        };
      });
      var Ir = U((Pp, pn) => {
        var Ia = Pr(), Ra = TypeError;
        pn.exports = function(e) {
          if (Ia(e)) throw Ra("Can't call method on " + e);
          return e;
        };
      });
      var nr = U((Ip, hn) => {
        var Ca = ln(), Na = Ir();
        hn.exports = function(e) {
          return Ca(Na(e));
        };
      });
      var Cr = U((Rp, dn) => {
        var Rr = typeof document == "object" && document.all, ja = typeof Rr > "u" && Rr !== void 0;
        dn.exports = { all: Rr, IS_HTMLDDA: ja };
      });
      var he = U((Cp, mn) => {
        var vn = Cr(), Ma = vn.all;
        mn.exports = vn.IS_HTMLDDA ? function(e) {
          return typeof e == "function" || e === Ma;
        } : function(e) {
          return typeof e == "function";
        };
      });
      var Me = U((Np, wn) => {
        var gn = he(), yn = Cr(), Da = yn.all;
        wn.exports = yn.IS_HTMLDDA ? function(e) {
          return typeof e == "object" ? e !== null : gn(e) || e === Da;
        } : function(e) {
          return typeof e == "object" ? e !== null : gn(e);
        };
      });
      var ir = U((jp, _n) => {
        var Nr = pe(), La = he(), za = function(e) {
          return La(e) ? e : void 0;
        };
        _n.exports = function(e, n) {
          return arguments.length < 2 ? za(Nr[e]) : Nr[e] && Nr[e][n];
        };
      });
      var xn = U((Mp, bn) => {
        var Ba = xe();
        bn.exports = Ba({}.isPrototypeOf);
      });
      var kn = U((Dp, Sn) => {
        var Fa = ir();
        Sn.exports = Fa("navigator", "userAgent") || "";
      });
      var In = U((Lp, Pn) => {
        var An = pe(), jr = kn(), On = An.process, Tn = An.Deno, En = On && On.versions || Tn && Tn.version, qn = En && En.v8, de, sr;
        qn && (de = qn.split("."), sr = de[0] > 0 && de[0] < 4 ? 1 : +(de[0] + de[1]));
        !sr && jr && (de = jr.match(/Edge\/(\d+)/), (!de || de[1] >= 74) && (de = jr.match(/Chrome\/(\d+)/), de && (sr = +de[1])));
        Pn.exports = sr;
      });
      var Mr = U((zp, Cn) => {
        var Rn = In(), Ua = be();
        Cn.exports = !!Object.getOwnPropertySymbols && !Ua(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Rn && Rn < 41;
        });
      });
      var Dr = U((Bp, Nn) => {
        var $a = Mr();
        Nn.exports = $a && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Lr = U((Fp, jn) => {
        var Wa = ir(), Va = he(), Ga = xn(), Ha = Dr(), Ja = Object;
        jn.exports = Ha ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var n = Wa("Symbol");
          return Va(n) && Ga(n.prototype, Ja(e));
        };
      });
      var Dn = U((Up, Mn) => {
        var Ka = String;
        Mn.exports = function(e) {
          try {
            return Ka(e);
          } catch {
            return "Object";
          }
        };
      });
      var zn = U(($p, Ln) => {
        var Qa = he(), Ya = Dn(), Xa = TypeError;
        Ln.exports = function(e) {
          if (Qa(e)) return e;
          throw Xa(Ya(e) + " is not a function");
        };
      });
      var Fn = U((Wp, Bn) => {
        var Za = zn(), eu = Pr();
        Bn.exports = function(e, n) {
          var i = e[n];
          return eu(i) ? void 0 : Za(i);
        };
      });
      var $n = U((Vp, Un) => {
        var zr = tr(), Br = he(), Fr = Me(), ru = TypeError;
        Un.exports = function(e, n) {
          var i, u;
          if (n === "string" && Br(i = e.toString) && !Fr(u = zr(i, e)) || Br(i = e.valueOf) && !Fr(u = zr(i, e)) || n !== "string" && Br(i = e.toString) && !Fr(u = zr(i, e))) return u;
          throw ru("Can't convert object to primitive value");
        };
      });
      var Vn = U((Gp, Wn) => {
        Wn.exports = false;
      });
      var or = U((Hp, Hn) => {
        var Gn = pe(), tu = Object.defineProperty;
        Hn.exports = function(e, n) {
          try {
            tu(Gn, e, { value: n, configurable: true, writable: true });
          } catch {
            Gn[e] = n;
          }
          return n;
        };
      });
      var ar = U((Jp, Kn) => {
        var nu = pe(), iu = or(), Jn = "__core-js_shared__", su = nu[Jn] || iu(Jn, {});
        Kn.exports = su;
      });
      var Ur = U((Kp, Yn) => {
        var ou = Vn(), Qn = ar();
        (Yn.exports = function(e, n) {
          return Qn[e] || (Qn[e] = n !== void 0 ? n : {});
        })("versions", []).push({ version: "3.26.1", mode: ou ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var Zn = U((Qp, Xn) => {
        var au = Ir(), uu = Object;
        Xn.exports = function(e) {
          return uu(au(e));
        };
      });
      var Te = U((Yp, ei) => {
        var cu = xe(), lu = Zn(), fu = cu({}.hasOwnProperty);
        ei.exports = Object.hasOwn || function(n, i) {
          return fu(lu(n), i);
        };
      });
      var $r = U((Xp, ri) => {
        var pu = xe(), hu = 0, du = Math.random(), vu = pu(1 .toString);
        ri.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + vu(++hu + du, 36);
        };
      });
      var ai = U((Zp, oi) => {
        var mu = pe(), gu = Ur(), ti = Te(), yu = $r(), ni = Mr(), si = Dr(), De = gu("wks"), Ee = mu.Symbol, ii = Ee && Ee.for, wu = si ? Ee : Ee && Ee.withoutSetter || yu;
        oi.exports = function(e) {
          if (!ti(De, e) || !(ni || typeof De[e] == "string")) {
            var n = "Symbol." + e;
            ni && ti(Ee, e) ? De[e] = Ee[e] : si && ii ? De[e] = ii(n) : De[e] = wu(n);
          }
          return De[e];
        };
      });
      var fi = U((eh, li) => {
        var _u = tr(), ui = Me(), ci = Lr(), bu = Fn(), xu = $n(), Su = ai(), ku = TypeError, Ou = Su("toPrimitive");
        li.exports = function(e, n) {
          if (!ui(e) || ci(e)) return e;
          var i = bu(e, Ou), u;
          if (i) {
            if (n === void 0 && (n = "default"), u = _u(i, e, n), !ui(u) || ci(u)) return u;
            throw ku("Can't convert object to primitive value");
          }
          return n === void 0 && (n = "number"), xu(e, n);
        };
      });
      var Wr = U((rh, pi) => {
        var Tu = fi(), Eu = Lr();
        pi.exports = function(e) {
          var n = Tu(e, "string");
          return Eu(n) ? n : n + "";
        };
      });
      var vi = U((th, di) => {
        var qu = pe(), hi = Me(), Vr = qu.document, Au = hi(Vr) && hi(Vr.createElement);
        di.exports = function(e) {
          return Au ? Vr.createElement(e) : {};
        };
      });
      var Gr = U((nh, mi) => {
        var Pu = Oe(), Iu = be(), Ru = vi();
        mi.exports = !Pu && !Iu(function() {
          return Object.defineProperty(Ru("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Hr = U((yi) => {
        var Cu = Oe(), Nu = tr(), ju = en(), Mu = Er(), Du = nr(), Lu = Wr(), zu = Te(), Bu = Gr(), gi = Object.getOwnPropertyDescriptor;
        yi.f = Cu ? gi : function(n, i) {
          if (n = Du(n), i = Lu(i), Bu) try {
            return gi(n, i);
          } catch {
          }
          if (zu(n, i)) return Mu(!Nu(ju.f, n, i), n[i]);
        };
      });
      var _i = U((sh, wi) => {
        var Fu = Oe(), Uu = be();
        wi.exports = Fu && Uu(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Jr = U((oh, bi) => {
        var $u = Me(), Wu = String, Vu = TypeError;
        bi.exports = function(e) {
          if ($u(e)) return e;
          throw Vu(Wu(e) + " is not an object");
        };
      });
      var cr = U((Si) => {
        var Gu = Oe(), Hu = Gr(), Ju = _i(), ur = Jr(), xi = Wr(), Ku = TypeError, Kr = Object.defineProperty, Qu = Object.getOwnPropertyDescriptor, Qr = "enumerable", Yr = "configurable", Xr = "writable";
        Si.f = Gu ? Ju ? function(n, i, u) {
          if (ur(n), i = xi(i), ur(u), typeof n == "function" && i === "prototype" && "value" in u && Xr in u && !u[Xr]) {
            var o = Qu(n, i);
            o && o[Xr] && (n[i] = u.value, u = { configurable: Yr in u ? u[Yr] : o[Yr], enumerable: Qr in u ? u[Qr] : o[Qr], writable: false });
          }
          return Kr(n, i, u);
        } : Kr : function(n, i, u) {
          if (ur(n), i = xi(i), ur(u), Hu) try {
            return Kr(n, i, u);
          } catch {
          }
          if ("get" in u || "set" in u) throw Ku("Accessors not supported");
          return "value" in u && (n[i] = u.value), n;
        };
      });
      var Zr = U((uh, ki) => {
        var Yu = Oe(), Xu = cr(), Zu = Er();
        ki.exports = Yu ? function(e, n, i) {
          return Xu.f(e, n, Zu(1, i));
        } : function(e, n, i) {
          return e[n] = i, e;
        };
      });
      var Ei = U((ch, Ti) => {
        var et = Oe(), ec = Te(), Oi = Function.prototype, rc = et && Object.getOwnPropertyDescriptor, rt = ec(Oi, "name"), tc = rt && function() {
        }.name === "something", nc = rt && (!et || et && rc(Oi, "name").configurable);
        Ti.exports = { EXISTS: rt, PROPER: tc, CONFIGURABLE: nc };
      });
      var Ai = U((lh, qi) => {
        var ic = xe(), sc = he(), tt = ar(), oc = ic(Function.toString);
        sc(tt.inspectSource) || (tt.inspectSource = function(e) {
          return oc(e);
        });
        qi.exports = tt.inspectSource;
      });
      var Ri = U((fh, Ii) => {
        var ac = pe(), uc = he(), Pi = ac.WeakMap;
        Ii.exports = uc(Pi) && /native code/.test(String(Pi));
      });
      var ji = U((ph, Ni) => {
        var cc = Ur(), lc = $r(), Ci = cc("keys");
        Ni.exports = function(e) {
          return Ci[e] || (Ci[e] = lc(e));
        };
      });
      var nt = U((hh, Mi) => {
        Mi.exports = {};
      });
      var Bi = U((dh, zi) => {
        var fc = Ri(), Li = pe(), pc = Me(), hc = Zr(), it = Te(), st = ar(), dc = ji(), vc = nt(), Di = "Object already initialized", ot = Li.TypeError, mc = Li.WeakMap, lr, Fe, fr, gc = function(e) {
          return fr(e) ? Fe(e) : lr(e, {});
        }, yc = function(e) {
          return function(n) {
            var i;
            if (!pc(n) || (i = Fe(n)).type !== e) throw ot("Incompatible receiver, " + e + " required");
            return i;
          };
        };
        fc || st.state ? (ve = st.state || (st.state = new mc()), ve.get = ve.get, ve.has = ve.has, ve.set = ve.set, lr = function(e, n) {
          if (ve.has(e)) throw ot(Di);
          return n.facade = e, ve.set(e, n), n;
        }, Fe = function(e) {
          return ve.get(e) || {};
        }, fr = function(e) {
          return ve.has(e);
        }) : (qe = dc("state"), vc[qe] = true, lr = function(e, n) {
          if (it(e, qe)) throw ot(Di);
          return n.facade = e, hc(e, qe, n), n;
        }, Fe = function(e) {
          return it(e, qe) ? e[qe] : {};
        }, fr = function(e) {
          return it(e, qe);
        });
        var ve, qe;
        zi.exports = { set: lr, get: Fe, has: fr, enforce: gc, getterFor: yc };
      });
      var $i = U((vh, Ui) => {
        var wc = be(), _c = he(), pr = Te(), at = Oe(), bc = Ei().CONFIGURABLE, xc = Ai(), Fi = Bi(), Sc = Fi.enforce, kc = Fi.get, hr = Object.defineProperty, Oc = at && !wc(function() {
          return hr(function() {
          }, "length", { value: 8 }).length !== 8;
        }), Tc = String(String).split("String"), Ec = Ui.exports = function(e, n, i) {
          String(n).slice(0, 7) === "Symbol(" && (n = "[" + String(n).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), i && i.getter && (n = "get " + n), i && i.setter && (n = "set " + n), (!pr(e, "name") || bc && e.name !== n) && (at ? hr(e, "name", { value: n, configurable: true }) : e.name = n), Oc && i && pr(i, "arity") && e.length !== i.arity && hr(e, "length", { value: i.arity });
          try {
            i && pr(i, "constructor") && i.constructor ? at && hr(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
          } catch {
          }
          var u = Sc(e);
          return pr(u, "source") || (u.source = Tc.join(typeof n == "string" ? n : "")), e;
        };
        Function.prototype.toString = Ec(function() {
          return _c(this) && kc(this).source || xc(this);
        }, "toString");
      });
      var Vi = U((mh, Wi) => {
        var qc = he(), Ac = cr(), Pc = $i(), Ic = or();
        Wi.exports = function(e, n, i, u) {
          u || (u = {});
          var o = u.enumerable, h = u.name !== void 0 ? u.name : n;
          if (qc(i) && Pc(i, h, u), u.global) o ? e[n] = i : Ic(n, i);
          else {
            try {
              u.unsafe ? e[n] && (o = true) : delete e[n];
            } catch {
            }
            o ? e[n] = i : Ac.f(e, n, { value: i, enumerable: false, configurable: !u.nonConfigurable, writable: !u.nonWritable });
          }
          return e;
        };
      });
      var Hi = U((gh, Gi) => {
        var Rc = Math.ceil, Cc = Math.floor;
        Gi.exports = Math.trunc || function(n) {
          var i = +n;
          return (i > 0 ? Cc : Rc)(i);
        };
      });
      var ut = U((yh, Ji) => {
        var Nc = Hi();
        Ji.exports = function(e) {
          var n = +e;
          return n !== n || n === 0 ? 0 : Nc(n);
        };
      });
      var Qi = U((wh, Ki) => {
        var jc = ut(), Mc = Math.max, Dc = Math.min;
        Ki.exports = function(e, n) {
          var i = jc(e);
          return i < 0 ? Mc(i + n, 0) : Dc(i, n);
        };
      });
      var Xi = U((_h, Yi) => {
        var Lc = ut(), zc = Math.min;
        Yi.exports = function(e) {
          return e > 0 ? zc(Lc(e), 9007199254740991) : 0;
        };
      });
      var es = U((bh, Zi) => {
        var Bc = Xi();
        Zi.exports = function(e) {
          return Bc(e.length);
        };
      });
      var ns = U((xh, ts) => {
        var Fc = nr(), Uc = Qi(), $c = es(), rs = function(e) {
          return function(n, i, u) {
            var o = Fc(n), h = $c(o), l = Uc(u, h), p;
            if (e && i != i) {
              for (; h > l; ) if (p = o[l++], p != p) return true;
            } else for (; h > l; l++) if ((e || l in o) && o[l] === i) return e || l || 0;
            return !e && -1;
          };
        };
        ts.exports = { includes: rs(true), indexOf: rs(false) };
      });
      var os = U((Sh, ss) => {
        var Wc = xe(), ct = Te(), Vc = nr(), Gc = ns().indexOf, Hc = nt(), is = Wc([].push);
        ss.exports = function(e, n) {
          var i = Vc(e), u = 0, o = [], h;
          for (h in i) !ct(Hc, h) && ct(i, h) && is(o, h);
          for (; n.length > u; ) ct(i, h = n[u++]) && (~Gc(o, h) || is(o, h));
          return o;
        };
      });
      var us = U((kh, as) => {
        as.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var ls = U((cs) => {
        var Jc = os(), Kc = us(), Qc = Kc.concat("length", "prototype");
        cs.f = Object.getOwnPropertyNames || function(n) {
          return Jc(n, Qc);
        };
      });
      var ps = U((fs) => {
        fs.f = Object.getOwnPropertySymbols;
      });
      var ds = U((Eh, hs) => {
        var Yc = ir(), Xc = xe(), Zc = ls(), el = ps(), rl = Jr(), tl = Xc([].concat);
        hs.exports = Yc("Reflect", "ownKeys") || function(n) {
          var i = Zc.f(rl(n)), u = el.f;
          return u ? tl(i, u(n)) : i;
        };
      });
      var gs = U((qh, ms) => {
        var vs = Te(), nl = ds(), il = Hr(), sl = cr();
        ms.exports = function(e, n, i) {
          for (var u = nl(n), o = sl.f, h = il.f, l = 0; l < u.length; l++) {
            var p = u[l];
            !vs(e, p) && !(i && vs(i, p)) && o(e, p, h(n, p));
          }
        };
      });
      var ws = U((Ah, ys) => {
        var ol = be(), al = he(), ul = /#|\.prototype\./, Ue = function(e, n) {
          var i = ll[cl(e)];
          return i == pl ? true : i == fl ? false : al(n) ? ol(n) : !!n;
        }, cl = Ue.normalize = function(e) {
          return String(e).replace(ul, ".").toLowerCase();
        }, ll = Ue.data = {}, fl = Ue.NATIVE = "N", pl = Ue.POLYFILL = "P";
        ys.exports = Ue;
      });
      var bs = U((Ph, _s) => {
        var lt = pe(), hl = Hr().f, dl = Zr(), vl = Vi(), ml = or(), gl = gs(), yl = ws();
        _s.exports = function(e, n) {
          var i = e.target, u = e.global, o = e.stat, h, l, p, m, c2, t;
          if (u ? l = lt : o ? l = lt[i] || ml(i, {}) : l = (lt[i] || {}).prototype, l) for (p in n) {
            if (c2 = n[p], e.dontCallGetSet ? (t = hl(l, p), m = t && t.value) : m = l[p], h = yl(u ? p : i + (o ? "." : "#") + p, e.forced), !h && m !== void 0) {
              if (typeof c2 == typeof m) continue;
              gl(c2, m);
            }
            (e.sham || m && m.sham) && dl(c2, "sham", true), vl(l, p, c2, e);
          }
        };
      });
      var xs = U(() => {
        var wl = bs(), ft = pe();
        wl({ global: true, forced: ft.globalThis !== ft }, { globalThis: ft });
      });
      var Ss = U(() => {
        xs();
      });
      var gp = U((Fh, wa) => {
        Ss();
        var Et = Object.defineProperty, _l = Object.getOwnPropertyDescriptor, qt = Object.getOwnPropertyNames, bl = Object.prototype.hasOwnProperty, Le = (e, n) => function() {
          return e && (n = (0, e[qt(e)[0]])(e = 0)), n;
        }, P = (e, n) => function() {
          return n || (0, e[qt(e)[0]])((n = { exports: {} }).exports, n), n.exports;
        }, At = (e, n) => {
          for (var i in n) Et(e, i, { get: n[i], enumerable: true });
        }, xl = (e, n, i, u) => {
          if (n && typeof n == "object" || typeof n == "function") for (let o of qt(n)) !bl.call(e, o) && o !== i && Et(e, o, { get: () => n[o], enumerable: !(u = _l(n, o)) || u.enumerable });
          return e;
        }, Pt = (e) => xl(Et({}, "__esModule", { value: true }), e), A = Le({ "<define:process>"() {
        } }), Sl = P({ "src/common/parser-create-error.js"(e, n) {
          A();
          function i(u, o) {
            let h = new SyntaxError(u + " (" + o.start.line + ":" + o.start.column + ")");
            return h.loc = o, h;
          }
          n.exports = i;
        } }), Us = P({ "src/utils/get-last.js"(e, n) {
          A();
          var i = (u) => u[u.length - 1];
          n.exports = i;
        } }), $s = P({ "src/utils/front-matter/parse.js"(e, n) {
          A();
          var i = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function u(o) {
            let h = o.match(i);
            if (!h) return { content: o };
            let { startDelimiter: l, language: p, value: m = "", endDelimiter: c2 } = h.groups, t = p.trim() || "yaml";
            if (l === "+++" && (t = "toml"), t !== "yaml" && l !== c2) return { content: o };
            let [r2] = h;
            return { frontMatter: { type: "front-matter", lang: t, value: m, startDelimiter: l, endDelimiter: c2, raw: r2.replace(/\n$/, "") }, content: r2.replace(/[^\n]/g, " ") + o.slice(r2.length) };
          }
          n.exports = u;
        } }), Ws = {};
        At(Ws, { EOL: () => bt, arch: () => kl, cpus: () => Ys, default: () => to, endianness: () => Vs, freemem: () => Ks, getNetworkInterfaces: () => ro, hostname: () => Gs, loadavg: () => Hs, networkInterfaces: () => eo, platform: () => Ol, release: () => Zs, tmpDir: () => wt, tmpdir: () => _t, totalmem: () => Qs, type: () => Xs, uptime: () => Js });
        function Vs() {
          if (typeof dr > "u") {
            var e = new ArrayBuffer(2), n = new Uint8Array(e), i = new Uint16Array(e);
            if (n[0] = 1, n[1] = 2, i[0] === 258) dr = "BE";
            else if (i[0] === 513) dr = "LE";
            else throw new Error("unable to figure out endianess");
          }
          return dr;
        }
        function Gs() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function Hs() {
          return [];
        }
        function Js() {
          return 0;
        }
        function Ks() {
          return Number.MAX_VALUE;
        }
        function Qs() {
          return Number.MAX_VALUE;
        }
        function Ys() {
          return [];
        }
        function Xs() {
          return "Browser";
        }
        function Zs() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function eo() {
        }
        function ro() {
        }
        function kl() {
          return "javascript";
        }
        function Ol() {
          return "browser";
        }
        function wt() {
          return "/tmp";
        }
        var dr, _t, bt, to, Tl = Le({ "node-modules-polyfills:os"() {
          A(), _t = wt, bt = `
`, to = { EOL: bt, tmpdir: _t, tmpDir: wt, networkInterfaces: eo, getNetworkInterfaces: ro, release: Zs, type: Xs, cpus: Ys, totalmem: Qs, freemem: Ks, uptime: Js, loadavg: Hs, hostname: Gs, endianness: Vs };
        } }), El = P({ "node-modules-polyfills-commonjs:os"(e, n) {
          A();
          var i = (Tl(), Pt(Ws));
          if (i && i.default) {
            n.exports = i.default;
            for (let u in i) n.exports[u] = i[u];
          } else i && (n.exports = i);
        } }), ql = P({ "node_modules/detect-newline/index.js"(e, n) {
          A();
          var i = (u) => {
            if (typeof u != "string") throw new TypeError("Expected a string");
            let o = u.match(/(?:\r?\n)/g) || [];
            if (o.length === 0) return;
            let h = o.filter((p) => p === `\r
`).length, l = o.length - h;
            return h > l ? `\r
` : `
`;
          };
          n.exports = i, n.exports.graceful = (u) => typeof u == "string" && i(u) || `
`;
        } }), Al = P({ "node_modules/jest-docblock/build/index.js"(e) {
          A(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = s, e.parse = g, e.parseWithComments = v, e.print = y, e.strip = f;
          function n() {
            let d = El();
            return n = function() {
              return d;
            }, d;
          }
          function i() {
            let d = u(ql());
            return i = function() {
              return d;
            }, d;
          }
          function u(d) {
            return d && d.__esModule ? d : { default: d };
          }
          var o = /\*\/$/, h = /^\/\*\*?/, l = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, p = /(^|\s+)\/\/([^\r\n]*)/g, m = /^(\r?\n)+/, c2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, t = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, r2 = /(\r?\n|^) *\* ?/g, a = [];
          function s(d) {
            let _ = d.match(l);
            return _ ? _[0].trimLeft() : "";
          }
          function f(d) {
            let _ = d.match(l);
            return _ && _[0] ? d.substring(_[0].length) : d;
          }
          function g(d) {
            return v(d).pragmas;
          }
          function v(d) {
            let _ = (0, i().default)(d) || n().EOL;
            d = d.replace(h, "").replace(o, "").replace(r2, "$1");
            let k = "";
            for (; k !== d; ) k = d, d = d.replace(c2, `${_}$1 $2${_}`);
            d = d.replace(m, "").trimRight();
            let x = /* @__PURE__ */ Object.create(null), N = d.replace(t, "").replace(m, "").trimRight(), I;
            for (; I = t.exec(d); ) {
              let W = I[2].replace(p, "");
              typeof x[I[1]] == "string" || Array.isArray(x[I[1]]) ? x[I[1]] = a.concat(x[I[1]], W) : x[I[1]] = W;
            }
            return { comments: N, pragmas: x };
          }
          function y(d) {
            let { comments: _ = "", pragmas: k = {} } = d, x = (0, i().default)(_) || n().EOL, N = "/**", I = " *", W = " */", $ = Object.keys(k), H = $.map((V) => w(V, k[V])).reduce((V, B) => V.concat(B), []).map((V) => `${I} ${V}${x}`).join("");
            if (!_) {
              if ($.length === 0) return "";
              if ($.length === 1 && !Array.isArray(k[$[0]])) {
                let V = k[$[0]];
                return `${N} ${w($[0], V)[0]}${W}`;
              }
            }
            let D = _.split(x).map((V) => `${I} ${V}`).join(x) + x;
            return N + x + (_ ? D : "") + (_ && $.length ? I + x : "") + H + W;
          }
          function w(d, _) {
            return a.concat(_).map((k) => `@${d} ${k}`.trim());
          }
        } }), Pl = P({ "src/common/end-of-line.js"(e, n) {
          A();
          function i(l) {
            let p = l.indexOf("\r");
            return p >= 0 ? l.charAt(p + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function u(l) {
            switch (l) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function o(l, p) {
            let m;
            switch (p) {
              case `
`:
                m = /\n/g;
                break;
              case "\r":
                m = /\r/g;
                break;
              case `\r
`:
                m = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(p)}.`);
            }
            let c2 = l.match(m);
            return c2 ? c2.length : 0;
          }
          function h(l) {
            return l.replace(/\r\n?/g, `
`);
          }
          n.exports = { guessEndOfLine: i, convertEndOfLineToChars: u, countEndOfLineChars: o, normalizeEndOfLine: h };
        } }), Il = P({ "src/language-js/utils/get-shebang.js"(e, n) {
          A();
          function i(u) {
            if (!u.startsWith("#!")) return "";
            let o = u.indexOf(`
`);
            return o === -1 ? u : u.slice(0, o);
          }
          n.exports = i;
        } }), Rl = P({ "src/language-js/pragma.js"(e, n) {
          A();
          var { parseWithComments: i, strip: u, extract: o, print: h } = Al(), { normalizeEndOfLine: l } = Pl(), p = Il();
          function m(r2) {
            let a = p(r2);
            a && (r2 = r2.slice(a.length + 1));
            let s = o(r2), { pragmas: f, comments: g } = i(s);
            return { shebang: a, text: r2, pragmas: f, comments: g };
          }
          function c2(r2) {
            let a = Object.keys(m(r2).pragmas);
            return a.includes("prettier") || a.includes("format");
          }
          function t(r2) {
            let { shebang: a, text: s, pragmas: f, comments: g } = m(r2), v = u(s), y = h({ pragmas: Object.assign({ format: "" }, f), comments: g.trimStart() });
            return (a ? `${a}
` : "") + l(y) + (v.startsWith(`
`) ? `
` : `

`) + v;
          }
          n.exports = { hasPragma: c2, insertPragma: t };
        } }), Cl = P({ "src/language-css/pragma.js"(e, n) {
          A();
          var i = Rl(), u = $s();
          function o(l) {
            return i.hasPragma(u(l).content);
          }
          function h(l) {
            let { frontMatter: p, content: m } = u(l);
            return (p ? p.raw + `

` : "") + i.insertPragma(m);
          }
          n.exports = { hasPragma: o, insertPragma: h };
        } }), Nl = P({ "src/utils/text/skip.js"(e, n) {
          A();
          function i(p) {
            return (m, c2, t) => {
              let r2 = t && t.backwards;
              if (c2 === false) return false;
              let { length: a } = m, s = c2;
              for (; s >= 0 && s < a; ) {
                let f = m.charAt(s);
                if (p instanceof RegExp) {
                  if (!p.test(f)) return s;
                } else if (!p.includes(f)) return s;
                r2 ? s-- : s++;
              }
              return s === -1 || s === a ? s : false;
            };
          }
          var u = i(/\s/), o = i(" 	"), h = i(",; 	"), l = i(/[^\n\r]/);
          n.exports = { skipWhitespace: u, skipSpaces: o, skipToLineEnd: h, skipEverythingButNewLine: l };
        } }), jl = P({ "src/utils/line-column-to-index.js"(e, n) {
          A(), n.exports = function(i, u) {
            let o = 0;
            for (let h = 0; h < i.line - 1; ++h) o = u.indexOf(`
`, o) + 1;
            return o + i.column;
          };
        } }), no = P({ "src/language-css/loc.js"(e, n) {
          A();
          var { skipEverythingButNewLine: i } = Nl(), u = Us(), o = jl();
          function h(s, f) {
            return typeof s.sourceIndex == "number" ? s.sourceIndex : s.source ? o(s.source.start, f) - 1 : null;
          }
          function l(s, f) {
            if (s.type === "css-comment" && s.inline) return i(f, s.source.startOffset);
            let g = s.nodes && u(s.nodes);
            return g && s.source && !s.source.end && (s = g), s.source && s.source.end ? o(s.source.end, f) : null;
          }
          function p(s, f) {
            s.source && (s.source.startOffset = h(s, f), s.source.endOffset = l(s, f));
            for (let g in s) {
              let v = s[g];
              g === "source" || !v || typeof v != "object" || (v.type === "value-root" || v.type === "value-unknown" ? m(v, c2(s), v.text || v.value) : p(v, f));
            }
          }
          function m(s, f, g) {
            s.source && (s.source.startOffset = h(s, g) + f, s.source.endOffset = l(s, g) + f);
            for (let v in s) {
              let y = s[v];
              v === "source" || !y || typeof y != "object" || m(y, f, g);
            }
          }
          function c2(s) {
            let f = s.source.startOffset;
            return typeof s.prop == "string" && (f += s.prop.length), s.type === "css-atrule" && typeof s.name == "string" && (f += 1 + s.name.length + s.raws.afterName.match(/^\s*:?\s*/)[0].length), s.type !== "css-atrule" && s.raws && typeof s.raws.between == "string" && (f += s.raws.between.length), f;
          }
          function t(s) {
            let f = "initial", g = "initial", v, y = false, w = [];
            for (let d = 0; d < s.length; d++) {
              let _ = s[d];
              switch (f) {
                case "initial":
                  if (_ === "'") {
                    f = "single-quotes";
                    continue;
                  }
                  if (_ === '"') {
                    f = "double-quotes";
                    continue;
                  }
                  if ((_ === "u" || _ === "U") && s.slice(d, d + 4).toLowerCase() === "url(") {
                    f = "url", d += 3;
                    continue;
                  }
                  if (_ === "*" && s[d - 1] === "/") {
                    f = "comment-block";
                    continue;
                  }
                  if (_ === "/" && s[d - 1] === "/") {
                    f = "comment-inline", v = d - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (_ === "'" && s[d - 1] !== "\\" && (f = g, g = "initial"), _ === `
` || _ === "\r") return s;
                  continue;
                case "double-quotes":
                  if (_ === '"' && s[d - 1] !== "\\" && (f = g, g = "initial"), _ === `
` || _ === "\r") return s;
                  continue;
                case "url":
                  if (_ === ")" && (f = "initial"), _ === `
` || _ === "\r") return s;
                  if (_ === "'") {
                    f = "single-quotes", g = "url";
                    continue;
                  }
                  if (_ === '"') {
                    f = "double-quotes", g = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  _ === "/" && s[d - 1] === "*" && (f = "initial");
                  continue;
                case "comment-inline":
                  (_ === '"' || _ === "'" || _ === "*") && (y = true), (_ === `
` || _ === "\r") && (y && w.push([v, d]), f = "initial", y = false);
                  continue;
              }
            }
            for (let [d, _] of w) s = s.slice(0, d) + s.slice(d, _).replace(/["'*]/g, " ") + s.slice(_);
            return s;
          }
          function r2(s) {
            return s.source.startOffset;
          }
          function a(s) {
            return s.source.endOffset;
          }
          n.exports = { locStart: r2, locEnd: a, calculateLoc: p, replaceQuotesInInlineComments: t };
        } }), Ml = P({ "src/utils/is-non-empty-array.js"(e, n) {
          A();
          function i(u) {
            return Array.isArray(u) && u.length > 0;
          }
          n.exports = i;
        } }), Dl = P({ "src/language-css/utils/has-scss-interpolation.js"(e, n) {
          A();
          var i = Ml();
          function u(o) {
            if (i(o)) {
              for (let h = o.length - 1; h > 0; h--) if (o[h].type === "word" && o[h].value === "{" && o[h - 1].type === "word" && o[h - 1].value.endsWith("#")) return true;
            }
            return false;
          }
          n.exports = u;
        } }), Ll = P({ "src/language-css/utils/has-string-or-function.js"(e, n) {
          A();
          function i(u) {
            return u.some((o) => o.type === "string" || o.type === "func");
          }
          n.exports = i;
        } }), zl = P({ "src/language-css/utils/is-less-parser.js"(e, n) {
          A();
          function i(u) {
            return u.parser === "css" || u.parser === "less";
          }
          n.exports = i;
        } }), Bl = P({ "src/language-css/utils/is-scss.js"(e, n) {
          A();
          function i(u, o) {
            return u === "less" || u === "scss" ? u === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(o);
          }
          n.exports = i;
        } }), Fl = P({ "src/language-css/utils/is-scss-nested-property-node.js"(e, n) {
          A();
          function i(u) {
            return u.selector ? u.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":") : false;
          }
          n.exports = i;
        } }), Ul = P({ "src/language-css/utils/is-scss-variable.js"(e, n) {
          A();
          function i(u) {
            return Boolean((u == null ? void 0 : u.type) === "word" && u.value.startsWith("$"));
          }
          n.exports = i;
        } }), $l = P({ "src/language-css/utils/stringify-node.js"(e, n) {
          A();
          function i(u) {
            var o, h, l;
            if (u.groups) {
              var p, m, c2;
              let y = ((p = u.open) === null || p === void 0 ? void 0 : p.value) || "", w = u.groups.map((_) => i(_)).join(((m = u.groups[0]) === null || m === void 0 ? void 0 : m.type) === "comma_group" ? "," : ""), d = ((c2 = u.close) === null || c2 === void 0 ? void 0 : c2.value) || "";
              return y + w + d;
            }
            let t = ((o = u.raws) === null || o === void 0 ? void 0 : o.before) || "", r2 = ((h = u.raws) === null || h === void 0 ? void 0 : h.quote) || "", a = u.type === "atword" ? "@" : "", s = u.value || "", f = u.unit || "", g = u.group ? i(u.group) : "", v = ((l = u.raws) === null || l === void 0 ? void 0 : l.after) || "";
            return t + r2 + a + s + r2 + f + g + v;
          }
          n.exports = i;
        } }), Wl = P({ "src/language-css/utils/is-module-rule-name.js"(e, n) {
          A();
          var i = /* @__PURE__ */ new Set(["import", "use", "forward"]);
          function u(o) {
            return i.has(o);
          }
          n.exports = u;
        } }), we = P({ "node_modules/postcss-values-parser/lib/node.js"(e, n) {
          A();
          var i = function(u, o) {
            let h = new u.constructor();
            for (let l in u) {
              if (!u.hasOwnProperty(l)) continue;
              let p = u[l], m = typeof p;
              l === "parent" && m === "object" ? o && (h[l] = o) : l === "source" ? h[l] = p : p instanceof Array ? h[l] = p.map((c2) => i(c2, h)) : l !== "before" && l !== "after" && l !== "between" && l !== "semicolon" && (m === "object" && p !== null && (p = i(p)), h[l] = p);
            }
            return h;
          };
          n.exports = class {
            constructor(o) {
              o = o || {}, this.raws = { before: "", after: "" };
              for (let h in o) this[h] = o[h];
            }
            remove() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }
            toString() {
              return [this.raws.before, String(this.value), this.raws.after].join("");
            }
            clone(o) {
              o = o || {};
              let h = i(this);
              for (let l in o) h[l] = o[l];
              return h;
            }
            cloneBefore(o) {
              o = o || {};
              let h = this.clone(o);
              return this.parent.insertBefore(this, h), h;
            }
            cloneAfter(o) {
              o = o || {};
              let h = this.clone(o);
              return this.parent.insertAfter(this, h), h;
            }
            replaceWith() {
              let o = Array.prototype.slice.call(arguments);
              if (this.parent) {
                for (let h of o) this.parent.insertBefore(this, h);
                this.remove();
              }
              return this;
            }
            moveTo(o) {
              return this.cleanRaws(this.root() === o.root()), this.remove(), o.append(this), this;
            }
            moveBefore(o) {
              return this.cleanRaws(this.root() === o.root()), this.remove(), o.parent.insertBefore(o, this), this;
            }
            moveAfter(o) {
              return this.cleanRaws(this.root() === o.root()), this.remove(), o.parent.insertAfter(o, this), this;
            }
            next() {
              let o = this.parent.index(this);
              return this.parent.nodes[o + 1];
            }
            prev() {
              let o = this.parent.index(this);
              return this.parent.nodes[o - 1];
            }
            toJSON() {
              let o = {};
              for (let h in this) {
                if (!this.hasOwnProperty(h) || h === "parent") continue;
                let l = this[h];
                l instanceof Array ? o[h] = l.map((p) => typeof p == "object" && p.toJSON ? p.toJSON() : p) : typeof l == "object" && l.toJSON ? o[h] = l.toJSON() : o[h] = l;
              }
              return o;
            }
            root() {
              let o = this;
              for (; o.parent; ) o = o.parent;
              return o;
            }
            cleanRaws(o) {
              delete this.raws.before, delete this.raws.after, o || delete this.raws.between;
            }
            positionInside(o) {
              let h = this.toString(), l = this.source.start.column, p = this.source.start.line;
              for (let m = 0; m < o; m++) h[m] === `
` ? (l = 1, p += 1) : l += 1;
              return { line: p, column: l };
            }
            positionBy(o) {
              let h = this.source.start;
              if (Object(o).index) h = this.positionInside(o.index);
              else if (Object(o).word) {
                let l = this.toString().indexOf(o.word);
                l !== -1 && (h = this.positionInside(l));
              }
              return h;
            }
          };
        } }), ae = P({ "node_modules/postcss-values-parser/lib/container.js"(e, n) {
          A();
          var i = we(), u = class extends i {
            constructor(o) {
              super(o), this.nodes || (this.nodes = []);
            }
            push(o) {
              return o.parent = this, this.nodes.push(o), this;
            }
            each(o) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
              let h = this.lastEach, l, p;
              if (this.indexes[h] = 0, !!this.nodes) {
                for (; this.indexes[h] < this.nodes.length && (l = this.indexes[h], p = o(this.nodes[l], l), p !== false); ) this.indexes[h] += 1;
                return delete this.indexes[h], p;
              }
            }
            walk(o) {
              return this.each((h, l) => {
                let p = o(h, l);
                return p !== false && h.walk && (p = h.walk(o)), p;
              });
            }
            walkType(o, h) {
              if (!o || !h) throw new Error("Parameters {type} and {callback} are required.");
              let l = typeof o == "function";
              return this.walk((p, m) => {
                if (l && p instanceof o || !l && p.type === o) return h.call(this, p, m);
              });
            }
            append(o) {
              return o.parent = this, this.nodes.push(o), this;
            }
            prepend(o) {
              return o.parent = this, this.nodes.unshift(o), this;
            }
            cleanRaws(o) {
              if (super.cleanRaws(o), this.nodes) for (let h of this.nodes) h.cleanRaws(o);
            }
            insertAfter(o, h) {
              let l = this.index(o), p;
              this.nodes.splice(l + 1, 0, h);
              for (let m in this.indexes) p = this.indexes[m], l <= p && (this.indexes[m] = p + this.nodes.length);
              return this;
            }
            insertBefore(o, h) {
              let l = this.index(o), p;
              this.nodes.splice(l, 0, h);
              for (let m in this.indexes) p = this.indexes[m], l <= p && (this.indexes[m] = p + this.nodes.length);
              return this;
            }
            removeChild(o) {
              o = this.index(o), this.nodes[o].parent = void 0, this.nodes.splice(o, 1);
              let h;
              for (let l in this.indexes) h = this.indexes[l], h >= o && (this.indexes[l] = h - 1);
              return this;
            }
            removeAll() {
              for (let o of this.nodes) o.parent = void 0;
              return this.nodes = [], this;
            }
            every(o) {
              return this.nodes.every(o);
            }
            some(o) {
              return this.nodes.some(o);
            }
            index(o) {
              return typeof o == "number" ? o : this.nodes.indexOf(o);
            }
            get first() {
              if (this.nodes) return this.nodes[0];
            }
            get last() {
              if (this.nodes) return this.nodes[this.nodes.length - 1];
            }
            toString() {
              let o = this.nodes.map(String).join("");
              return this.value && (o = this.value + o), this.raws.before && (o = this.raws.before + o), this.raws.after && (o += this.raws.after), o;
            }
          };
          u.registerWalker = (o) => {
            let h = "walk" + o.name;
            h.lastIndexOf("s") !== h.length - 1 && (h += "s"), !u.prototype[h] && (u.prototype[h] = function(l) {
              return this.walkType(o, l);
            });
          }, n.exports = u;
        } }), Vl = P({ "node_modules/postcss-values-parser/lib/root.js"(e, n) {
          A();
          var i = ae();
          n.exports = class extends i {
            constructor(o) {
              super(o), this.type = "root";
            }
          };
        } }), io = P({ "node_modules/postcss-values-parser/lib/value.js"(e, n) {
          A();
          var i = ae();
          n.exports = class extends i {
            constructor(o) {
              super(o), this.type = "value", this.unbalanced = 0;
            }
          };
        } }), so = P({ "node_modules/postcss-values-parser/lib/atword.js"(e, n) {
          A();
          var i = ae(), u = class extends i {
            constructor(o) {
              super(o), this.type = "atword";
            }
            toString() {
              this.quoted ? this.raws.quote : "";
              return [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
            }
          };
          i.registerWalker(u), n.exports = u;
        } }), oo = P({ "node_modules/postcss-values-parser/lib/colon.js"(e, n) {
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h) {
              super(h), this.type = "colon";
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), ao = P({ "node_modules/postcss-values-parser/lib/comma.js"(e, n) {
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h) {
              super(h), this.type = "comma";
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), uo = P({ "node_modules/postcss-values-parser/lib/comment.js"(e, n) {
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h) {
              super(h), this.type = "comment", this.inline = Object(h).inline || false;
            }
            toString() {
              return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), co = P({ "node_modules/postcss-values-parser/lib/function.js"(e, n) {
          A();
          var i = ae(), u = class extends i {
            constructor(o) {
              super(o), this.type = "func", this.unbalanced = -1;
            }
          };
          i.registerWalker(u), n.exports = u;
        } }), lo = P({ "node_modules/postcss-values-parser/lib/number.js"(e, n) {
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h) {
              super(h), this.type = "number", this.unit = Object(h).unit || "";
            }
            toString() {
              return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), fo = P({ "node_modules/postcss-values-parser/lib/operator.js"(e, n) {
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h) {
              super(h), this.type = "operator";
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), po = P({ "node_modules/postcss-values-parser/lib/paren.js"(e, n) {
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h) {
              super(h), this.type = "paren", this.parenType = "";
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), ho = P({ "node_modules/postcss-values-parser/lib/string.js"(e, n) {
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h) {
              super(h), this.type = "string";
            }
            toString() {
              let h = this.quoted ? this.raws.quote : "";
              return [this.raws.before, h, this.value + "", h, this.raws.after].join("");
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), vo = P({ "node_modules/postcss-values-parser/lib/word.js"(e, n) {
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h) {
              super(h), this.type = "word";
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), mo = P({ "node_modules/postcss-values-parser/lib/unicode-range.js"(e, n) {
          A();
          var i = ae(), u = we(), o = class extends u {
            constructor(h) {
              super(h), this.type = "unicode-range";
            }
          };
          i.registerWalker(o), n.exports = o;
        } });
        function go2() {
          throw new Error("setTimeout has not been defined");
        }
        function yo() {
          throw new Error("clearTimeout has not been defined");
        }
        function wo(e) {
          if (Se === setTimeout) return setTimeout(e, 0);
          if ((Se === go2 || !Se) && setTimeout) return Se = setTimeout, setTimeout(e, 0);
          try {
            return Se(e, 0);
          } catch {
            try {
              return Se.call(null, e, 0);
            } catch {
              return Se.call(this, e, 0);
            }
          }
        }
        function Gl(e) {
          if (ke === clearTimeout) return clearTimeout(e);
          if ((ke === yo || !ke) && clearTimeout) return ke = clearTimeout, clearTimeout(e);
          try {
            return ke(e);
          } catch {
            try {
              return ke.call(null, e);
            } catch {
              return ke.call(this, e);
            }
          }
        }
        function Hl() {
          !Ne || !Ce || (Ne = false, Ce.length ? me = Ce.concat(me) : We = -1, me.length && _o());
        }
        function _o() {
          if (!Ne) {
            var e = wo(Hl);
            Ne = true;
            for (var n = me.length; n; ) {
              for (Ce = me, me = []; ++We < n; ) Ce && Ce[We].run();
              We = -1, n = me.length;
            }
            Ce = null, Ne = false, Gl(e);
          }
        }
        function Jl(e) {
          var n = new Array(arguments.length - 1);
          if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) n[i - 1] = arguments[i];
          me.push(new bo(e, n)), me.length === 1 && !Ne && wo(_o);
        }
        function bo(e, n) {
          this.fun = e, this.array = n;
        }
        function Ae() {
        }
        function Kl(e) {
          throw new Error("process.binding is not supported");
        }
        function Ql() {
          return "/";
        }
        function Yl(e) {
          throw new Error("process.chdir is not supported");
        }
        function Xl() {
          return 0;
        }
        function Zl(e) {
          var n = xo.call(Ie) * 1e-3, i = Math.floor(n), u = Math.floor(n % 1 * 1e9);
          return e && (i = i - e[0], u = u - e[1], u < 0 && (i--, u += 1e9)), [i, u];
        }
        function ef() {
          var e = /* @__PURE__ */ new Date(), n = e - So;
          return n / 1e3;
        }
        var Se, ke, me, Ne, Ce, We, ks, Os, Ts, Es, qs, As, Ps, Is, Rs, Cs, Ns, js, Ms, Ds, Ls, zs, Ie, xo, So, Bs, Ve, rf = Le({ "node-modules-polyfills:process"() {
          A(), Se = go2, ke = yo, typeof globalThis.setTimeout == "function" && (Se = setTimeout), typeof globalThis.clearTimeout == "function" && (ke = clearTimeout), me = [], Ne = false, We = -1, bo.prototype.run = function() {
            this.fun.apply(null, this.array);
          }, ks = "browser", Os = "browser", Ts = true, Es = {}, qs = [], As = "", Ps = {}, Is = {}, Rs = {}, Cs = Ae, Ns = Ae, js = Ae, Ms = Ae, Ds = Ae, Ls = Ae, zs = Ae, Ie = globalThis.performance || {}, xo = Ie.now || Ie.mozNow || Ie.msNow || Ie.oNow || Ie.webkitNow || function() {
            return (/* @__PURE__ */ new Date()).getTime();
          }, So = /* @__PURE__ */ new Date(), Bs = { nextTick: Jl, title: ks, browser: Ts, env: Es, argv: qs, version: As, versions: Ps, on: Cs, addListener: Ns, once: js, off: Ms, removeListener: Ds, removeAllListeners: Ls, emit: zs, binding: Kl, cwd: Ql, chdir: Yl, umask: Xl, hrtime: Zl, platform: Os, release: Is, config: Rs, uptime: ef }, Ve = Bs;
        } }), pt, It, tf = Le({ "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
          A(), typeof Object.create == "function" ? pt = function(n, i) {
            n.super_ = i, n.prototype = Object.create(i.prototype, { constructor: { value: n, enumerable: false, writable: true, configurable: true } });
          } : pt = function(n, i) {
            n.super_ = i;
            var u = function() {
            };
            u.prototype = i.prototype, n.prototype = new u(), n.prototype.constructor = n;
          }, It = pt;
        } }), ko = {};
        At(ko, { _extend: () => Mt, debuglog: () => Oo, default: () => No, deprecate: () => Rt, format: () => wr, inherits: () => It, inspect: () => ye, isArray: () => Ct, isBoolean: () => _r, isBuffer: () => Ao, isDate: () => gr, isError: () => He, isFunction: () => Je, isNull: () => Ke, isNullOrUndefined: () => To, isNumber: () => Nt, isObject: () => je, isPrimitive: () => qo, isRegExp: () => Ge, isString: () => Qe, isSymbol: () => Eo, isUndefined: () => ge, log: () => Po });
        function wr(e) {
          if (!Qe(e)) {
            for (var n = [], i = 0; i < arguments.length; i++) n.push(ye(arguments[i]));
            return n.join(" ");
          }
          for (var i = 1, u = arguments, o = u.length, h = String(e).replace(Ro, function(p) {
            if (p === "%%") return "%";
            if (i >= o) return p;
            switch (p) {
              case "%s":
                return String(u[i++]);
              case "%d":
                return Number(u[i++]);
              case "%j":
                try {
                  return JSON.stringify(u[i++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return p;
            }
          }), l = u[i]; i < o; l = u[++i]) Ke(l) || !je(l) ? h += " " + l : h += " " + ye(l);
          return h;
        }
        function Rt(e, n) {
          if (ge(globalThis.process)) return function() {
            return Rt(e, n).apply(this, arguments);
          };
          if (Ve.noDeprecation === true) return e;
          var i = false;
          function u() {
            if (!i) {
              if (Ve.throwDeprecation) throw new Error(n);
              Ve.traceDeprecation ? console.trace(n) : console.error(n), i = true;
            }
            return e.apply(this, arguments);
          }
          return u;
        }
        function Oo(e) {
          if (ge(vt) && (vt = Ve.env.NODE_DEBUG || ""), e = e.toUpperCase(), !$e[e]) if (new RegExp("\\b" + e + "\\b", "i").test(vt)) {
            var n = 0;
            $e[e] = function() {
              var i = wr.apply(null, arguments);
              console.error("%s %d: %s", e, n, i);
            };
          } else $e[e] = function() {
          };
          return $e[e];
        }
        function ye(e, n) {
          var i = { seen: [], stylize: sf };
          return arguments.length >= 3 && (i.depth = arguments[2]), arguments.length >= 4 && (i.colors = arguments[3]), _r(n) ? i.showHidden = n : n && Mt(i, n), ge(i.showHidden) && (i.showHidden = false), ge(i.depth) && (i.depth = 2), ge(i.colors) && (i.colors = false), ge(i.customInspect) && (i.customInspect = true), i.colors && (i.stylize = nf), mr(i, e, i.depth);
        }
        function nf(e, n) {
          var i = ye.styles[n];
          return i ? "\x1B[" + ye.colors[i][0] + "m" + e + "\x1B[" + ye.colors[i][1] + "m" : e;
        }
        function sf(e, n) {
          return e;
        }
        function of(e) {
          var n = {};
          return e.forEach(function(i, u) {
            n[i] = true;
          }), n;
        }
        function mr(e, n, i) {
          if (e.customInspect && n && Je(n.inspect) && n.inspect !== ye && !(n.constructor && n.constructor.prototype === n)) {
            var u = n.inspect(i, e);
            return Qe(u) || (u = mr(e, u, i)), u;
          }
          var o = af(e, n);
          if (o) return o;
          var h = Object.keys(n), l = of(h);
          if (e.showHidden && (h = Object.getOwnPropertyNames(n)), He(n) && (h.indexOf("message") >= 0 || h.indexOf("description") >= 0)) return ht(n);
          if (h.length === 0) {
            if (Je(n)) {
              var p = n.name ? ": " + n.name : "";
              return e.stylize("[Function" + p + "]", "special");
            }
            if (Ge(n)) return e.stylize(RegExp.prototype.toString.call(n), "regexp");
            if (gr(n)) return e.stylize(Date.prototype.toString.call(n), "date");
            if (He(n)) return ht(n);
          }
          var m = "", c2 = false, t = ["{", "}"];
          if (Ct(n) && (c2 = true, t = ["[", "]"]), Je(n)) {
            var r2 = n.name ? ": " + n.name : "";
            m = " [Function" + r2 + "]";
          }
          if (Ge(n) && (m = " " + RegExp.prototype.toString.call(n)), gr(n) && (m = " " + Date.prototype.toUTCString.call(n)), He(n) && (m = " " + ht(n)), h.length === 0 && (!c2 || n.length == 0)) return t[0] + m + t[1];
          if (i < 0) return Ge(n) ? e.stylize(RegExp.prototype.toString.call(n), "regexp") : e.stylize("[Object]", "special");
          e.seen.push(n);
          var a;
          return c2 ? a = uf(e, n, i, l, h) : a = h.map(function(s) {
            return xt(e, n, i, l, s, c2);
          }), e.seen.pop(), cf(a, m, t);
        }
        function af(e, n) {
          if (ge(n)) return e.stylize("undefined", "undefined");
          if (Qe(n)) {
            var i = "'" + JSON.stringify(n).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e.stylize(i, "string");
          }
          if (Nt(n)) return e.stylize("" + n, "number");
          if (_r(n)) return e.stylize("" + n, "boolean");
          if (Ke(n)) return e.stylize("null", "null");
        }
        function ht(e) {
          return "[" + Error.prototype.toString.call(e) + "]";
        }
        function uf(e, n, i, u, o) {
          for (var h = [], l = 0, p = n.length; l < p; ++l) Io(n, String(l)) ? h.push(xt(e, n, i, u, String(l), true)) : h.push("");
          return o.forEach(function(m) {
            m.match(/^\d+$/) || h.push(xt(e, n, i, u, m, true));
          }), h;
        }
        function xt(e, n, i, u, o, h) {
          var l, p, m;
          if (m = Object.getOwnPropertyDescriptor(n, o) || { value: n[o] }, m.get ? m.set ? p = e.stylize("[Getter/Setter]", "special") : p = e.stylize("[Getter]", "special") : m.set && (p = e.stylize("[Setter]", "special")), Io(u, o) || (l = "[" + o + "]"), p || (e.seen.indexOf(m.value) < 0 ? (Ke(i) ? p = mr(e, m.value, null) : p = mr(e, m.value, i - 1), p.indexOf(`
`) > -1 && (h ? p = p.split(`
`).map(function(c2) {
            return "  " + c2;
          }).join(`
`).substr(2) : p = `
` + p.split(`
`).map(function(c2) {
            return "   " + c2;
          }).join(`
`))) : p = e.stylize("[Circular]", "special")), ge(l)) {
            if (h && o.match(/^\d+$/)) return p;
            l = JSON.stringify("" + o), l.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (l = l.substr(1, l.length - 2), l = e.stylize(l, "name")) : (l = l.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), l = e.stylize(l, "string"));
          }
          return l + ": " + p;
        }
        function cf(e, n, i) {
          var u = 0, o = e.reduce(function(h, l) {
            return u++, l.indexOf(`
`) >= 0 && u++, h + l.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return o > 60 ? i[0] + (n === "" ? "" : n + `
 `) + " " + e.join(`,
  `) + " " + i[1] : i[0] + n + " " + e.join(", ") + " " + i[1];
        }
        function Ct(e) {
          return Array.isArray(e);
        }
        function _r(e) {
          return typeof e == "boolean";
        }
        function Ke(e) {
          return e === null;
        }
        function To(e) {
          return e == null;
        }
        function Nt(e) {
          return typeof e == "number";
        }
        function Qe(e) {
          return typeof e == "string";
        }
        function Eo(e) {
          return typeof e == "symbol";
        }
        function ge(e) {
          return e === void 0;
        }
        function Ge(e) {
          return je(e) && jt(e) === "[object RegExp]";
        }
        function je(e) {
          return typeof e == "object" && e !== null;
        }
        function gr(e) {
          return je(e) && jt(e) === "[object Date]";
        }
        function He(e) {
          return je(e) && (jt(e) === "[object Error]" || e instanceof Error);
        }
        function Je(e) {
          return typeof e == "function";
        }
        function qo(e) {
          return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || typeof e > "u";
        }
        function Ao(e) {
          return Buffer.isBuffer(e);
        }
        function jt(e) {
          return Object.prototype.toString.call(e);
        }
        function dt(e) {
          return e < 10 ? "0" + e.toString(10) : e.toString(10);
        }
        function lf() {
          var e = /* @__PURE__ */ new Date(), n = [dt(e.getHours()), dt(e.getMinutes()), dt(e.getSeconds())].join(":");
          return [e.getDate(), Co[e.getMonth()], n].join(" ");
        }
        function Po() {
          console.log("%s - %s", lf(), wr.apply(null, arguments));
        }
        function Mt(e, n) {
          if (!n || !je(n)) return e;
          for (var i = Object.keys(n), u = i.length; u--; ) e[i[u]] = n[i[u]];
          return e;
        }
        function Io(e, n) {
          return Object.prototype.hasOwnProperty.call(e, n);
        }
        var Ro, $e, vt, Co, No, ff = Le({ "node-modules-polyfills:util"() {
          A(), rf(), tf(), Ro = /%[sdj%]/g, $e = {}, ye.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, ye.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, Co = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], No = { inherits: It, _extend: Mt, log: Po, isBuffer: Ao, isPrimitive: qo, isFunction: Je, isError: He, isDate: gr, isObject: je, isRegExp: Ge, isUndefined: ge, isSymbol: Eo, isString: Qe, isNumber: Nt, isNullOrUndefined: To, isNull: Ke, isBoolean: _r, isArray: Ct, inspect: ye, deprecate: Rt, format: wr, debuglog: Oo };
        } }), pf = P({ "node-modules-polyfills-commonjs:util"(e, n) {
          A();
          var i = (ff(), Pt(ko));
          if (i && i.default) {
            n.exports = i.default;
            for (let u in i) n.exports[u] = i[u];
          } else i && (n.exports = i);
        } }), hf = P({ "node_modules/postcss-values-parser/lib/errors/TokenizeError.js"(e, n) {
          A();
          var i = class extends Error {
            constructor(u) {
              super(u), this.name = this.constructor.name, this.message = u || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(u).stack;
            }
          };
          n.exports = i;
        } }), df = P({ "node_modules/postcss-values-parser/lib/tokenize.js"(e, n) {
          A();
          var i = "{".charCodeAt(0), u = "}".charCodeAt(0), o = "(".charCodeAt(0), h = ")".charCodeAt(0), l = "'".charCodeAt(0), p = '"'.charCodeAt(0), m = "\\".charCodeAt(0), c2 = "/".charCodeAt(0), t = ".".charCodeAt(0), r2 = ",".charCodeAt(0), a = ":".charCodeAt(0), s = "*".charCodeAt(0), f = "-".charCodeAt(0), g = "+".charCodeAt(0), v = "#".charCodeAt(0), y = `
`.charCodeAt(0), w = " ".charCodeAt(0), d = "\f".charCodeAt(0), _ = "	".charCodeAt(0), k = "\r".charCodeAt(0), x = "@".charCodeAt(0), N = "e".charCodeAt(0), I = "E".charCodeAt(0), W = "0".charCodeAt(0), $ = "9".charCodeAt(0), H = "u".charCodeAt(0), D = "U".charCodeAt(0), V = /[ \n\t\r\{\(\)'"\\;,/]/g, B = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, O = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, j = /^[a-z0-9]/i, C = /^[a-f0-9?\-]/i, R = pf(), X = hf();
          n.exports = function(Q, K) {
            K = K || {};
            let J = [], M = Q.valueOf(), Y = M.length, G = -1, E = 1, S = 0, b = 0, L = null, q, T, F, z, ee, te, le, re, ne, oe, ie;
            function ce(Ze) {
              let _e = R.format("Unclosed %s at line: %d, column: %d, token: %d", Ze, E, S - G, S);
              throw new X(_e);
            }
            for (; S < Y; ) {
              switch (q = M.charCodeAt(S), q === y && (G = S, E += 1), q) {
                case y:
                case w:
                case _:
                case k:
                case d:
                  T = S;
                  do
                    T += 1, q = M.charCodeAt(T), q === y && (G = T, E += 1);
                  while (q === w || q === y || q === _ || q === k || q === d);
                  J.push(["space", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  break;
                case a:
                  T = S + 1, J.push(["colon", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  break;
                case r2:
                  T = S + 1, J.push(["comma", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  break;
                case i:
                  J.push(["{", "{", E, S - G, E, T - G, S]);
                  break;
                case u:
                  J.push(["}", "}", E, S - G, E, T - G, S]);
                  break;
                case o:
                  b++, L = !L && b === 1 && J.length > 0 && J[J.length - 1][0] === "word" && J[J.length - 1][1] === "url", J.push(["(", "(", E, S - G, E, T - G, S]);
                  break;
                case h:
                  b--, L = L && b > 0, J.push([")", ")", E, S - G, E, T - G, S]);
                  break;
                case l:
                case p:
                  F = q === l ? "'" : '"', T = S;
                  do
                    for (ne = false, T = M.indexOf(F, T + 1), T === -1 && ce("quote"), oe = T; M.charCodeAt(oe - 1) === m; ) oe -= 1, ne = !ne;
                  while (ne);
                  J.push(["string", M.slice(S, T + 1), E, S - G, E, T - G, S]), S = T;
                  break;
                case x:
                  V.lastIndex = S + 1, V.test(M), V.lastIndex === 0 ? T = M.length - 1 : T = V.lastIndex - 2, J.push(["atword", M.slice(S, T + 1), E, S - G, E, T - G, S]), S = T;
                  break;
                case m:
                  T = S, q = M.charCodeAt(T + 1), J.push(["word", M.slice(S, T + 1), E, S - G, E, T - G, S]), S = T;
                  break;
                case g:
                case f:
                case s:
                  T = S + 1, ie = M.slice(S + 1, T + 1);
                  M.slice(S - 1, S);
                  if (q === f && ie.charCodeAt(0) === f) {
                    T++, J.push(["word", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                    break;
                  }
                  J.push(["operator", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  break;
                default:
                  if (q === c2 && (M.charCodeAt(S + 1) === s || K.loose && !L && M.charCodeAt(S + 1) === c2)) {
                    if (M.charCodeAt(S + 1) === s) T = M.indexOf("*/", S + 2) + 1, T === 0 && ce("comment");
                    else {
                      let Be = M.indexOf(`
`, S + 2);
                      T = Be !== -1 ? Be - 1 : Y;
                    }
                    te = M.slice(S, T + 1), z = te.split(`
`), ee = z.length - 1, ee > 0 ? (le = E + ee, re = T - z[ee].length) : (le = E, re = G), J.push(["comment", te, E, S - G, le, T - re, S]), G = re, E = le, S = T;
                  } else if (q === v && !j.test(M.slice(S + 1, S + 2))) T = S + 1, J.push(["#", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  else if ((q === H || q === D) && M.charCodeAt(S + 1) === g) {
                    T = S + 2;
                    do
                      T += 1, q = M.charCodeAt(T);
                    while (T < Y && C.test(M.slice(T, T + 1)));
                    J.push(["unicoderange", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  } else if (q === c2) T = S + 1, J.push(["operator", M.slice(S, T), E, S - G, E, T - G, S]), S = T - 1;
                  else {
                    let _e = B;
                    if (q >= W && q <= $ && (_e = O), _e.lastIndex = S + 1, _e.test(M), _e.lastIndex === 0 ? T = M.length - 1 : T = _e.lastIndex - 2, _e === O || q === t) {
                      let Be = M.charCodeAt(T), Wt = M.charCodeAt(T + 1), Vt = M.charCodeAt(T + 2);
                      (Be === N || Be === I) && (Wt === f || Wt === g) && Vt >= W && Vt <= $ && (O.lastIndex = T + 2, O.test(M), O.lastIndex === 0 ? T = M.length - 1 : T = O.lastIndex - 2);
                    }
                    J.push(["word", M.slice(S, T + 1), E, S - G, E, T - G, S]), S = T;
                  }
                  break;
              }
              S++;
            }
            return J;
          };
        } }), jo = P({ "node_modules/flatten/index.js"(e, n) {
          A(), n.exports = function(u, o) {
            if (o = typeof o == "number" ? o : 1 / 0, !o) return Array.isArray(u) ? u.map(function(l) {
              return l;
            }) : u;
            return h(u, 1);
            function h(l, p) {
              return l.reduce(function(m, c2) {
                return Array.isArray(c2) && p < o ? m.concat(h(c2, p + 1)) : m.concat(c2);
              }, []);
            }
          };
        } }), Mo = P({ "node_modules/indexes-of/index.js"(e, n) {
          A(), n.exports = function(i, u) {
            for (var o = -1, h = []; (o = i.indexOf(u, o + 1)) !== -1; ) h.push(o);
            return h;
          };
        } }), Do = P({ "node_modules/uniq/uniq.js"(e, n) {
          A();
          function i(h, l) {
            for (var p = 1, m = h.length, c2 = h[0], t = h[0], r2 = 1; r2 < m; ++r2) if (t = c2, c2 = h[r2], l(c2, t)) {
              if (r2 === p) {
                p++;
                continue;
              }
              h[p++] = c2;
            }
            return h.length = p, h;
          }
          function u(h) {
            for (var l = 1, p = h.length, m = h[0], c2 = h[0], t = 1; t < p; ++t, c2 = m) if (c2 = m, m = h[t], m !== c2) {
              if (t === l) {
                l++;
                continue;
              }
              h[l++] = m;
            }
            return h.length = l, h;
          }
          function o(h, l, p) {
            return h.length === 0 ? h : l ? (p || h.sort(l), i(h, l)) : (p || h.sort(), u(h));
          }
          n.exports = o;
        } }), vf = P({ "node_modules/postcss-values-parser/lib/errors/ParserError.js"(e, n) {
          A();
          var i = class extends Error {
            constructor(u) {
              super(u), this.name = this.constructor.name, this.message = u || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(u).stack;
            }
          };
          n.exports = i;
        } }), mf = P({ "node_modules/postcss-values-parser/lib/parser.js"(e, n) {
          A();
          var i = Vl(), u = io(), o = so(), h = oo(), l = ao(), p = uo(), m = co(), c2 = lo(), t = fo(), r2 = po(), a = ho(), s = vo(), f = mo(), g = df(), v = jo(), y = Mo(), w = Do(), d = vf();
          function _(k) {
            return k.sort((x, N) => x - N);
          }
          n.exports = class {
            constructor(x, N) {
              let I = { loose: false };
              this.cache = [], this.input = x, this.options = Object.assign({}, I, N), this.position = 0, this.unbalanced = 0, this.root = new i();
              let W = new u();
              this.root.append(W), this.current = W, this.tokens = g(x, this.options);
            }
            parse() {
              return this.loop();
            }
            colon() {
              let x = this.currToken;
              this.newNode(new h({ value: x[1], source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6] })), this.position++;
            }
            comma() {
              let x = this.currToken;
              this.newNode(new l({ value: x[1], source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6] })), this.position++;
            }
            comment() {
              let x = false, N = this.currToken[1].replace(/\/\*|\*\//g, ""), I;
              this.options.loose && N.startsWith("//") && (N = N.substring(2), x = true), I = new p({ value: N, inline: x, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(I), this.position++;
            }
            error(x, N) {
              throw new d(x + ` at line: ${N[2]}, column ${N[3]}`);
            }
            loop() {
              for (; this.position < this.tokens.length; ) this.parseTokens();
              return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
            }
            operator() {
              let x = this.currToken[1], N;
              if (x === "+" || x === "-") {
                if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
                  if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word") return this.word();
                } else if (this.nextToken[0] === "word") return this.word();
              }
              return N = new t({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(N);
            }
            parseTokens() {
              switch (this.currToken[0]) {
                case "space":
                  this.space();
                  break;
                case "colon":
                  this.colon();
                  break;
                case "comma":
                  this.comma();
                  break;
                case "comment":
                  this.comment();
                  break;
                case "(":
                  this.parenOpen();
                  break;
                case ")":
                  this.parenClose();
                  break;
                case "atword":
                case "word":
                  this.word();
                  break;
                case "operator":
                  this.operator();
                  break;
                case "string":
                  this.string();
                  break;
                case "unicoderange":
                  this.unicodeRange();
                  break;
                default:
                  this.word();
                  break;
              }
            }
            parenOpen() {
              let x = 1, N = this.position + 1, I = this.currToken, W;
              for (; N < this.tokens.length && x; ) {
                let $ = this.tokens[N];
                $[0] === "(" && x++, $[0] === ")" && x--, N++;
              }
              if (x && this.error("Expected closing parenthesis", I), W = this.current.last, W && W.type === "func" && W.unbalanced < 0 && (W.unbalanced = 0, this.current = W), this.current.unbalanced++, this.newNode(new r2({ value: I[1], source: { start: { line: I[2], column: I[3] }, end: { line: I[4], column: I[5] } }, sourceIndex: I[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
                let $ = this.nextToken, H = this.currToken[1], D = { line: this.currToken[2], column: this.currToken[3] };
                for (; $ && $[0] !== ")" && this.current.unbalanced; ) this.position++, H += this.currToken[1], $ = this.nextToken;
                this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new s({ value: H, source: { start: D, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
              }
            }
            parenClose() {
              let x = this.currToken;
              this.newNode(new r2({ value: x[1], source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", x), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
            }
            space() {
              let x = this.currToken;
              this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += x[1], this.position++) : (this.spaces = x[1], this.position++);
            }
            unicodeRange() {
              let x = this.currToken;
              this.newNode(new f({ value: x[1], source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6] })), this.position++;
            }
            splitWord() {
              let x = this.nextToken, N = this.currToken[1], I = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, W = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, $, H;
              if (!W.test(N)) for (; x && x[0] === "word"; ) {
                this.position++;
                let D = this.currToken[1];
                N += D, x = this.nextToken;
              }
              $ = y(N, "@"), H = _(w(v([[0], $]))), H.forEach((D, V) => {
                let B = H[V + 1] || N.length, O = N.slice(D, B), j;
                if (~$.indexOf(D)) j = new o({ value: O.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + D }, end: { line: this.currToken[4], column: this.currToken[3] + (B - 1) } }, sourceIndex: this.currToken[6] + H[V] });
                else if (I.test(this.currToken[1])) {
                  let C = O.replace(I, "");
                  j = new c2({ value: O.replace(C, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + D }, end: { line: this.currToken[4], column: this.currToken[3] + (B - 1) } }, sourceIndex: this.currToken[6] + H[V], unit: C });
                } else j = new (x && x[0] === "(" ? m : s)({ value: O, source: { start: { line: this.currToken[2], column: this.currToken[3] + D }, end: { line: this.currToken[4], column: this.currToken[3] + (B - 1) } }, sourceIndex: this.currToken[6] + H[V] }), j.type === "word" ? (j.isHex = /^#(.+)/.test(O), j.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(O)) : this.cache.push(this.current);
                this.newNode(j);
              }), this.position++;
            }
            string() {
              let x = this.currToken, N = this.currToken[1], I = /^(\"|\')/, W = I.test(N), $ = "", H;
              W && ($ = N.match(I)[0], N = N.slice(1, N.length - 1)), H = new a({ value: N, source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6], quoted: W }), H.raws.quote = $, this.newNode(H), this.position++;
            }
            word() {
              return this.splitWord();
            }
            newNode(x) {
              return this.spaces && (x.raws.before += this.spaces, this.spaces = ""), this.current.append(x);
            }
            get currToken() {
              return this.tokens[this.position];
            }
            get nextToken() {
              return this.tokens[this.position + 1];
            }
            get prevToken() {
              return this.tokens[this.position - 1];
            }
          };
        } }), gf = P({ "node_modules/postcss-values-parser/lib/index.js"(e, n) {
          A();
          var i = mf(), u = so(), o = oo(), h = ao(), l = uo(), p = co(), m = lo(), c2 = fo(), t = po(), r2 = ho(), a = mo(), s = io(), f = vo(), g = function(v, y) {
            return new i(v, y);
          };
          g.atword = function(v) {
            return new u(v);
          }, g.colon = function(v) {
            return new o(Object.assign({ value: ":" }, v));
          }, g.comma = function(v) {
            return new h(Object.assign({ value: "," }, v));
          }, g.comment = function(v) {
            return new l(v);
          }, g.func = function(v) {
            return new p(v);
          }, g.number = function(v) {
            return new m(v);
          }, g.operator = function(v) {
            return new c2(v);
          }, g.paren = function(v) {
            return new t(Object.assign({ value: "(" }, v));
          }, g.string = function(v) {
            return new r2(Object.assign({ quote: "'" }, v));
          }, g.value = function(v) {
            return new s(v);
          }, g.word = function(v) {
            return new f(v);
          }, g.unicodeRange = function(v) {
            return new a(v);
          }, n.exports = g;
        } }), ze = P({ "node_modules/postcss-selector-parser/dist/selectors/node.js"(e, n) {
          A(), e.__esModule = true;
          var i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          };
          function u(l, p) {
            if (!(l instanceof p)) throw new TypeError("Cannot call a class as a function");
          }
          var o = function l(p, m) {
            if ((typeof p > "u" ? "undefined" : i(p)) !== "object") return p;
            var c2 = new p.constructor();
            for (var t in p) if (p.hasOwnProperty(t)) {
              var r2 = p[t], a = typeof r2 > "u" ? "undefined" : i(r2);
              t === "parent" && a === "object" ? m && (c2[t] = m) : r2 instanceof Array ? c2[t] = r2.map(function(s) {
                return l(s, c2);
              }) : c2[t] = l(r2, c2);
            }
            return c2;
          }, h = (function() {
            function l() {
              var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              u(this, l);
              for (var m in p) this[m] = p[m];
              var c2 = p.spaces;
              c2 = c2 === void 0 ? {} : c2;
              var t = c2.before, r2 = t === void 0 ? "" : t, a = c2.after, s = a === void 0 ? "" : a;
              this.spaces = { before: r2, after: s };
            }
            return l.prototype.remove = function() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }, l.prototype.replaceWith = function() {
              if (this.parent) {
                for (var m in arguments) this.parent.insertBefore(this, arguments[m]);
                this.remove();
              }
              return this;
            }, l.prototype.next = function() {
              return this.parent.at(this.parent.index(this) + 1);
            }, l.prototype.prev = function() {
              return this.parent.at(this.parent.index(this) - 1);
            }, l.prototype.clone = function() {
              var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c2 = o(this);
              for (var t in m) c2[t] = m[t];
              return c2;
            }, l.prototype.toString = function() {
              return [this.spaces.before, String(this.value), this.spaces.after].join("");
            }, l;
          })();
          e.default = h, n.exports = e.default;
        } }), se = P({ "node_modules/postcss-selector-parser/dist/selectors/types.js"(e) {
          A(), e.__esModule = true;
          e.TAG = "tag"; e.STRING = "string"; e.SELECTOR = "selector"; e.ROOT = "root"; e.PSEUDO = "pseudo"; e.NESTING = "nesting"; e.ID = "id"; e.COMMENT = "comment"; e.COMBINATOR = "combinator"; e.CLASS = "class"; e.ATTRIBUTE = "attribute"; e.UNIVERSAL = "universal";
        } }), Dt = P({ "node_modules/postcss-selector-parser/dist/selectors/container.js"(e, n) {
          A(), e.__esModule = true;
          var i = /* @__PURE__ */ (function() {
            function s(f, g) {
              for (var v = 0; v < g.length; v++) {
                var y = g[v];
                y.enumerable = y.enumerable || false, y.configurable = true, "value" in y && (y.writable = true), Object.defineProperty(f, y.key, y);
              }
            }
            return function(f, g, v) {
              return g && s(f.prototype, g), v && s(f, v), f;
            };
          })(), u = ze(), o = m(u), h = se(), l = p(h);
          function p(s) {
            if (s && s.__esModule) return s;
            var f = {};
            if (s != null) for (var g in s) Object.prototype.hasOwnProperty.call(s, g) && (f[g] = s[g]);
            return f.default = s, f;
          }
          function m(s) {
            return s && s.__esModule ? s : { default: s };
          }
          function c2(s, f) {
            if (!(s instanceof f)) throw new TypeError("Cannot call a class as a function");
          }
          function t(s, f) {
            if (!s) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return f && (typeof f == "object" || typeof f == "function") ? f : s;
          }
          function r2(s, f) {
            if (typeof f != "function" && f !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof f);
            s.prototype = Object.create(f && f.prototype, { constructor: { value: s, enumerable: false, writable: true, configurable: true } }), f && (Object.setPrototypeOf ? Object.setPrototypeOf(s, f) : s.__proto__ = f);
          }
          var a = (function(s) {
            r2(f, s);
            function f(g) {
              c2(this, f);
              var v = t(this, s.call(this, g));
              return v.nodes || (v.nodes = []), v;
            }
            return f.prototype.append = function(v) {
              return v.parent = this, this.nodes.push(v), this;
            }, f.prototype.prepend = function(v) {
              return v.parent = this, this.nodes.unshift(v), this;
            }, f.prototype.at = function(v) {
              return this.nodes[v];
            }, f.prototype.index = function(v) {
              return typeof v == "number" ? v : this.nodes.indexOf(v);
            }, f.prototype.removeChild = function(v) {
              v = this.index(v), this.at(v).parent = void 0, this.nodes.splice(v, 1);
              var y = void 0;
              for (var w in this.indexes) y = this.indexes[w], y >= v && (this.indexes[w] = y - 1);
              return this;
            }, f.prototype.removeAll = function() {
              for (var w = this.nodes, v = Array.isArray(w), y = 0, w = v ? w : w[Symbol.iterator](); ; ) {
                var d;
                if (v) {
                  if (y >= w.length) break;
                  d = w[y++];
                } else {
                  if (y = w.next(), y.done) break;
                  d = y.value;
                }
                var _ = d;
                _.parent = void 0;
              }
              return this.nodes = [], this;
            }, f.prototype.empty = function() {
              return this.removeAll();
            }, f.prototype.insertAfter = function(v, y) {
              var w = this.index(v);
              this.nodes.splice(w + 1, 0, y);
              var d = void 0;
              for (var _ in this.indexes) d = this.indexes[_], w <= d && (this.indexes[_] = d + this.nodes.length);
              return this;
            }, f.prototype.insertBefore = function(v, y) {
              var w = this.index(v);
              this.nodes.splice(w, 0, y);
              var d = void 0;
              for (var _ in this.indexes) d = this.indexes[_], w <= d && (this.indexes[_] = d + this.nodes.length);
              return this;
            }, f.prototype.each = function(v) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
              var y = this.lastEach;
              if (this.indexes[y] = 0, !!this.length) {
                for (var w = void 0, d = void 0; this.indexes[y] < this.length && (w = this.indexes[y], d = v(this.at(w), w), d !== false); ) this.indexes[y] += 1;
                if (delete this.indexes[y], d === false) return false;
              }
            }, f.prototype.walk = function(v) {
              return this.each(function(y, w) {
                var d = v(y, w);
                if (d !== false && y.length && (d = y.walk(v)), d === false) return false;
              });
            }, f.prototype.walkAttributes = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.ATTRIBUTE) return v.call(y, w);
              });
            }, f.prototype.walkClasses = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.CLASS) return v.call(y, w);
              });
            }, f.prototype.walkCombinators = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.COMBINATOR) return v.call(y, w);
              });
            }, f.prototype.walkComments = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.COMMENT) return v.call(y, w);
              });
            }, f.prototype.walkIds = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.ID) return v.call(y, w);
              });
            }, f.prototype.walkNesting = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.NESTING) return v.call(y, w);
              });
            }, f.prototype.walkPseudos = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.PSEUDO) return v.call(y, w);
              });
            }, f.prototype.walkTags = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.TAG) return v.call(y, w);
              });
            }, f.prototype.walkUniversals = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === l.UNIVERSAL) return v.call(y, w);
              });
            }, f.prototype.split = function(v) {
              var y = this, w = [];
              return this.reduce(function(d, _, k) {
                var x = v.call(y, _);
                return w.push(_), x ? (d.push(w), w = []) : k === y.length - 1 && d.push(w), d;
              }, []);
            }, f.prototype.map = function(v) {
              return this.nodes.map(v);
            }, f.prototype.reduce = function(v, y) {
              return this.nodes.reduce(v, y);
            }, f.prototype.every = function(v) {
              return this.nodes.every(v);
            }, f.prototype.some = function(v) {
              return this.nodes.some(v);
            }, f.prototype.filter = function(v) {
              return this.nodes.filter(v);
            }, f.prototype.sort = function(v) {
              return this.nodes.sort(v);
            }, f.prototype.toString = function() {
              return this.map(String).join("");
            }, i(f, [{ key: "first", get: function() {
              return this.at(0);
            } }, { key: "last", get: function() {
              return this.at(this.length - 1);
            } }, { key: "length", get: function() {
              return this.nodes.length;
            } }]), f;
          })(o.default);
          e.default = a, n.exports = e.default;
        } }), Lo = P({ "node_modules/postcss-selector-parser/dist/selectors/root.js"(e, n) {
          A(), e.__esModule = true;
          var i = Dt(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.ROOT, s;
            }
            return r2.prototype.toString = function() {
              var s = this.reduce(function(f, g) {
                var v = String(g);
                return v ? f + v + "," : "";
              }, "").slice(0, -1);
              return this.trailingComma ? s + "," : s;
            }, r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), zo = P({ "node_modules/postcss-selector-parser/dist/selectors/selector.js"(e, n) {
          A(), e.__esModule = true;
          var i = Dt(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.SELECTOR, s;
            }
            return r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), Ye = P({ "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(e, n) {
          A(), e.__esModule = true;
          var i = /* @__PURE__ */ (function() {
            function t(r2, a) {
              for (var s = 0; s < a.length; s++) {
                var f = a[s];
                f.enumerable = f.enumerable || false, f.configurable = true, "value" in f && (f.writable = true), Object.defineProperty(r2, f.key, f);
              }
            }
            return function(r2, a, s) {
              return a && t(r2.prototype, a), s && t(r2, s), r2;
            };
          })(), u = ze(), o = h(u);
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2() {
              return l(this, r2), p(this, t.apply(this, arguments));
            }
            return r2.prototype.toString = function() {
              return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
            }, i(r2, [{ key: "ns", get: function() {
              var s = this.namespace;
              return s ? (typeof s == "string" ? s : "") + "|" : "";
            } }]), r2;
          })(o.default);
          e.default = c2, n.exports = e.default;
        } }), Bo = P({ "node_modules/postcss-selector-parser/dist/selectors/className.js"(e, n) {
          A(), e.__esModule = true;
          var i = Ye(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.CLASS, s;
            }
            return r2.prototype.toString = function() {
              return [this.spaces.before, this.ns, String("." + this.value), this.spaces.after].join("");
            }, r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), Fo = P({ "node_modules/postcss-selector-parser/dist/selectors/comment.js"(e, n) {
          A(), e.__esModule = true;
          var i = ze(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.COMMENT, s;
            }
            return r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), Uo = P({ "node_modules/postcss-selector-parser/dist/selectors/id.js"(e, n) {
          A(), e.__esModule = true;
          var i = Ye(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.ID, s;
            }
            return r2.prototype.toString = function() {
              return [this.spaces.before, this.ns, String("#" + this.value), this.spaces.after].join("");
            }, r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), $o = P({ "node_modules/postcss-selector-parser/dist/selectors/tag.js"(e, n) {
          A(), e.__esModule = true;
          var i = Ye(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.TAG, s;
            }
            return r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), Wo = P({ "node_modules/postcss-selector-parser/dist/selectors/string.js"(e, n) {
          A(), e.__esModule = true;
          var i = ze(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.STRING, s;
            }
            return r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), Vo = P({ "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(e, n) {
          A(), e.__esModule = true;
          var i = Dt(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.PSEUDO, s;
            }
            return r2.prototype.toString = function() {
              var s = this.length ? "(" + this.map(String).join(",") + ")" : "";
              return [this.spaces.before, String(this.value), s, this.spaces.after].join("");
            }, r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), Go = P({ "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(e, n) {
          A(), e.__esModule = true;
          var i = Ye(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.ATTRIBUTE, s.raws = {}, s;
            }
            return r2.prototype.toString = function() {
              var s = [this.spaces.before, "[", this.ns, this.attribute];
              return this.operator && s.push(this.operator), this.value && s.push(this.value), this.raws.insensitive ? s.push(this.raws.insensitive) : this.insensitive && s.push(" i"), s.push("]"), s.concat(this.spaces.after).join("");
            }, r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), Ho = P({ "node_modules/postcss-selector-parser/dist/selectors/universal.js"(e, n) {
          A(), e.__esModule = true;
          var i = Ye(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.UNIVERSAL, s.value = "*", s;
            }
            return r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), Jo = P({ "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(e, n) {
          A(), e.__esModule = true;
          var i = ze(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.COMBINATOR, s;
            }
            return r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), Ko = P({ "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(e, n) {
          A(), e.__esModule = true;
          var i = ze(), u = h(i), o = se();
          function h(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function l(t, r2) {
            if (!(t instanceof r2)) throw new TypeError("Cannot call a class as a function");
          }
          function p(t, r2) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r2 && (typeof r2 == "object" || typeof r2 == "function") ? r2 : t;
          }
          function m(t, r2) {
            if (typeof r2 != "function" && r2 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof r2);
            t.prototype = Object.create(r2 && r2.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r2) : t.__proto__ = r2);
          }
          var c2 = (function(t) {
            m(r2, t);
            function r2(a) {
              l(this, r2);
              var s = p(this, t.call(this, a));
              return s.type = o.NESTING, s.value = "&", s;
            }
            return r2;
          })(u.default);
          e.default = c2, n.exports = e.default;
        } }), yf = P({ "node_modules/postcss-selector-parser/dist/sortAscending.js"(e, n) {
          A(), e.__esModule = true, e.default = i;
          function i(u) {
            return u.sort(function(o, h) {
              return o - h;
            });
          }
          n.exports = e.default;
        } }), wf = P({ "node_modules/postcss-selector-parser/dist/tokenize.js"(e, n) {
          A(), e.__esModule = true, e.default = H;
          var i = 39, u = 34, o = 92, h = 47, l = 10, p = 32, m = 12, c2 = 9, t = 13, r2 = 43, a = 62, s = 126, f = 124, g = 44, v = 40, y = 41, w = 91, d = 93, _ = 59, k = 42, x = 58, N = 38, I = 64, W = /[ \n\t\r\{\(\)'"\\;/]/g, $ = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
          function H(D) {
            for (var V = [], B = D.css.valueOf(), O = void 0, j = void 0, C = void 0, R = void 0, X = void 0, Z = void 0, Q = void 0, K = void 0, J = void 0, M = void 0, Y = void 0, G = B.length, E = -1, S = 1, b = 0, L = function(T, F) {
              if (D.safe) B += F, j = B.length - 1;
              else throw D.error("Unclosed " + T, S, b - E, b);
            }; b < G; ) {
              switch (O = B.charCodeAt(b), O === l && (E = b, S += 1), O) {
                case l:
                case p:
                case c2:
                case t:
                case m:
                  j = b;
                  do
                    j += 1, O = B.charCodeAt(j), O === l && (E = j, S += 1);
                  while (O === p || O === l || O === c2 || O === t || O === m);
                  V.push(["space", B.slice(b, j), S, b - E, b]), b = j - 1;
                  break;
                case r2:
                case a:
                case s:
                case f:
                  j = b;
                  do
                    j += 1, O = B.charCodeAt(j);
                  while (O === r2 || O === a || O === s || O === f);
                  V.push(["combinator", B.slice(b, j), S, b - E, b]), b = j - 1;
                  break;
                case k:
                  V.push(["*", "*", S, b - E, b]);
                  break;
                case N:
                  V.push(["&", "&", S, b - E, b]);
                  break;
                case g:
                  V.push([",", ",", S, b - E, b]);
                  break;
                case w:
                  V.push(["[", "[", S, b - E, b]);
                  break;
                case d:
                  V.push(["]", "]", S, b - E, b]);
                  break;
                case x:
                  V.push([":", ":", S, b - E, b]);
                  break;
                case _:
                  V.push([";", ";", S, b - E, b]);
                  break;
                case v:
                  V.push(["(", "(", S, b - E, b]);
                  break;
                case y:
                  V.push([")", ")", S, b - E, b]);
                  break;
                case i:
                case u:
                  C = O === i ? "'" : '"', j = b;
                  do
                    for (M = false, j = B.indexOf(C, j + 1), j === -1 && L("quote", C), Y = j; B.charCodeAt(Y - 1) === o; ) Y -= 1, M = !M;
                  while (M);
                  V.push(["string", B.slice(b, j + 1), S, b - E, S, j - E, b]), b = j;
                  break;
                case I:
                  W.lastIndex = b + 1, W.test(B), W.lastIndex === 0 ? j = B.length - 1 : j = W.lastIndex - 2, V.push(["at-word", B.slice(b, j + 1), S, b - E, S, j - E, b]), b = j;
                  break;
                case o:
                  for (j = b, Q = true; B.charCodeAt(j + 1) === o; ) j += 1, Q = !Q;
                  O = B.charCodeAt(j + 1), Q && O !== h && O !== p && O !== l && O !== c2 && O !== t && O !== m && (j += 1), V.push(["word", B.slice(b, j + 1), S, b - E, S, j - E, b]), b = j;
                  break;
                default:
                  O === h && B.charCodeAt(b + 1) === k ? (j = B.indexOf("*/", b + 2) + 1, j === 0 && L("comment", "*/"), Z = B.slice(b, j + 1), R = Z.split(`
`), X = R.length - 1, X > 0 ? (K = S + X, J = j - R[X].length) : (K = S, J = E), V.push(["comment", Z, S, b - E, K, j - J, b]), E = J, S = K, b = j) : ($.lastIndex = b + 1, $.test(B), $.lastIndex === 0 ? j = B.length - 1 : j = $.lastIndex - 2, V.push(["word", B.slice(b, j + 1), S, b - E, S, j - E, b]), b = j);
                  break;
              }
              b++;
            }
            return V;
          }
          n.exports = e.default;
        } }), _f = P({ "node_modules/postcss-selector-parser/dist/parser.js"(e, n) {
          A(), e.__esModule = true;
          var i = /* @__PURE__ */ (function() {
            function E(S, b) {
              for (var L = 0; L < b.length; L++) {
                var q = b[L];
                q.enumerable = q.enumerable || false, q.configurable = true, "value" in q && (q.writable = true), Object.defineProperty(S, q.key, q);
              }
            }
            return function(S, b, L) {
              return b && E(S.prototype, b), L && E(S, L), S;
            };
          })(), u = jo(), o = M(u), h = Mo(), l = M(h), p = Do(), m = M(p), c2 = Lo(), t = M(c2), r2 = zo(), a = M(r2), s = Bo(), f = M(s), g = Fo(), v = M(g), y = Uo(), w = M(y), d = $o(), _ = M(d), k = Wo(), x = M(k), N = Vo(), I = M(N), W = Go(), $ = M(W), H = Ho(), D = M(H), V = Jo(), B = M(V), O = Ko(), j = M(O), C = yf(), R = M(C), X = wf(), Z = M(X), Q = se(), K = J(Q);
          function J(E) {
            if (E && E.__esModule) return E;
            var S = {};
            if (E != null) for (var b in E) Object.prototype.hasOwnProperty.call(E, b) && (S[b] = E[b]);
            return S.default = E, S;
          }
          function M(E) {
            return E && E.__esModule ? E : { default: E };
          }
          function Y(E, S) {
            if (!(E instanceof S)) throw new TypeError("Cannot call a class as a function");
          }
          var G = (function() {
            function E(S) {
              Y(this, E), this.input = S, this.lossy = S.options.lossless === false, this.position = 0, this.root = new t.default();
              var b = new a.default();
              return this.root.append(b), this.current = b, this.lossy ? this.tokens = (0, Z.default)({ safe: S.safe, css: S.css.trim() }) : this.tokens = (0, Z.default)(S), this.loop();
            }
            return E.prototype.attribute = function() {
              var b = "", L = void 0, q = this.currToken;
              for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; ) b += this.tokens[this.position][1], this.position++;
              this.position === this.tokens.length && !~b.indexOf("]") && this.error("Expected a closing square bracket.");
              var T = b.split(/((?:[*~^$|]?=))([^]*)/), F = T[0].split(/(\|)/g), z = { operator: T[1], value: T[2], source: { start: { line: q[2], column: q[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: q[4] };
              if (F.length > 1 ? (F[0] === "" && (F[0] = true), z.attribute = this.parseValue(F[2]), z.namespace = this.parseNamespace(F[0])) : z.attribute = this.parseValue(T[0]), L = new $.default(z), T[2]) {
                var ee = T[2].split(/(\s+i\s*?)$/), te = ee[0].trim();
                L.value = this.lossy ? te : ee[0], ee[1] && (L.insensitive = true, this.lossy || (L.raws.insensitive = ee[1])), L.quoted = te[0] === "'" || te[0] === '"', L.raws.unquoted = L.quoted ? te.slice(1, -1) : te;
              }
              this.newNode(L), this.position++;
            }, E.prototype.combinator = function() {
              if (this.currToken[1] === "|") return this.namespace();
              for (var b = new B.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); ) this.nextToken && this.nextToken[0] === "combinator" ? (b.spaces.before = this.parseSpace(this.currToken[1]), b.source.start.line = this.nextToken[2], b.source.start.column = this.nextToken[3], b.source.end.column = this.nextToken[3], b.source.end.line = this.nextToken[2], b.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? b.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? b.value = this.currToken[1] : this.currToken[0] === "space" && (b.value = this.parseSpace(this.currToken[1], " ")), this.position++;
              return this.newNode(b);
            }, E.prototype.comma = function() {
              if (this.position === this.tokens.length - 1) {
                this.root.trailingComma = true, this.position++;
                return;
              }
              var b = new a.default();
              this.current.parent.append(b), this.current = b, this.position++;
            }, E.prototype.comment = function() {
              var b = new v.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
              this.newNode(b), this.position++;
            }, E.prototype.error = function(b) {
              throw new this.input.error(b);
            }, E.prototype.missingBackslash = function() {
              return this.error("Expected a backslash preceding the semicolon.");
            }, E.prototype.missingParenthesis = function() {
              return this.error("Expected opening parenthesis.");
            }, E.prototype.missingSquareBracket = function() {
              return this.error("Expected opening square bracket.");
            }, E.prototype.namespace = function() {
              var b = this.prevToken && this.prevToken[1] || true;
              if (this.nextToken[0] === "word") return this.position++, this.word(b);
              if (this.nextToken[0] === "*") return this.position++, this.universal(b);
            }, E.prototype.nesting = function() {
              this.newNode(new j.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
            }, E.prototype.parentheses = function() {
              var b = this.current.last;
              if (b && b.type === K.PSEUDO) {
                var L = new a.default(), q = this.current;
                b.append(L), this.current = L;
                var T = 1;
                for (this.position++; this.position < this.tokens.length && T; ) this.currToken[0] === "(" && T++, this.currToken[0] === ")" && T--, T ? this.parse() : (L.parent.source.end.line = this.currToken[2], L.parent.source.end.column = this.currToken[3], this.position++);
                T && this.error("Expected closing parenthesis."), this.current = q;
              } else {
                var F = 1;
                for (this.position++, b.value += "("; this.position < this.tokens.length && F; ) this.currToken[0] === "(" && F++, this.currToken[0] === ")" && F--, b.value += this.parseParenthesisToken(this.currToken), this.position++;
                F && this.error("Expected closing parenthesis.");
              }
            }, E.prototype.pseudo = function() {
              for (var b = this, L = "", q = this.currToken; this.currToken && this.currToken[0] === ":"; ) L += this.currToken[1], this.position++;
              if (!this.currToken) return this.error("Expected pseudo-class or pseudo-element");
              if (this.currToken[0] === "word") {
                var T = void 0;
                this.splitWord(false, function(F, z) {
                  L += F, T = new I.default({ value: L, source: { start: { line: q[2], column: q[3] }, end: { line: b.currToken[4], column: b.currToken[5] } }, sourceIndex: q[4] }), b.newNode(T), z > 1 && b.nextToken && b.nextToken[0] === "(" && b.error("Misplaced parenthesis.");
                });
              } else this.error('Unexpected "' + this.currToken[0] + '" found.');
            }, E.prototype.space = function() {
              var b = this.currToken;
              this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(b[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(b[1]), this.position++) : this.combinator();
            }, E.prototype.string = function() {
              var b = this.currToken;
              this.newNode(new x.default({ value: this.currToken[1], source: { start: { line: b[2], column: b[3] }, end: { line: b[4], column: b[5] } }, sourceIndex: b[6] })), this.position++;
            }, E.prototype.universal = function(b) {
              var L = this.nextToken;
              if (L && L[1] === "|") return this.position++, this.namespace();
              this.newNode(new D.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), b), this.position++;
            }, E.prototype.splitWord = function(b, L) {
              for (var q = this, T = this.nextToken, F = this.currToken[1]; T && T[0] === "word"; ) {
                this.position++;
                var z = this.currToken[1];
                if (F += z, z.lastIndexOf("\\") === z.length - 1) {
                  var ee = this.nextToken;
                  ee && ee[0] === "space" && (F += this.parseSpace(ee[1], " "), this.position++);
                }
                T = this.nextToken;
              }
              var te = (0, l.default)(F, "."), ue = (0, l.default)(F, "#"), le = (0, l.default)(F, "#{");
              le.length && (ue = ue.filter(function(ne) {
                return !~le.indexOf(ne);
              }));
              var re = (0, R.default)((0, m.default)((0, o.default)([[0], te, ue])));
              re.forEach(function(ne, oe) {
                var ie = re[oe + 1] || F.length, ce = F.slice(ne, ie);
                if (oe === 0 && L) return L.call(q, ce, re.length);
                var fe = void 0;
                ~te.indexOf(ne) ? fe = new f.default({ value: ce.slice(1), source: { start: { line: q.currToken[2], column: q.currToken[3] + ne }, end: { line: q.currToken[4], column: q.currToken[3] + (ie - 1) } }, sourceIndex: q.currToken[6] + re[oe] }) : ~ue.indexOf(ne) ? fe = new w.default({ value: ce.slice(1), source: { start: { line: q.currToken[2], column: q.currToken[3] + ne }, end: { line: q.currToken[4], column: q.currToken[3] + (ie - 1) } }, sourceIndex: q.currToken[6] + re[oe] }) : fe = new _.default({ value: ce, source: { start: { line: q.currToken[2], column: q.currToken[3] + ne }, end: { line: q.currToken[4], column: q.currToken[3] + (ie - 1) } }, sourceIndex: q.currToken[6] + re[oe] }), q.newNode(fe, b);
              }), this.position++;
            }, E.prototype.word = function(b) {
              var L = this.nextToken;
              return L && L[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(b);
            }, E.prototype.loop = function() {
              for (; this.position < this.tokens.length; ) this.parse(true);
              return this.root;
            }, E.prototype.parse = function(b) {
              switch (this.currToken[0]) {
                case "space":
                  this.space();
                  break;
                case "comment":
                  this.comment();
                  break;
                case "(":
                  this.parentheses();
                  break;
                case ")":
                  b && this.missingParenthesis();
                  break;
                case "[":
                  this.attribute();
                  break;
                case "]":
                  this.missingSquareBracket();
                  break;
                case "at-word":
                case "word":
                  this.word();
                  break;
                case ":":
                  this.pseudo();
                  break;
                case ";":
                  this.missingBackslash();
                  break;
                case ",":
                  this.comma();
                  break;
                case "*":
                  this.universal();
                  break;
                case "&":
                  this.nesting();
                  break;
                case "combinator":
                  this.combinator();
                  break;
                case "string":
                  this.string();
                  break;
              }
            }, E.prototype.parseNamespace = function(b) {
              if (this.lossy && typeof b == "string") {
                var L = b.trim();
                return L.length ? L : true;
              }
              return b;
            }, E.prototype.parseSpace = function(b, L) {
              return this.lossy ? L || "" : b;
            }, E.prototype.parseValue = function(b) {
              return this.lossy && b && typeof b == "string" ? b.trim() : b;
            }, E.prototype.parseParenthesisToken = function(b) {
              return this.lossy ? b[0] === "space" ? this.parseSpace(b[1], " ") : this.parseValue(b[1]) : b[1];
            }, E.prototype.newNode = function(b, L) {
              return L && (b.namespace = this.parseNamespace(L)), this.spaces && (b.spaces.before = this.spaces, this.spaces = ""), this.current.append(b);
            }, i(E, [{ key: "currToken", get: function() {
              return this.tokens[this.position];
            } }, { key: "nextToken", get: function() {
              return this.tokens[this.position + 1];
            } }, { key: "prevToken", get: function() {
              return this.tokens[this.position - 1];
            } }]), E;
          })();
          e.default = G, n.exports = e.default;
        } }), bf = P({ "node_modules/postcss-selector-parser/dist/processor.js"(e, n) {
          A(), e.__esModule = true;
          var i = /* @__PURE__ */ (function() {
            function m(c2, t) {
              for (var r2 = 0; r2 < t.length; r2++) {
                var a = t[r2];
                a.enumerable = a.enumerable || false, a.configurable = true, "value" in a && (a.writable = true), Object.defineProperty(c2, a.key, a);
              }
            }
            return function(c2, t, r2) {
              return t && m(c2.prototype, t), r2 && m(c2, r2), c2;
            };
          })(), u = _f(), o = h(u);
          function h(m) {
            return m && m.__esModule ? m : { default: m };
          }
          function l(m, c2) {
            if (!(m instanceof c2)) throw new TypeError("Cannot call a class as a function");
          }
          var p = (function() {
            function m(c2) {
              return l(this, m), this.func = c2 || function() {
              }, this;
            }
            return m.prototype.process = function(t) {
              var r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = new o.default({ css: t, error: function(f) {
                throw new Error(f);
              }, options: r2 });
              return this.res = a, this.func(a), this;
            }, i(m, [{ key: "result", get: function() {
              return String(this.res);
            } }]), m;
          })();
          e.default = p, n.exports = e.default;
        } }), xf = P({ "node_modules/postcss-selector-parser/dist/index.js"(e, n) {
          A(), e.__esModule = true;
          var i = bf(), u = O(i), o = Go(), h = O(o), l = Bo(), p = O(l), m = Jo(), c2 = O(m), t = Fo(), r2 = O(t), a = Uo(), s = O(a), f = Ko(), g = O(f), v = Vo(), y = O(v), w = Lo(), d = O(w), _ = zo(), k = O(_), x = Wo(), N = O(x), I = $o(), W = O(I), $ = Ho(), H = O($), D = se(), V = B(D);
          function B(C) {
            if (C && C.__esModule) return C;
            var R = {};
            if (C != null) for (var X in C) Object.prototype.hasOwnProperty.call(C, X) && (R[X] = C[X]);
            return R.default = C, R;
          }
          function O(C) {
            return C && C.__esModule ? C : { default: C };
          }
          var j = function(R) {
            return new u.default(R);
          };
          j.attribute = function(C) {
            return new h.default(C);
          }, j.className = function(C) {
            return new p.default(C);
          }, j.combinator = function(C) {
            return new c2.default(C);
          }, j.comment = function(C) {
            return new r2.default(C);
          }, j.id = function(C) {
            return new s.default(C);
          }, j.nesting = function(C) {
            return new g.default(C);
          }, j.pseudo = function(C) {
            return new y.default(C);
          }, j.root = function(C) {
            return new d.default(C);
          }, j.selector = function(C) {
            return new k.default(C);
          }, j.string = function(C) {
            return new N.default(C);
          }, j.tag = function(C) {
            return new W.default(C);
          }, j.universal = function(C) {
            return new H.default(C);
          }, Object.keys(V).forEach(function(C) {
            C !== "__esModule" && (j[C] = V[C]);
          }), e.default = j, n.exports = e.default;
        } }), Qo = P({ "node_modules/postcss-media-query-parser/dist/nodes/Node.js"(e) {
          A(), Object.defineProperty(e, "__esModule", { value: true });
          function n(i) {
            this.after = i.after, this.before = i.before, this.type = i.type, this.value = i.value, this.sourceIndex = i.sourceIndex;
          }
          e.default = n;
        } }), Yo = P({ "node_modules/postcss-media-query-parser/dist/nodes/Container.js"(e) {
          A(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Qo(), i = u(n);
          function u(h) {
            return h && h.__esModule ? h : { default: h };
          }
          function o(h) {
            var l = this;
            this.constructor(h), this.nodes = h.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(p) {
              p.parent = l;
            });
          }
          o.prototype = Object.create(i.default.prototype), o.constructor = i.default, o.prototype.walk = function(l, p) {
            for (var m = typeof l == "string" || l instanceof RegExp, c2 = m ? p : l, t = typeof l == "string" ? new RegExp(l) : l, r2 = 0; r2 < this.nodes.length; r2++) {
              var a = this.nodes[r2], s = m ? t.test(a.type) : true;
              if (s && c2 && c2(a, r2, this.nodes) === false || a.nodes && a.walk(l, p) === false) return false;
            }
            return true;
          }, o.prototype.each = function() {
            for (var l = arguments.length <= 0 || arguments[0] === void 0 ? function() {
            } : arguments[0], p = 0; p < this.nodes.length; p++) {
              var m = this.nodes[p];
              if (l(m, p, this.nodes) === false) return false;
            }
            return true;
          }, e.default = o;
        } }), Sf = P({ "node_modules/postcss-media-query-parser/dist/parsers.js"(e) {
          A(), Object.defineProperty(e, "__esModule", { value: true }), e.parseMediaFeature = l, e.parseMediaQuery = p, e.parseMediaList = m;
          var n = Qo(), i = h(n), u = Yo(), o = h(u);
          function h(c2) {
            return c2 && c2.__esModule ? c2 : { default: c2 };
          }
          function l(c2) {
            var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r2 = [{ mode: "normal", character: null }], a = [], s = 0, f = "", g = null, v = null, y = t, w = c2;
            c2[0] === "(" && c2[c2.length - 1] === ")" && (w = c2.substring(1, c2.length - 1), y++);
            for (var d = 0; d < w.length; d++) {
              var _ = w[d];
              if ((_ === "'" || _ === '"') && (r2[s].isCalculationEnabled === true ? (r2.push({ mode: "string", isCalculationEnabled: false, character: _ }), s++) : r2[s].mode === "string" && r2[s].character === _ && w[d - 1] !== "\\" && (r2.pop(), s--)), _ === "{" ? (r2.push({ mode: "interpolation", isCalculationEnabled: true }), s++) : _ === "}" && (r2.pop(), s--), r2[s].mode === "normal" && _ === ":") {
                var k = w.substring(d + 1);
                v = { type: "value", before: /^(\s*)/.exec(k)[1], after: /(\s*)$/.exec(k)[1], value: k.trim() }, v.sourceIndex = v.before.length + d + 1 + y, g = { type: "colon", sourceIndex: d + y, after: v.before, value: ":" };
                break;
              }
              f += _;
            }
            return f = { type: "media-feature", before: /^(\s*)/.exec(f)[1], after: /(\s*)$/.exec(f)[1], value: f.trim() }, f.sourceIndex = f.before.length + y, a.push(f), g !== null && (g.before = f.after, a.push(g)), v !== null && a.push(v), a;
          }
          function p(c2) {
            var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r2 = [], a = 0, s = false, f = void 0;
            function g() {
              return { before: "", after: "", value: "" };
            }
            f = g();
            for (var v = 0; v < c2.length; v++) {
              var y = c2[v];
              s ? (f.value += y, (y === "{" || y === "(") && a++, (y === ")" || y === "}") && a--) : y.search(/\s/) !== -1 ? f.before += y : (y === "(" && (f.type = "media-feature-expression", a++), f.value = y, f.sourceIndex = t + v, s = true), s && a === 0 && (y === ")" || v === c2.length - 1 || c2[v + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(f.value) !== -1 && (f.type = "keyword"), f.type === "media-feature-expression" && (f.nodes = l(f.value, f.sourceIndex)), r2.push(Array.isArray(f.nodes) ? new o.default(f) : new i.default(f)), f = g(), s = false);
            }
            for (var w = 0; w < r2.length; w++) if (f = r2[w], w > 0 && (r2[w - 1].after = f.before), f.type === void 0) {
              if (w > 0) {
                if (r2[w - 1].type === "media-feature-expression") {
                  f.type = "keyword";
                  continue;
                }
                if (r2[w - 1].value === "not" || r2[w - 1].value === "only") {
                  f.type = "media-type";
                  continue;
                }
                if (r2[w - 1].value === "and") {
                  f.type = "media-feature-expression";
                  continue;
                }
                r2[w - 1].type === "media-type" && (r2[w + 1] ? f.type = r2[w + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : f.type = "media-feature-expression");
              }
              if (w === 0) {
                if (!r2[w + 1]) {
                  f.type = "media-type";
                  continue;
                }
                if (r2[w + 1] && (r2[w + 1].type === "media-feature-expression" || r2[w + 1].type === "keyword")) {
                  f.type = "media-type";
                  continue;
                }
                if (r2[w + 2]) {
                  if (r2[w + 2].type === "media-feature-expression") {
                    f.type = "media-type", r2[w + 1].type = "keyword";
                    continue;
                  }
                  if (r2[w + 2].type === "keyword") {
                    f.type = "keyword", r2[w + 1].type = "media-type";
                    continue;
                  }
                }
                if (r2[w + 3] && r2[w + 3].type === "media-feature-expression") {
                  f.type = "keyword", r2[w + 1].type = "media-type", r2[w + 2].type = "keyword";
                  continue;
                }
              }
            }
            return r2;
          }
          function m(c2) {
            var t = [], r2 = 0, a = 0, s = /^(\s*)url\s*\(/.exec(c2);
            if (s !== null) {
              for (var f = s[0].length, g = 1; g > 0; ) {
                var v = c2[f];
                v === "(" && g++, v === ")" && g--, f++;
              }
              t.unshift(new i.default({ type: "url", value: c2.substring(0, f).trim(), sourceIndex: s[1].length, before: s[1], after: /^(\s*)/.exec(c2.substring(f))[1] })), r2 = f;
            }
            for (var y = r2; y < c2.length; y++) {
              var w = c2[y];
              if (w === "(" && a++, w === ")" && a--, a === 0 && w === ",") {
                var d = c2.substring(r2, y), _ = /^(\s*)/.exec(d)[1];
                t.push(new o.default({ type: "media-query", value: d.trim(), sourceIndex: r2 + _.length, nodes: p(d, r2), before: _, after: /(\s*)$/.exec(d)[1] })), r2 = y + 1;
              }
            }
            var k = c2.substring(r2), x = /^(\s*)/.exec(k)[1];
            return t.push(new o.default({ type: "media-query", value: k.trim(), sourceIndex: r2 + x.length, nodes: p(k, r2), before: x, after: /(\s*)$/.exec(k)[1] })), t;
          }
        } }), kf = P({ "node_modules/postcss-media-query-parser/dist/index.js"(e) {
          A(), Object.defineProperty(e, "__esModule", { value: true }), e.default = h;
          var n = Yo(), i = o(n), u = Sf();
          function o(l) {
            return l && l.__esModule ? l : { default: l };
          }
          function h(l) {
            return new i.default({ nodes: (0, u.parseMediaList)(l), type: "media-query-list", value: l.trim() });
          }
        } }), Xo = {};
        At(Xo, { basename: () => na, default: () => sa, delimiter: () => kt, dirname: () => ta, extname: () => ia, isAbsolute: () => zt, join: () => ea, normalize: () => Lt, relative: () => ra, resolve: () => yr, sep: () => St });
        function Zo(e, n) {
          for (var i = 0, u = e.length - 1; u >= 0; u--) {
            var o = e[u];
            o === "." ? e.splice(u, 1) : o === ".." ? (e.splice(u, 1), i++) : i && (e.splice(u, 1), i--);
          }
          if (n) for (; i--; i) e.unshift("..");
          return e;
        }
        function yr() {
          for (var e = "", n = false, i = arguments.length - 1; i >= -1 && !n; i--) {
            var u = i >= 0 ? arguments[i] : "/";
            if (typeof u != "string") throw new TypeError("Arguments to path.resolve must be strings");
            if (!u) continue;
            e = u + "/" + e, n = u.charAt(0) === "/";
          }
          return e = Zo(Bt(e.split("/"), function(o) {
            return !!o;
          }), !n).join("/"), (n ? "/" : "") + e || ".";
        }
        function Lt(e) {
          var n = zt(e), i = oa(e, -1) === "/";
          return e = Zo(Bt(e.split("/"), function(u) {
            return !!u;
          }), !n).join("/"), !e && !n && (e = "."), e && i && (e += "/"), (n ? "/" : "") + e;
        }
        function zt(e) {
          return e.charAt(0) === "/";
        }
        function ea() {
          var e = Array.prototype.slice.call(arguments, 0);
          return Lt(Bt(e, function(n, i) {
            if (typeof n != "string") throw new TypeError("Arguments to path.join must be strings");
            return n;
          }).join("/"));
        }
        function ra(e, n) {
          e = yr(e).substr(1), n = yr(n).substr(1);
          function i(c2) {
            for (var t = 0; t < c2.length && c2[t] === ""; t++) ;
            for (var r2 = c2.length - 1; r2 >= 0 && c2[r2] === ""; r2--) ;
            return t > r2 ? [] : c2.slice(t, r2 - t + 1);
          }
          for (var u = i(e.split("/")), o = i(n.split("/")), h = Math.min(u.length, o.length), l = h, p = 0; p < h; p++) if (u[p] !== o[p]) {
            l = p;
            break;
          }
          for (var m = [], p = l; p < u.length; p++) m.push("..");
          return m = m.concat(o.slice(l)), m.join("/");
        }
        function ta(e) {
          var n = br(e), i = n[0], u = n[1];
          return !i && !u ? "." : (u && (u = u.substr(0, u.length - 1)), i + u);
        }
        function na(e, n) {
          var i = br(e)[2];
          return n && i.substr(-1 * n.length) === n && (i = i.substr(0, i.length - n.length)), i;
        }
        function ia(e) {
          return br(e)[3];
        }
        function Bt(e, n) {
          if (e.filter) return e.filter(n);
          for (var i = [], u = 0; u < e.length; u++) n(e[u], u, e) && i.push(e[u]);
          return i;
        }
        var Fs, br, St, kt, sa, oa, Of = Le({ "node-modules-polyfills:path"() {
          A(), Fs = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, br = function(e) {
            return Fs.exec(e).slice(1);
          }, St = "/", kt = ":", sa = { extname: ia, basename: na, dirname: ta, sep: St, delimiter: kt, relative: ra, join: ea, isAbsolute: zt, normalize: Lt, resolve: yr }, oa = "ab".substr(-1) === "b" ? function(e, n, i) {
            return e.substr(n, i);
          } : function(e, n, i) {
            return n < 0 && (n = e.length + n), e.substr(n, i);
          };
        } }), Tf = P({ "node-modules-polyfills-commonjs:path"(e, n) {
          A();
          var i = (Of(), Pt(Xo));
          if (i && i.default) {
            n.exports = i.default;
            for (let u in i) n.exports[u] = i[u];
          } else i && (n.exports = i);
        } }), Ef = P({ "node_modules/picocolors/picocolors.browser.js"(e, n) {
          A();
          var i = String, u = function() {
            return { isColorSupported: false, reset: i, bold: i, dim: i, italic: i, underline: i, inverse: i, hidden: i, strikethrough: i, black: i, red: i, green: i, yellow: i, blue: i, magenta: i, cyan: i, white: i, gray: i, bgBlack: i, bgRed: i, bgGreen: i, bgYellow: i, bgBlue: i, bgMagenta: i, bgCyan: i, bgWhite: i };
          };
          n.exports = u(), n.exports.createColors = u;
        } }), qf = P({ "(disabled):node_modules/postcss/lib/terminal-highlight"() {
          A();
        } }), aa = P({ "node_modules/postcss/lib/css-syntax-error.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = o(Ef()), u = o(qf());
          function o(g) {
            return g && g.__esModule ? g : { default: g };
          }
          function h(g) {
            if (g === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return g;
          }
          function l(g, v) {
            g.prototype = Object.create(v.prototype), g.prototype.constructor = g, g.__proto__ = v;
          }
          function p(g) {
            var v = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
            return p = function(w) {
              if (w === null || !t(w)) return w;
              if (typeof w != "function") throw new TypeError("Super expression must either be null or a function");
              if (typeof v < "u") {
                if (v.has(w)) return v.get(w);
                v.set(w, d);
              }
              function d() {
                return m(w, arguments, a(this).constructor);
              }
              return d.prototype = Object.create(w.prototype, { constructor: { value: d, enumerable: false, writable: true, configurable: true } }), r2(d, w);
            }, p(g);
          }
          function m(g, v, y) {
            return c2() ? m = Reflect.construct : m = function(d, _, k) {
              var x = [null];
              x.push.apply(x, _);
              var N = Function.bind.apply(d, x), I = new N();
              return k && r2(I, k.prototype), I;
            }, m.apply(null, arguments);
          }
          function c2() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return false;
            if (typeof Proxy == "function") return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch {
              return false;
            }
          }
          function t(g) {
            return Function.toString.call(g).indexOf("[native code]") !== -1;
          }
          function r2(g, v) {
            return r2 = Object.setPrototypeOf || function(w, d) {
              return w.__proto__ = d, w;
            }, r2(g, v);
          }
          function a(g) {
            return a = Object.setPrototypeOf ? Object.getPrototypeOf : function(y) {
              return y.__proto__ || Object.getPrototypeOf(y);
            }, a(g);
          }
          var s = (function(g) {
            l(v, g);
            function v(w, d, _, k, x, N) {
              var I;
              return I = g.call(this, w) || this, I.name = "CssSyntaxError", I.reason = w, x && (I.file = x), k && (I.source = k), N && (I.plugin = N), typeof d < "u" && typeof _ < "u" && (I.line = d, I.column = _), I.setMessage(), Error.captureStackTrace && Error.captureStackTrace(h(I), v), I;
            }
            var y = v.prototype;
            return y.setMessage = function() {
              this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
            }, y.showSourceCode = function(d) {
              var _ = this;
              if (!this.source) return "";
              var k = this.source;
              u.default && (typeof d > "u" && (d = i.default.isColorSupported), d && (k = (0, u.default)(k)));
              var x = k.split(/\r?\n/), N = Math.max(this.line - 3, 0), I = Math.min(this.line + 2, x.length), W = String(I).length;
              function $(D) {
                return d && i.default.red ? i.default.red(i.default.bold(D)) : D;
              }
              function H(D) {
                return d && i.default.gray ? i.default.gray(D) : D;
              }
              return x.slice(N, I).map(function(D, V) {
                var B = N + 1 + V, O = " " + (" " + B).slice(-W) + " | ";
                if (B === _.line) {
                  var j = H(O.replace(/\d/g, " ")) + D.slice(0, _.column - 1).replace(/[^\t]/g, " ");
                  return $(">") + H(O) + D + `
 ` + j + $("^");
                }
                return " " + H(O) + D;
              }).join(`
`);
            }, y.toString = function() {
              var d = this.showSourceCode();
              return d && (d = `

` + d + `
`), this.name + ": " + this.message + d;
            }, v;
          })(p(Error)), f = s;
          e.default = f, n.exports = e.default;
        } }), Af = P({ "node_modules/postcss/lib/previous-map.js"(e, n) {
          A(), n.exports = class {
          };
        } }), xr = P({ "node_modules/postcss/lib/input.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = h(Tf()), u = h(aa()), o = h(Af());
          function h(r2) {
            return r2 && r2.__esModule ? r2 : { default: r2 };
          }
          function l(r2, a) {
            for (var s = 0; s < a.length; s++) {
              var f = a[s];
              f.enumerable = f.enumerable || false, f.configurable = true, "value" in f && (f.writable = true), Object.defineProperty(r2, f.key, f);
            }
          }
          function p(r2, a, s) {
            return a && l(r2.prototype, a), r2;
          }
          var m = 0, c2 = (function() {
            function r2(s, f) {
              if (f === void 0 && (f = {}), s === null || typeof s > "u" || typeof s == "object" && !s.toString) throw new Error("PostCSS received " + s + " instead of CSS string");
              this.css = s.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, f.from && (/^\w+:\/\//.test(f.from) || i.default.isAbsolute(f.from) ? this.file = f.from : this.file = i.default.resolve(f.from));
              var g = new o.default(this.css, f);
              if (g.text) {
                this.map = g;
                var v = g.consumer().file;
                !this.file && v && (this.file = this.mapResolve(v));
              }
              this.file || (m += 1, this.id = "<input css " + m + ">"), this.map && (this.map.file = this.from);
            }
            var a = r2.prototype;
            return a.error = function(f, g, v, y) {
              y === void 0 && (y = {});
              var w, d = this.origin(g, v);
              return d ? w = new u.default(f, d.line, d.column, d.source, d.file, y.plugin) : w = new u.default(f, g, v, this.css, this.file, y.plugin), w.input = { line: g, column: v, source: this.css }, this.file && (w.input.file = this.file), w;
            }, a.origin = function(f, g) {
              if (!this.map) return false;
              var v = this.map.consumer(), y = v.originalPositionFor({ line: f, column: g });
              if (!y.source) return false;
              var w = { file: this.mapResolve(y.source), line: y.line, column: y.column }, d = v.sourceContentFor(y.source);
              return d && (w.source = d), w;
            }, a.mapResolve = function(f) {
              return /^\w+:\/\//.test(f) ? f : i.default.resolve(this.map.consumer().sourceRoot || ".", f);
            }, p(r2, [{ key: "from", get: function() {
              return this.file || this.id;
            } }]), r2;
          })(), t = c2;
          e.default = t, n.exports = e.default;
        } }), Sr = P({ "node_modules/postcss/lib/stringifier.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = { colon: ": ", indent: "    ", beforeDecl: `
`, beforeRule: `
`, beforeOpen: " ", beforeClose: `
`, beforeComment: `
`, after: `
`, emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false };
          function u(l) {
            return l[0].toUpperCase() + l.slice(1);
          }
          var o = (function() {
            function l(m) {
              this.builder = m;
            }
            var p = l.prototype;
            return p.stringify = function(c2, t) {
              this[c2.type](c2, t);
            }, p.root = function(c2) {
              this.body(c2), c2.raws.after && this.builder(c2.raws.after);
            }, p.comment = function(c2) {
              var t = this.raw(c2, "left", "commentLeft"), r2 = this.raw(c2, "right", "commentRight");
              this.builder("/*" + t + c2.text + r2 + "*/", c2);
            }, p.decl = function(c2, t) {
              var r2 = this.raw(c2, "between", "colon"), a = c2.prop + r2 + this.rawValue(c2, "value");
              c2.important && (a += c2.raws.important || " !important"), t && (a += ";"), this.builder(a, c2);
            }, p.rule = function(c2) {
              this.block(c2, this.rawValue(c2, "selector")), c2.raws.ownSemicolon && this.builder(c2.raws.ownSemicolon, c2, "end");
            }, p.atrule = function(c2, t) {
              var r2 = "@" + c2.name, a = c2.params ? this.rawValue(c2, "params") : "";
              if (typeof c2.raws.afterName < "u" ? r2 += c2.raws.afterName : a && (r2 += " "), c2.nodes) this.block(c2, r2 + a);
              else {
                var s = (c2.raws.between || "") + (t ? ";" : "");
                this.builder(r2 + a + s, c2);
              }
            }, p.body = function(c2) {
              for (var t = c2.nodes.length - 1; t > 0 && c2.nodes[t].type === "comment"; ) t -= 1;
              for (var r2 = this.raw(c2, "semicolon"), a = 0; a < c2.nodes.length; a++) {
                var s = c2.nodes[a], f = this.raw(s, "before");
                f && this.builder(f), this.stringify(s, t !== a || r2);
              }
            }, p.block = function(c2, t) {
              var r2 = this.raw(c2, "between", "beforeOpen");
              this.builder(t + r2 + "{", c2, "start");
              var a;
              c2.nodes && c2.nodes.length ? (this.body(c2), a = this.raw(c2, "after")) : a = this.raw(c2, "after", "emptyBody"), a && this.builder(a), this.builder("}", c2, "end");
            }, p.raw = function(c2, t, r2) {
              var a;
              if (r2 || (r2 = t), t && (a = c2.raws[t], typeof a < "u")) return a;
              var s = c2.parent;
              if (r2 === "before" && (!s || s.type === "root" && s.first === c2)) return "";
              if (!s) return i[r2];
              var f = c2.root();
              if (f.rawCache || (f.rawCache = {}), typeof f.rawCache[r2] < "u") return f.rawCache[r2];
              if (r2 === "before" || r2 === "after") return this.beforeAfter(c2, r2);
              var g = "raw" + u(r2);
              return this[g] ? a = this[g](f, c2) : f.walk(function(v) {
                if (a = v.raws[t], typeof a < "u") return false;
              }), typeof a > "u" && (a = i[r2]), f.rawCache[r2] = a, a;
            }, p.rawSemicolon = function(c2) {
              var t;
              return c2.walk(function(r2) {
                if (r2.nodes && r2.nodes.length && r2.last.type === "decl" && (t = r2.raws.semicolon, typeof t < "u")) return false;
              }), t;
            }, p.rawEmptyBody = function(c2) {
              var t;
              return c2.walk(function(r2) {
                if (r2.nodes && r2.nodes.length === 0 && (t = r2.raws.after, typeof t < "u")) return false;
              }), t;
            }, p.rawIndent = function(c2) {
              if (c2.raws.indent) return c2.raws.indent;
              var t;
              return c2.walk(function(r2) {
                var a = r2.parent;
                if (a && a !== c2 && a.parent && a.parent === c2 && typeof r2.raws.before < "u") {
                  var s = r2.raws.before.split(`
`);
                  return t = s[s.length - 1], t = t.replace(/[^\s]/g, ""), false;
                }
              }), t;
            }, p.rawBeforeComment = function(c2, t) {
              var r2;
              return c2.walkComments(function(a) {
                if (typeof a.raws.before < "u") return r2 = a.raws.before, r2.indexOf(`
`) !== -1 && (r2 = r2.replace(/[^\n]+$/, "")), false;
              }), typeof r2 > "u" ? r2 = this.raw(t, null, "beforeDecl") : r2 && (r2 = r2.replace(/[^\s]/g, "")), r2;
            }, p.rawBeforeDecl = function(c2, t) {
              var r2;
              return c2.walkDecls(function(a) {
                if (typeof a.raws.before < "u") return r2 = a.raws.before, r2.indexOf(`
`) !== -1 && (r2 = r2.replace(/[^\n]+$/, "")), false;
              }), typeof r2 > "u" ? r2 = this.raw(t, null, "beforeRule") : r2 && (r2 = r2.replace(/[^\s]/g, "")), r2;
            }, p.rawBeforeRule = function(c2) {
              var t;
              return c2.walk(function(r2) {
                if (r2.nodes && (r2.parent !== c2 || c2.first !== r2) && typeof r2.raws.before < "u") return t = r2.raws.before, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
              }), t && (t = t.replace(/[^\s]/g, "")), t;
            }, p.rawBeforeClose = function(c2) {
              var t;
              return c2.walk(function(r2) {
                if (r2.nodes && r2.nodes.length > 0 && typeof r2.raws.after < "u") return t = r2.raws.after, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
              }), t && (t = t.replace(/[^\s]/g, "")), t;
            }, p.rawBeforeOpen = function(c2) {
              var t;
              return c2.walk(function(r2) {
                if (r2.type !== "decl" && (t = r2.raws.between, typeof t < "u")) return false;
              }), t;
            }, p.rawColon = function(c2) {
              var t;
              return c2.walkDecls(function(r2) {
                if (typeof r2.raws.between < "u") return t = r2.raws.between.replace(/[^\s:]/g, ""), false;
              }), t;
            }, p.beforeAfter = function(c2, t) {
              var r2;
              c2.type === "decl" ? r2 = this.raw(c2, null, "beforeDecl") : c2.type === "comment" ? r2 = this.raw(c2, null, "beforeComment") : t === "before" ? r2 = this.raw(c2, null, "beforeRule") : r2 = this.raw(c2, null, "beforeClose");
              for (var a = c2.parent, s = 0; a && a.type !== "root"; ) s += 1, a = a.parent;
              if (r2.indexOf(`
`) !== -1) {
                var f = this.raw(c2, null, "indent");
                if (f.length) for (var g = 0; g < s; g++) r2 += f;
              }
              return r2;
            }, p.rawValue = function(c2, t) {
              var r2 = c2[t], a = c2.raws[t];
              return a && a.value === r2 ? a.raw : r2;
            }, l;
          })(), h = o;
          e.default = h, n.exports = e.default;
        } }), ua = P({ "node_modules/postcss/lib/stringify.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = u(Sr());
          function u(l) {
            return l && l.__esModule ? l : { default: l };
          }
          function o(l, p) {
            var m = new i.default(p);
            m.stringify(l);
          }
          var h = o;
          e.default = h, n.exports = e.default;
        } }), Ft = P({ "node_modules/postcss/lib/node.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = h(aa()), u = h(Sr()), o = h(ua());
          function h(c2) {
            return c2 && c2.__esModule ? c2 : { default: c2 };
          }
          function l(c2, t) {
            var r2 = new c2.constructor();
            for (var a in c2) if (c2.hasOwnProperty(a)) {
              var s = c2[a], f = typeof s;
              a === "parent" && f === "object" ? t && (r2[a] = t) : a === "source" ? r2[a] = s : s instanceof Array ? r2[a] = s.map(function(g) {
                return l(g, r2);
              }) : (f === "object" && s !== null && (s = l(s)), r2[a] = s);
            }
            return r2;
          }
          var p = (function() {
            function c2(r2) {
              r2 === void 0 && (r2 = {}), this.raws = {};
              for (var a in r2) this[a] = r2[a];
            }
            var t = c2.prototype;
            return t.error = function(a, s) {
              if (s === void 0 && (s = {}), this.source) {
                var f = this.positionBy(s);
                return this.source.input.error(a, f.line, f.column, s);
              }
              return new i.default(a);
            }, t.warn = function(a, s, f) {
              var g = { node: this };
              for (var v in f) g[v] = f[v];
              return a.warn(s, g);
            }, t.remove = function() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }, t.toString = function(a) {
              a === void 0 && (a = o.default), a.stringify && (a = a.stringify);
              var s = "";
              return a(this, function(f) {
                s += f;
              }), s;
            }, t.clone = function(a) {
              a === void 0 && (a = {});
              var s = l(this);
              for (var f in a) s[f] = a[f];
              return s;
            }, t.cloneBefore = function(a) {
              a === void 0 && (a = {});
              var s = this.clone(a);
              return this.parent.insertBefore(this, s), s;
            }, t.cloneAfter = function(a) {
              a === void 0 && (a = {});
              var s = this.clone(a);
              return this.parent.insertAfter(this, s), s;
            }, t.replaceWith = function() {
              if (this.parent) {
                for (var a = arguments.length, s = new Array(a), f = 0; f < a; f++) s[f] = arguments[f];
                for (var g = 0, v = s; g < v.length; g++) {
                  var y = v[g];
                  this.parent.insertBefore(this, y);
                }
                this.remove();
              }
              return this;
            }, t.next = function() {
              if (this.parent) {
                var a = this.parent.index(this);
                return this.parent.nodes[a + 1];
              }
            }, t.prev = function() {
              if (this.parent) {
                var a = this.parent.index(this);
                return this.parent.nodes[a - 1];
              }
            }, t.before = function(a) {
              return this.parent.insertBefore(this, a), this;
            }, t.after = function(a) {
              return this.parent.insertAfter(this, a), this;
            }, t.toJSON = function() {
              var a = {};
              for (var s in this) if (this.hasOwnProperty(s) && s !== "parent") {
                var f = this[s];
                f instanceof Array ? a[s] = f.map(function(g) {
                  return typeof g == "object" && g.toJSON ? g.toJSON() : g;
                }) : typeof f == "object" && f.toJSON ? a[s] = f.toJSON() : a[s] = f;
              }
              return a;
            }, t.raw = function(a, s) {
              var f = new u.default();
              return f.raw(this, a, s);
            }, t.root = function() {
              for (var a = this; a.parent; ) a = a.parent;
              return a;
            }, t.cleanRaws = function(a) {
              delete this.raws.before, delete this.raws.after, a || delete this.raws.between;
            }, t.positionInside = function(a) {
              for (var s = this.toString(), f = this.source.start.column, g = this.source.start.line, v = 0; v < a; v++) s[v] === `
` ? (f = 1, g += 1) : f += 1;
              return { line: g, column: f };
            }, t.positionBy = function(a) {
              var s = this.source.start;
              if (a.index) s = this.positionInside(a.index);
              else if (a.word) {
                var f = this.toString().indexOf(a.word);
                f !== -1 && (s = this.positionInside(f));
              }
              return s;
            }, c2;
          })(), m = p;
          e.default = m, n.exports = e.default;
        } }), kr = P({ "node_modules/postcss/lib/comment.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = u(Ft());
          function u(p) {
            return p && p.__esModule ? p : { default: p };
          }
          function o(p, m) {
            p.prototype = Object.create(m.prototype), p.prototype.constructor = p, p.__proto__ = m;
          }
          var h = (function(p) {
            o(m, p);
            function m(c2) {
              var t;
              return t = p.call(this, c2) || this, t.type = "comment", t;
            }
            return m;
          })(i.default), l = h;
          e.default = l, n.exports = e.default;
        } }), ca = P({ "node_modules/postcss/lib/declaration.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = u(Ft());
          function u(p) {
            return p && p.__esModule ? p : { default: p };
          }
          function o(p, m) {
            p.prototype = Object.create(m.prototype), p.prototype.constructor = p, p.__proto__ = m;
          }
          var h = (function(p) {
            o(m, p);
            function m(c2) {
              var t;
              return t = p.call(this, c2) || this, t.type = "decl", t;
            }
            return m;
          })(i.default), l = h;
          e.default = l, n.exports = e.default;
        } }), Ut = P({ "node_modules/postcss/lib/tokenize.js"(e, n) {
          A(), e.__esModule = true, e.default = W;
          var i = "'".charCodeAt(0), u = '"'.charCodeAt(0), o = "\\".charCodeAt(0), h = "/".charCodeAt(0), l = `
`.charCodeAt(0), p = " ".charCodeAt(0), m = "\f".charCodeAt(0), c2 = "	".charCodeAt(0), t = "\r".charCodeAt(0), r2 = "[".charCodeAt(0), a = "]".charCodeAt(0), s = "(".charCodeAt(0), f = ")".charCodeAt(0), g = "{".charCodeAt(0), v = "}".charCodeAt(0), y = ";".charCodeAt(0), w = "*".charCodeAt(0), d = ":".charCodeAt(0), _ = "@".charCodeAt(0), k = /[ \n\t\r\f{}()'"\\;/[\]#]/g, x = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, N = /.[\\/("'\n]/, I = /[a-f0-9]/i;
          function W($, H) {
            H === void 0 && (H = {});
            var D = $.css.valueOf(), V = H.ignoreErrors, B, O, j, C, R, X, Z, Q, K, J, M, Y, G, E, S = D.length, b = -1, L = 1, q = 0, T = [], F = [];
            function z() {
              return q;
            }
            function ee(re) {
              throw $.error("Unclosed " + re, L, q - b);
            }
            function te() {
              return F.length === 0 && q >= S;
            }
            function ue(re) {
              if (F.length) return F.pop();
              if (!(q >= S)) {
                var ne = re ? re.ignoreUnclosed : false;
                switch (B = D.charCodeAt(q), (B === l || B === m || B === t && D.charCodeAt(q + 1) !== l) && (b = q, L += 1), B) {
                  case l:
                  case p:
                  case c2:
                  case t:
                  case m:
                    O = q;
                    do
                      O += 1, B = D.charCodeAt(O), B === l && (b = O, L += 1);
                    while (B === p || B === l || B === c2 || B === t || B === m);
                    E = ["space", D.slice(q, O)], q = O - 1;
                    break;
                  case r2:
                  case a:
                  case g:
                  case v:
                  case d:
                  case y:
                  case f:
                    var oe = String.fromCharCode(B);
                    E = [oe, oe, L, q - b];
                    break;
                  case s:
                    if (Y = T.length ? T.pop()[1] : "", G = D.charCodeAt(q + 1), Y === "url" && G !== i && G !== u && G !== p && G !== l && G !== c2 && G !== m && G !== t) {
                      O = q;
                      do {
                        if (J = false, O = D.indexOf(")", O + 1), O === -1) if (V || ne) {
                          O = q;
                          break;
                        } else ee("bracket");
                        for (M = O; D.charCodeAt(M - 1) === o; ) M -= 1, J = !J;
                      } while (J);
                      E = ["brackets", D.slice(q, O + 1), L, q - b, L, O - b], q = O;
                    } else O = D.indexOf(")", q + 1), X = D.slice(q, O + 1), O === -1 || N.test(X) ? E = ["(", "(", L, q - b] : (E = ["brackets", X, L, q - b, L, O - b], q = O);
                    break;
                  case i:
                  case u:
                    j = B === i ? "'" : '"', O = q;
                    do {
                      if (J = false, O = D.indexOf(j, O + 1), O === -1) if (V || ne) {
                        O = q + 1;
                        break;
                      } else ee("string");
                      for (M = O; D.charCodeAt(M - 1) === o; ) M -= 1, J = !J;
                    } while (J);
                    X = D.slice(q, O + 1), C = X.split(`
`), R = C.length - 1, R > 0 ? (Q = L + R, K = O - C[R].length) : (Q = L, K = b), E = ["string", D.slice(q, O + 1), L, q - b, Q, O - K], b = K, L = Q, q = O;
                    break;
                  case _:
                    k.lastIndex = q + 1, k.test(D), k.lastIndex === 0 ? O = D.length - 1 : O = k.lastIndex - 2, E = ["at-word", D.slice(q, O + 1), L, q - b, L, O - b], q = O;
                    break;
                  case o:
                    for (O = q, Z = true; D.charCodeAt(O + 1) === o; ) O += 1, Z = !Z;
                    if (B = D.charCodeAt(O + 1), Z && B !== h && B !== p && B !== l && B !== c2 && B !== t && B !== m && (O += 1, I.test(D.charAt(O)))) {
                      for (; I.test(D.charAt(O + 1)); ) O += 1;
                      D.charCodeAt(O + 1) === p && (O += 1);
                    }
                    E = ["word", D.slice(q, O + 1), L, q - b, L, O - b], q = O;
                    break;
                  default:
                    B === h && D.charCodeAt(q + 1) === w ? (O = D.indexOf("*/", q + 2) + 1, O === 0 && (V || ne ? O = D.length : ee("comment")), X = D.slice(q, O + 1), C = X.split(`
`), R = C.length - 1, R > 0 ? (Q = L + R, K = O - C[R].length) : (Q = L, K = b), E = ["comment", X, L, q - b, Q, O - K], b = K, L = Q, q = O) : (x.lastIndex = q + 1, x.test(D), x.lastIndex === 0 ? O = D.length - 1 : O = x.lastIndex - 2, E = ["word", D.slice(q, O + 1), L, q - b, L, O - b], T.push(E), q = O);
                    break;
                }
                return q++, E;
              }
            }
            function le(re) {
              F.push(re);
            }
            return { back: le, nextToken: ue, endOfFile: te, position: z };
          }
          n.exports = e.default;
        } }), la = P({ "node_modules/postcss/lib/parse.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = o($t()), u = o(xr());
          function o(p) {
            return p && p.__esModule ? p : { default: p };
          }
          function h(p, m) {
            var c2 = new u.default(p, m), t = new i.default(c2);
            try {
              t.parse();
            } catch (r2) {
              throw r2;
            }
            return t.root;
          }
          var l = h;
          e.default = l, n.exports = e.default;
        } }), Pf = P({ "node_modules/postcss/lib/list.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = { split: function(h, l, p) {
            for (var m = [], c2 = "", t = false, r2 = 0, a = false, s = false, f = 0; f < h.length; f++) {
              var g = h[f];
              a ? s ? s = false : g === "\\" ? s = true : g === a && (a = false) : g === '"' || g === "'" ? a = g : g === "(" ? r2 += 1 : g === ")" ? r2 > 0 && (r2 -= 1) : r2 === 0 && l.indexOf(g) !== -1 && (t = true), t ? (c2 !== "" && m.push(c2.trim()), c2 = "", t = false) : c2 += g;
            }
            return (p || c2 !== "") && m.push(c2.trim()), m;
          }, space: function(h) {
            var l = [" ", `
`, "	"];
            return i.split(h, l);
          }, comma: function(h) {
            return i.split(h, [","], true);
          } }, u = i;
          e.default = u, n.exports = e.default;
        } }), fa = P({ "node_modules/postcss/lib/rule.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = o(Or()), u = o(Pf());
          function o(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function h(t, r2) {
            for (var a = 0; a < r2.length; a++) {
              var s = r2[a];
              s.enumerable = s.enumerable || false, s.configurable = true, "value" in s && (s.writable = true), Object.defineProperty(t, s.key, s);
            }
          }
          function l(t, r2, a) {
            return r2 && h(t.prototype, r2), t;
          }
          function p(t, r2) {
            t.prototype = Object.create(r2.prototype), t.prototype.constructor = t, t.__proto__ = r2;
          }
          var m = (function(t) {
            p(r2, t);
            function r2(a) {
              var s;
              return s = t.call(this, a) || this, s.type = "rule", s.nodes || (s.nodes = []), s;
            }
            return l(r2, [{ key: "selectors", get: function() {
              return u.default.comma(this.selector);
            }, set: function(s) {
              var f = this.selector ? this.selector.match(/,\s*/) : null, g = f ? f[0] : "," + this.raw("between", "beforeOpen");
              this.selector = s.join(g);
            } }]), r2;
          })(i.default), c2 = m;
          e.default = c2, n.exports = e.default;
        } }), Or = P({ "node_modules/postcss/lib/container.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = h(ca()), u = h(kr()), o = h(Ft());
          function h(g) {
            return g && g.__esModule ? g : { default: g };
          }
          function l(g, v) {
            var y;
            if (typeof Symbol > "u" || g[Symbol.iterator] == null) {
              if (Array.isArray(g) || (y = p(g)) || v) {
                y && (g = y);
                var w = 0;
                return function() {
                  return w >= g.length ? { done: true } : { done: false, value: g[w++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return y = g[Symbol.iterator](), y.next.bind(y);
          }
          function p(g, v) {
            if (g) {
              if (typeof g == "string") return m(g, v);
              var y = Object.prototype.toString.call(g).slice(8, -1);
              if (y === "Object" && g.constructor && (y = g.constructor.name), y === "Map" || y === "Set") return Array.from(g);
              if (y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y)) return m(g, v);
            }
          }
          function m(g, v) {
            (v == null || v > g.length) && (v = g.length);
            for (var y = 0, w = new Array(v); y < v; y++) w[y] = g[y];
            return w;
          }
          function c2(g, v) {
            for (var y = 0; y < v.length; y++) {
              var w = v[y];
              w.enumerable = w.enumerable || false, w.configurable = true, "value" in w && (w.writable = true), Object.defineProperty(g, w.key, w);
            }
          }
          function t(g, v, y) {
            return v && c2(g.prototype, v), g;
          }
          function r2(g, v) {
            g.prototype = Object.create(v.prototype), g.prototype.constructor = g, g.__proto__ = v;
          }
          function a(g) {
            return g.map(function(v) {
              return v.nodes && (v.nodes = a(v.nodes)), delete v.source, v;
            });
          }
          var s = (function(g) {
            r2(v, g);
            function v() {
              return g.apply(this, arguments) || this;
            }
            var y = v.prototype;
            return y.push = function(d) {
              return d.parent = this, this.nodes.push(d), this;
            }, y.each = function(d) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
              var _ = this.lastEach;
              if (this.indexes[_] = 0, !!this.nodes) {
                for (var k, x; this.indexes[_] < this.nodes.length && (k = this.indexes[_], x = d(this.nodes[k], k), x !== false); ) this.indexes[_] += 1;
                return delete this.indexes[_], x;
              }
            }, y.walk = function(d) {
              return this.each(function(_, k) {
                var x;
                try {
                  x = d(_, k);
                } catch (I) {
                  if (I.postcssNode = _, I.stack && _.source && /\n\s{4}at /.test(I.stack)) {
                    var N = _.source;
                    I.stack = I.stack.replace(/\n\s{4}at /, "$&" + N.input.from + ":" + N.start.line + ":" + N.start.column + "$&");
                  }
                  throw I;
                }
                return x !== false && _.walk && (x = _.walk(d)), x;
              });
            }, y.walkDecls = function(d, _) {
              return _ ? d instanceof RegExp ? this.walk(function(k, x) {
                if (k.type === "decl" && d.test(k.prop)) return _(k, x);
              }) : this.walk(function(k, x) {
                if (k.type === "decl" && k.prop === d) return _(k, x);
              }) : (_ = d, this.walk(function(k, x) {
                if (k.type === "decl") return _(k, x);
              }));
            }, y.walkRules = function(d, _) {
              return _ ? d instanceof RegExp ? this.walk(function(k, x) {
                if (k.type === "rule" && d.test(k.selector)) return _(k, x);
              }) : this.walk(function(k, x) {
                if (k.type === "rule" && k.selector === d) return _(k, x);
              }) : (_ = d, this.walk(function(k, x) {
                if (k.type === "rule") return _(k, x);
              }));
            }, y.walkAtRules = function(d, _) {
              return _ ? d instanceof RegExp ? this.walk(function(k, x) {
                if (k.type === "atrule" && d.test(k.name)) return _(k, x);
              }) : this.walk(function(k, x) {
                if (k.type === "atrule" && k.name === d) return _(k, x);
              }) : (_ = d, this.walk(function(k, x) {
                if (k.type === "atrule") return _(k, x);
              }));
            }, y.walkComments = function(d) {
              return this.walk(function(_, k) {
                if (_.type === "comment") return d(_, k);
              });
            }, y.append = function() {
              for (var d = arguments.length, _ = new Array(d), k = 0; k < d; k++) _[k] = arguments[k];
              for (var x = 0, N = _; x < N.length; x++) for (var I = N[x], W = this.normalize(I, this.last), $ = l(W), H; !(H = $()).done; ) {
                var D = H.value;
                this.nodes.push(D);
              }
              return this;
            }, y.prepend = function() {
              for (var d = arguments.length, _ = new Array(d), k = 0; k < d; k++) _[k] = arguments[k];
              _ = _.reverse();
              for (var x = l(_), N; !(N = x()).done; ) {
                for (var I = N.value, W = this.normalize(I, this.first, "prepend").reverse(), $ = l(W), H; !(H = $()).done; ) {
                  var D = H.value;
                  this.nodes.unshift(D);
                }
                for (var V in this.indexes) this.indexes[V] = this.indexes[V] + W.length;
              }
              return this;
            }, y.cleanRaws = function(d) {
              if (g.prototype.cleanRaws.call(this, d), this.nodes) for (var _ = l(this.nodes), k; !(k = _()).done; ) {
                var x = k.value;
                x.cleanRaws(d);
              }
            }, y.insertBefore = function(d, _) {
              d = this.index(d);
              for (var k = d === 0 ? "prepend" : false, x = this.normalize(_, this.nodes[d], k).reverse(), N = l(x), I; !(I = N()).done; ) {
                var W = I.value;
                this.nodes.splice(d, 0, W);
              }
              var $;
              for (var H in this.indexes) $ = this.indexes[H], d <= $ && (this.indexes[H] = $ + x.length);
              return this;
            }, y.insertAfter = function(d, _) {
              d = this.index(d);
              for (var k = this.normalize(_, this.nodes[d]).reverse(), x = l(k), N; !(N = x()).done; ) {
                var I = N.value;
                this.nodes.splice(d + 1, 0, I);
              }
              var W;
              for (var $ in this.indexes) W = this.indexes[$], d < W && (this.indexes[$] = W + k.length);
              return this;
            }, y.removeChild = function(d) {
              d = this.index(d), this.nodes[d].parent = void 0, this.nodes.splice(d, 1);
              var _;
              for (var k in this.indexes) _ = this.indexes[k], _ >= d && (this.indexes[k] = _ - 1);
              return this;
            }, y.removeAll = function() {
              for (var d = l(this.nodes), _; !(_ = d()).done; ) {
                var k = _.value;
                k.parent = void 0;
              }
              return this.nodes = [], this;
            }, y.replaceValues = function(d, _, k) {
              return k || (k = _, _ = {}), this.walkDecls(function(x) {
                _.props && _.props.indexOf(x.prop) === -1 || _.fast && x.value.indexOf(_.fast) === -1 || (x.value = x.value.replace(d, k));
              }), this;
            }, y.every = function(d) {
              return this.nodes.every(d);
            }, y.some = function(d) {
              return this.nodes.some(d);
            }, y.index = function(d) {
              return typeof d == "number" ? d : this.nodes.indexOf(d);
            }, y.normalize = function(d, _) {
              var k = this;
              if (typeof d == "string") {
                var x = la();
                d = a(x(d).nodes);
              } else if (Array.isArray(d)) {
                d = d.slice(0);
                for (var N = l(d), I; !(I = N()).done; ) {
                  var W = I.value;
                  W.parent && W.parent.removeChild(W, "ignore");
                }
              } else if (d.type === "root") {
                d = d.nodes.slice(0);
                for (var $ = l(d), H; !(H = $()).done; ) {
                  var D = H.value;
                  D.parent && D.parent.removeChild(D, "ignore");
                }
              } else if (d.type) d = [d];
              else if (d.prop) {
                if (typeof d.value > "u") throw new Error("Value field is missed in node creation");
                typeof d.value != "string" && (d.value = String(d.value)), d = [new i.default(d)];
              } else if (d.selector) {
                var V = fa();
                d = [new V(d)];
              } else if (d.name) {
                var B = pa();
                d = [new B(d)];
              } else if (d.text) d = [new u.default(d)];
              else throw new Error("Unknown node type in node creation");
              var O = d.map(function(j) {
                return j.parent && j.parent.removeChild(j), typeof j.raws.before > "u" && _ && typeof _.raws.before < "u" && (j.raws.before = _.raws.before.replace(/[^\s]/g, "")), j.parent = k, j;
              });
              return O;
            }, t(v, [{ key: "first", get: function() {
              if (this.nodes) return this.nodes[0];
            } }, { key: "last", get: function() {
              if (this.nodes) return this.nodes[this.nodes.length - 1];
            } }]), v;
          })(o.default), f = s;
          e.default = f, n.exports = e.default;
        } }), pa = P({ "node_modules/postcss/lib/at-rule.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = u(Or());
          function u(p) {
            return p && p.__esModule ? p : { default: p };
          }
          function o(p, m) {
            p.prototype = Object.create(m.prototype), p.prototype.constructor = p, p.__proto__ = m;
          }
          var h = (function(p) {
            o(m, p);
            function m(t) {
              var r2;
              return r2 = p.call(this, t) || this, r2.type = "atrule", r2;
            }
            var c2 = m.prototype;
            return c2.append = function() {
              var r2;
              this.nodes || (this.nodes = []);
              for (var a = arguments.length, s = new Array(a), f = 0; f < a; f++) s[f] = arguments[f];
              return (r2 = p.prototype.append).call.apply(r2, [this].concat(s));
            }, c2.prepend = function() {
              var r2;
              this.nodes || (this.nodes = []);
              for (var a = arguments.length, s = new Array(a), f = 0; f < a; f++) s[f] = arguments[f];
              return (r2 = p.prototype.prepend).call.apply(r2, [this].concat(s));
            }, m;
          })(i.default), l = h;
          e.default = l, n.exports = e.default;
        } }), If = P({ "node_modules/postcss/lib/map-generator.js"(e, n) {
          A(), n.exports = class {
            generate() {
            }
          };
        } }), Rf = P({ "node_modules/postcss/lib/warn-once.js"(e, n) {
          A(), e.__esModule = true, e.default = u;
          var i = {};
          function u(o) {
            i[o] || (i[o] = true, typeof console < "u" && console.warn && console.warn(o));
          }
          n.exports = e.default;
        } }), Cf = P({ "node_modules/postcss/lib/warning.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = (function() {
            function o(l, p) {
              if (p === void 0 && (p = {}), this.type = "warning", this.text = l, p.node && p.node.source) {
                var m = p.node.positionBy(p);
                this.line = m.line, this.column = m.column;
              }
              for (var c2 in p) this[c2] = p[c2];
            }
            var h = o.prototype;
            return h.toString = function() {
              return this.node ? this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
            }, o;
          })(), u = i;
          e.default = u, n.exports = e.default;
        } }), Nf = P({ "node_modules/postcss/lib/result.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = u(Cf());
          function u(m) {
            return m && m.__esModule ? m : { default: m };
          }
          function o(m, c2) {
            for (var t = 0; t < c2.length; t++) {
              var r2 = c2[t];
              r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(m, r2.key, r2);
            }
          }
          function h(m, c2, t) {
            return c2 && o(m.prototype, c2), m;
          }
          var l = (function() {
            function m(t, r2, a) {
              this.processor = t, this.messages = [], this.root = r2, this.opts = a, this.css = void 0, this.map = void 0;
            }
            var c2 = m.prototype;
            return c2.toString = function() {
              return this.css;
            }, c2.warn = function(r2, a) {
              a === void 0 && (a = {}), a.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (a.plugin = this.lastPlugin.postcssPlugin);
              var s = new i.default(r2, a);
              return this.messages.push(s), s;
            }, c2.warnings = function() {
              return this.messages.filter(function(r2) {
                return r2.type === "warning";
              });
            }, h(m, [{ key: "content", get: function() {
              return this.css;
            } }]), m;
          })(), p = l;
          e.default = p, n.exports = e.default;
        } }), ha = P({ "node_modules/postcss/lib/lazy-result.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = p(If()), u = p(ua()); p(Rf()); var h = p(Nf()), l = p(la());
          function p(v) {
            return v && v.__esModule ? v : { default: v };
          }
          function m(v, y) {
            var w;
            if (typeof Symbol > "u" || v[Symbol.iterator] == null) {
              if (Array.isArray(v) || (w = c2(v)) || y) {
                w && (v = w);
                var d = 0;
                return function() {
                  return d >= v.length ? { done: true } : { done: false, value: v[d++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return w = v[Symbol.iterator](), w.next.bind(w);
          }
          function c2(v, y) {
            if (v) {
              if (typeof v == "string") return t(v, y);
              var w = Object.prototype.toString.call(v).slice(8, -1);
              if (w === "Object" && v.constructor && (w = v.constructor.name), w === "Map" || w === "Set") return Array.from(v);
              if (w === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w)) return t(v, y);
            }
          }
          function t(v, y) {
            (y == null || y > v.length) && (y = v.length);
            for (var w = 0, d = new Array(y); w < y; w++) d[w] = v[w];
            return d;
          }
          function r2(v, y) {
            for (var w = 0; w < y.length; w++) {
              var d = y[w];
              d.enumerable = d.enumerable || false, d.configurable = true, "value" in d && (d.writable = true), Object.defineProperty(v, d.key, d);
            }
          }
          function a(v, y, w) {
            return y && r2(v.prototype, y), v;
          }
          function s(v) {
            return typeof v == "object" && typeof v.then == "function";
          }
          var f = (function() {
            function v(w, d, _) {
              this.stringified = false, this.processed = false;
              var k;
              if (typeof d == "object" && d !== null && d.type === "root") k = d;
              else if (d instanceof v || d instanceof h.default) k = d.root, d.map && (typeof _.map > "u" && (_.map = {}), _.map.inline || (_.map.inline = false), _.map.prev = d.map);
              else {
                var x = l.default;
                _.syntax && (x = _.syntax.parse), _.parser && (x = _.parser), x.parse && (x = x.parse);
                try {
                  k = x(d, _);
                } catch (N) {
                  this.error = N;
                }
              }
              this.result = new h.default(w, k, _);
            }
            var y = v.prototype;
            return y.warnings = function() {
              return this.sync().warnings();
            }, y.toString = function() {
              return this.css;
            }, y.then = function(d, _) {
              return this.async().then(d, _);
            }, y.catch = function(d) {
              return this.async().catch(d);
            }, y.finally = function(d) {
              return this.async().then(d, d);
            }, y.handleError = function(d, _) {
              try {
                if (this.error = d, d.name === "CssSyntaxError" && !d.plugin) d.plugin = _.postcssPlugin, d.setMessage();
                else { var k, x, N, I, W; if (_.postcssVersion && false) ; }
              } catch ($) {
                console && console.error && console.error($);
              }
            }, y.asyncTick = function(d, _) {
              var k = this;
              if (this.plugin >= this.processor.plugins.length) return this.processed = true, d();
              try {
                var x = this.processor.plugins[this.plugin], N = this.run(x);
                this.plugin += 1, s(N) ? N.then(function() {
                  k.asyncTick(d, _);
                }).catch(function(I) {
                  k.handleError(I, x), k.processed = true, _(I);
                }) : this.asyncTick(d, _);
              } catch (I) {
                this.processed = true, _(I);
              }
            }, y.async = function() {
              var d = this;
              return this.processed ? new Promise(function(_, k) {
                d.error ? k(d.error) : _(d.stringify());
              }) : this.processing ? this.processing : (this.processing = new Promise(function(_, k) {
                if (d.error) return k(d.error);
                d.plugin = 0, d.asyncTick(_, k);
              }).then(function() {
                return d.processed = true, d.stringify();
              }), this.processing);
            }, y.sync = function() {
              if (this.processed) return this.result;
              if (this.processed = true, this.processing) throw new Error("Use process(css).then(cb) to work with async plugins");
              if (this.error) throw this.error;
              for (var d = m(this.result.processor.plugins), _; !(_ = d()).done; ) {
                var k = _.value, x = this.run(k);
                if (s(x)) throw new Error("Use process(css).then(cb) to work with async plugins");
              }
              return this.result;
            }, y.run = function(d) {
              this.result.lastPlugin = d;
              try {
                return d(this.result.root, this.result);
              } catch (_) {
                throw this.handleError(_, d), _;
              }
            }, y.stringify = function() {
              if (this.stringified) return this.result;
              this.stringified = true, this.sync();
              var d = this.result.opts, _ = u.default;
              d.syntax && (_ = d.syntax.stringify), d.stringifier && (_ = d.stringifier), _.stringify && (_ = _.stringify);
              var k = new i.default(_, this.result.root, this.result.opts), x = k.generate();
              return this.result.css = x[0], this.result.map = x[1], this.result;
            }, a(v, [{ key: "processor", get: function() {
              return this.result.processor;
            } }, { key: "opts", get: function() {
              return this.result.opts;
            } }, { key: "css", get: function() {
              return this.stringify().css;
            } }, { key: "content", get: function() {
              return this.stringify().content;
            } }, { key: "map", get: function() {
              return this.stringify().map;
            } }, { key: "root", get: function() {
              return this.sync().root;
            } }, { key: "messages", get: function() {
              return this.sync().messages;
            } }]), v;
          })(), g = f;
          e.default = g, n.exports = e.default;
        } }), jf = P({ "node_modules/postcss/lib/processor.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = u(ha());
          function u(c2) {
            return c2 && c2.__esModule ? c2 : { default: c2 };
          }
          function o(c2, t) {
            var r2;
            if (typeof Symbol > "u" || c2[Symbol.iterator] == null) {
              if (Array.isArray(c2) || (r2 = h(c2)) || t) {
                r2 && (c2 = r2);
                var a = 0;
                return function() {
                  return a >= c2.length ? { done: true } : { done: false, value: c2[a++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return r2 = c2[Symbol.iterator](), r2.next.bind(r2);
          }
          function h(c2, t) {
            if (c2) {
              if (typeof c2 == "string") return l(c2, t);
              var r2 = Object.prototype.toString.call(c2).slice(8, -1);
              if (r2 === "Object" && c2.constructor && (r2 = c2.constructor.name), r2 === "Map" || r2 === "Set") return Array.from(c2);
              if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2)) return l(c2, t);
            }
          }
          function l(c2, t) {
            (t == null || t > c2.length) && (t = c2.length);
            for (var r2 = 0, a = new Array(t); r2 < t; r2++) a[r2] = c2[r2];
            return a;
          }
          var p = (function() {
            function c2(r2) {
              r2 === void 0 && (r2 = []), this.version = "7.0.39", this.plugins = this.normalize(r2);
            }
            var t = c2.prototype;
            return t.use = function(a) {
              return this.plugins = this.plugins.concat(this.normalize([a])), this;
            }, t.process = (function(r2) {
              function a(s) {
                return r2.apply(this, arguments);
              }
              return a.toString = function() {
                return r2.toString();
              }, a;
            })(function(r2, a) {
              return a === void 0 && (a = {}), this.plugins.length === 0 && (a.parser, a.stringifier), new i.default(this, r2, a);
            }), t.normalize = function(a) {
              for (var s = [], f = o(a), g; !(g = f()).done; ) {
                var v = g.value;
                if (v.postcss === true) {
                  var y = v();
                  throw new Error("PostCSS plugin " + y.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`);
                }
                if (v.postcss && (v = v.postcss), typeof v == "object" && Array.isArray(v.plugins)) s = s.concat(v.plugins);
                else if (typeof v == "function") s.push(v);
                else if (!(typeof v == "object" && (v.parse || v.stringify))) throw typeof v == "object" && v.postcssPlugin ? new Error("PostCSS plugin " + v.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`) : new Error(v + " is not a PostCSS plugin");
              }
              return s;
            }, c2;
          })(), m = p;
          e.default = m, n.exports = e.default;
        } }), Mf = P({ "node_modules/postcss/lib/root.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = u(Or());
          function u(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function o(t, r2) {
            var a;
            if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
              if (Array.isArray(t) || (a = h(t)) || r2) {
                a && (t = a);
                var s = 0;
                return function() {
                  return s >= t.length ? { done: true } : { done: false, value: t[s++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return a = t[Symbol.iterator](), a.next.bind(a);
          }
          function h(t, r2) {
            if (t) {
              if (typeof t == "string") return l(t, r2);
              var a = Object.prototype.toString.call(t).slice(8, -1);
              if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
              if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return l(t, r2);
            }
          }
          function l(t, r2) {
            (r2 == null || r2 > t.length) && (r2 = t.length);
            for (var a = 0, s = new Array(r2); a < r2; a++) s[a] = t[a];
            return s;
          }
          function p(t, r2) {
            t.prototype = Object.create(r2.prototype), t.prototype.constructor = t, t.__proto__ = r2;
          }
          var m = (function(t) {
            p(r2, t);
            function r2(s) {
              var f;
              return f = t.call(this, s) || this, f.type = "root", f.nodes || (f.nodes = []), f;
            }
            var a = r2.prototype;
            return a.removeChild = function(f, g) {
              var v = this.index(f);
              return !g && v === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[v].raws.before), t.prototype.removeChild.call(this, f);
            }, a.normalize = function(f, g, v) {
              var y = t.prototype.normalize.call(this, f);
              if (g) {
                if (v === "prepend") this.nodes.length > 1 ? g.raws.before = this.nodes[1].raws.before : delete g.raws.before;
                else if (this.first !== g) for (var w = o(y), d; !(d = w()).done; ) {
                  var _ = d.value;
                  _.raws.before = g.raws.before;
                }
              }
              return y;
            }, a.toResult = function(f) {
              f === void 0 && (f = {});
              var g = ha(), v = jf(), y = new g(new v(), this, f);
              return y.stringify();
            }, r2;
          })(i.default), c2 = m;
          e.default = c2, n.exports = e.default;
        } }), $t = P({ "node_modules/postcss/lib/parser.js"(e, n) {
          A(), e.__esModule = true, e.default = void 0;
          var i = m(ca()), u = m(Ut()), o = m(kr()), h = m(pa()), l = m(Mf()), p = m(fa());
          function m(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var c2 = (function() {
            function t(a) {
              this.input = a, this.root = new l.default(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: a, start: { line: 1, column: 1 } };
            }
            var r2 = t.prototype;
            return r2.createTokenizer = function() {
              this.tokenizer = (0, u.default)(this.input);
            }, r2.parse = function() {
              for (var s; !this.tokenizer.endOfFile(); ) switch (s = this.tokenizer.nextToken(), s[0]) {
                case "space":
                  this.spaces += s[1];
                  break;
                case ";":
                  this.freeSemicolon(s);
                  break;
                case "}":
                  this.end(s);
                  break;
                case "comment":
                  this.comment(s);
                  break;
                case "at-word":
                  this.atrule(s);
                  break;
                case "{":
                  this.emptyRule(s);
                  break;
                default:
                  this.other(s);
                  break;
              }
              this.endFile();
            }, r2.comment = function(s) {
              var f = new o.default();
              this.init(f, s[2], s[3]), f.source.end = { line: s[4], column: s[5] };
              var g = s[1].slice(2, -2);
              if (/^\s*$/.test(g)) f.text = "", f.raws.left = g, f.raws.right = "";
              else {
                var v = g.match(/^(\s*)([^]*[^\s])(\s*)$/);
                f.text = v[2], f.raws.left = v[1], f.raws.right = v[3];
              }
            }, r2.emptyRule = function(s) {
              var f = new p.default();
              this.init(f, s[2], s[3]), f.selector = "", f.raws.between = "", this.current = f;
            }, r2.other = function(s) {
              for (var f = false, g = null, v = false, y = null, w = [], d = [], _ = s; _; ) {
                if (g = _[0], d.push(_), g === "(" || g === "[") y || (y = _), w.push(g === "(" ? ")" : "]");
                else if (w.length === 0) if (g === ";") if (v) {
                  this.decl(d);
                  return;
                } else break;
                else if (g === "{") {
                  this.rule(d);
                  return;
                } else if (g === "}") {
                  this.tokenizer.back(d.pop()), f = true;
                  break;
                } else g === ":" && (v = true);
                else g === w[w.length - 1] && (w.pop(), w.length === 0 && (y = null));
                _ = this.tokenizer.nextToken();
              }
              if (this.tokenizer.endOfFile() && (f = true), w.length > 0 && this.unclosedBracket(y), f && v) {
                for (; d.length && (_ = d[d.length - 1][0], !(_ !== "space" && _ !== "comment")); ) this.tokenizer.back(d.pop());
                this.decl(d);
              } else this.unknownWord(d);
            }, r2.rule = function(s) {
              s.pop();
              var f = new p.default();
              this.init(f, s[0][2], s[0][3]), f.raws.between = this.spacesAndCommentsFromEnd(s), this.raw(f, "selector", s), this.current = f;
            }, r2.decl = function(s) {
              var f = new i.default();
              this.init(f);
              var g = s[s.length - 1];
              for (g[0] === ";" && (this.semicolon = true, s.pop()), g[4] ? f.source.end = { line: g[4], column: g[5] } : f.source.end = { line: g[2], column: g[3] }; s[0][0] !== "word"; ) s.length === 1 && this.unknownWord(s), f.raws.before += s.shift()[1];
              for (f.source.start = { line: s[0][2], column: s[0][3] }, f.prop = ""; s.length; ) {
                var v = s[0][0];
                if (v === ":" || v === "space" || v === "comment") break;
                f.prop += s.shift()[1];
              }
              f.raws.between = "";
              for (var y; s.length; ) if (y = s.shift(), y[0] === ":") {
                f.raws.between += y[1];
                break;
              } else y[0] === "word" && /\w/.test(y[1]) && this.unknownWord([y]), f.raws.between += y[1];
              (f.prop[0] === "_" || f.prop[0] === "*") && (f.raws.before += f.prop[0], f.prop = f.prop.slice(1)), f.raws.between += this.spacesAndCommentsFromStart(s), this.precheckMissedSemicolon(s);
              for (var w = s.length - 1; w > 0; w--) {
                if (y = s[w], y[1].toLowerCase() === "!important") {
                  f.important = true;
                  var d = this.stringFrom(s, w);
                  d = this.spacesFromEnd(s) + d, d !== " !important" && (f.raws.important = d);
                  break;
                } else if (y[1].toLowerCase() === "important") {
                  for (var _ = s.slice(0), k = "", x = w; x > 0; x--) {
                    var N = _[x][0];
                    if (k.trim().indexOf("!") === 0 && N !== "space") break;
                    k = _.pop()[1] + k;
                  }
                  k.trim().indexOf("!") === 0 && (f.important = true, f.raws.important = k, s = _);
                }
                if (y[0] !== "space" && y[0] !== "comment") break;
              }
              this.raw(f, "value", s), f.value.indexOf(":") !== -1 && this.checkMissedSemicolon(s);
            }, r2.atrule = function(s) {
              var f = new h.default();
              f.name = s[1].slice(1), f.name === "" && this.unnamedAtrule(f, s), this.init(f, s[2], s[3]);
              for (var g, v, y = false, w = false, d = []; !this.tokenizer.endOfFile(); ) {
                if (s = this.tokenizer.nextToken(), s[0] === ";") {
                  f.source.end = { line: s[2], column: s[3] }, this.semicolon = true;
                  break;
                } else if (s[0] === "{") {
                  w = true;
                  break;
                } else if (s[0] === "}") {
                  if (d.length > 0) {
                    for (v = d.length - 1, g = d[v]; g && g[0] === "space"; ) g = d[--v];
                    g && (f.source.end = { line: g[4], column: g[5] });
                  }
                  this.end(s);
                  break;
                } else d.push(s);
                if (this.tokenizer.endOfFile()) {
                  y = true;
                  break;
                }
              }
              f.raws.between = this.spacesAndCommentsFromEnd(d), d.length ? (f.raws.afterName = this.spacesAndCommentsFromStart(d), this.raw(f, "params", d), y && (s = d[d.length - 1], f.source.end = { line: s[4], column: s[5] }, this.spaces = f.raws.between, f.raws.between = "")) : (f.raws.afterName = "", f.params = ""), w && (f.nodes = [], this.current = f);
            }, r2.end = function(s) {
              this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = { line: s[2], column: s[3] }, this.current = this.current.parent) : this.unexpectedClose(s);
            }, r2.endFile = function() {
              this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
            }, r2.freeSemicolon = function(s) {
              if (this.spaces += s[1], this.current.nodes) {
                var f = this.current.nodes[this.current.nodes.length - 1];
                f && f.type === "rule" && !f.raws.ownSemicolon && (f.raws.ownSemicolon = this.spaces, this.spaces = "");
              }
            }, r2.init = function(s, f, g) {
              this.current.push(s), s.source = { start: { line: f, column: g }, input: this.input }, s.raws.before = this.spaces, this.spaces = "", s.type !== "comment" && (this.semicolon = false);
            }, r2.raw = function(s, f, g) {
              for (var v, y, w = g.length, d = "", _ = true, k, x, N = /^([.|#])?([\w])+/i, I = 0; I < w; I += 1) {
                if (v = g[I], y = v[0], y === "comment" && s.type === "rule") {
                  x = g[I - 1], k = g[I + 1], x[0] !== "space" && k[0] !== "space" && N.test(x[1]) && N.test(k[1]) ? d += v[1] : _ = false;
                  continue;
                }
                y === "comment" || y === "space" && I === w - 1 ? _ = false : d += v[1];
              }
              if (!_) {
                var W = g.reduce(function($, H) {
                  return $ + H[1];
                }, "");
                s.raws[f] = { value: d, raw: W };
              }
              s[f] = d;
            }, r2.spacesAndCommentsFromEnd = function(s) {
              for (var f, g = ""; s.length && (f = s[s.length - 1][0], !(f !== "space" && f !== "comment")); ) g = s.pop()[1] + g;
              return g;
            }, r2.spacesAndCommentsFromStart = function(s) {
              for (var f, g = ""; s.length && (f = s[0][0], !(f !== "space" && f !== "comment")); ) g += s.shift()[1];
              return g;
            }, r2.spacesFromEnd = function(s) {
              for (var f, g = ""; s.length && (f = s[s.length - 1][0], f === "space"); ) g = s.pop()[1] + g;
              return g;
            }, r2.stringFrom = function(s, f) {
              for (var g = "", v = f; v < s.length; v++) g += s[v][1];
              return s.splice(f, s.length - f), g;
            }, r2.colon = function(s) {
              for (var f = 0, g, v, y, w = 0; w < s.length; w++) {
                if (g = s[w], v = g[0], v === "(" && (f += 1), v === ")" && (f -= 1), f === 0 && v === ":") if (!y) this.doubleColon(g);
                else {
                  if (y[0] === "word" && y[1] === "progid") continue;
                  return w;
                }
                y = g;
              }
              return false;
            }, r2.unclosedBracket = function(s) {
              throw this.input.error("Unclosed bracket", s[2], s[3]);
            }, r2.unknownWord = function(s) {
              throw this.input.error("Unknown word", s[0][2], s[0][3]);
            }, r2.unexpectedClose = function(s) {
              throw this.input.error("Unexpected }", s[2], s[3]);
            }, r2.unclosedBlock = function() {
              var s = this.current.source.start;
              throw this.input.error("Unclosed block", s.line, s.column);
            }, r2.doubleColon = function(s) {
              throw this.input.error("Double colon", s[2], s[3]);
            }, r2.unnamedAtrule = function(s, f) {
              throw this.input.error("At-rule without name", f[2], f[3]);
            }, r2.precheckMissedSemicolon = function() {
            }, r2.checkMissedSemicolon = function(s) {
              var f = this.colon(s);
              if (f !== false) {
                for (var g = 0, v, y = f - 1; y >= 0 && (v = s[y], !(v[0] !== "space" && (g += 1, g === 2))); y--) ;
                throw this.input.error("Missed semicolon", v[2], v[3]);
              }
            }, t;
          })();
          e.default = c2, n.exports = e.default;
        } }), Df = P({ "node_modules/postcss-less/lib/nodes/inline-comment.js"(e, n) {
          A();
          var i = Ut(), u = xr();
          n.exports = { isInlineComment(o) {
            if (o[0] === "word" && o[1].slice(0, 2) === "//") {
              let h = o, l = [], p;
              for (; o; ) {
                if (/\r?\n/.test(o[1])) {
                  if (/['"].*\r?\n/.test(o[1])) {
                    l.push(o[1].substring(0, o[1].indexOf(`
`)));
                    let c2 = o[1].substring(o[1].indexOf(`
`));
                    c2 += this.input.css.valueOf().substring(this.tokenizer.position()), this.input = new u(c2), this.tokenizer = i(this.input);
                  } else this.tokenizer.back(o);
                  break;
                }
                l.push(o[1]), p = o, o = this.tokenizer.nextToken({ ignoreUnclosed: true });
              }
              let m = ["comment", l.join(""), h[2], h[3], p[2], p[3]];
              return this.inlineComment(m), true;
            } else if (o[1] === "/") {
              let h = this.tokenizer.nextToken({ ignoreUnclosed: true });
              if (h[0] === "comment" && /^\/\*/.test(h[1])) return h[0] = "word", h[1] = h[1].slice(1), o[1] = "//", this.tokenizer.back(h), n.exports.isInlineComment.bind(this)(o);
            }
            return false;
          } };
        } }), Lf = P({ "node_modules/postcss-less/lib/nodes/interpolation.js"(e, n) {
          A(), n.exports = { interpolation(i) {
            let u = i, o = [i], h = ["word", "{", "}"];
            if (i = this.tokenizer.nextToken(), u[1].length > 1 || i[0] !== "{") return this.tokenizer.back(i), false;
            for (; i && h.includes(i[0]); ) o.push(i), i = this.tokenizer.nextToken();
            let l = o.map((r2) => r2[1]);
            [u] = o;
            let p = o.pop(), m = [u[2], u[3]], c2 = [p[4] || p[2], p[5] || p[3]], t = ["word", l.join("")].concat(m, c2);
            return this.tokenizer.back(i), this.tokenizer.back(t), true;
          } };
        } }), zf = P({ "node_modules/postcss-less/lib/nodes/mixin.js"(e, n) {
          A();
          var i = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, u = /\.[0-9]/, o = (h) => {
            let [, l] = h, [p] = l;
            return (p === "." || p === "#") && i.test(l) === false && u.test(l) === false;
          };
          n.exports = { isMixinToken: o };
        } }), Bf = P({ "node_modules/postcss-less/lib/nodes/import.js"(e, n) {
          A();
          var i = Ut(), u = /^url\((.+)\)/;
          n.exports = (o) => {
            let { name: h, params: l = "" } = o;
            if (h === "import" && l.length) {
              o.import = true;
              let p = i({ css: l });
              for (o.filename = l.replace(u, "$1"); !p.endOfFile(); ) {
                let [m, c2] = p.nextToken();
                if (m === "word" && c2 === "url") return;
                if (m === "brackets") {
                  o.options = c2, o.filename = l.replace(c2, "").trim();
                  break;
                }
              }
            }
          };
        } }), Ff = P({ "node_modules/postcss-less/lib/nodes/variable.js"(e, n) {
          A();
          var i = /:$/, u = /^:(\s+)?/;
          n.exports = (o) => {
            let { name: h, params: l = "" } = o;
            if (o.name.slice(-1) === ":") {
              if (i.test(h)) {
                let [p] = h.match(i);
                o.name = h.replace(p, ""), o.raws.afterName = p + (o.raws.afterName || ""), o.variable = true, o.value = o.params;
              }
              if (u.test(l)) {
                let [p] = l.match(u);
                o.value = l.replace(p, ""), o.raws.afterName = (o.raws.afterName || "") + p, o.variable = true;
              }
            }
          };
        } }), Uf = P({ "node_modules/postcss-less/lib/LessParser.js"(e, n) {
          A();
          var i = kr(), u = $t(), { isInlineComment: o } = Df(), { interpolation: h } = Lf(), { isMixinToken: l } = zf(), p = Bf(), m = Ff(), c2 = /(!\s*important)$/i;
          n.exports = class extends u {
            constructor() {
              super(...arguments), this.lastNode = null;
            }
            atrule(r2) {
              h.bind(this)(r2) || (super.atrule(r2), p(this.lastNode), m(this.lastNode));
            }
            decl() {
              super.decl(...arguments), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
            }
            each(r2) {
              r2[0][1] = ` ${r2[0][1]}`;
              let a = r2.findIndex((y) => y[0] === "("), s = r2.reverse().find((y) => y[0] === ")"), f = r2.reverse().indexOf(s), v = r2.splice(a, f).map((y) => y[1]).join("");
              for (let y of r2.reverse()) this.tokenizer.back(y);
              this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = v;
            }
            init(r2, a, s) {
              super.init(r2, a, s), this.lastNode = r2;
            }
            inlineComment(r2) {
              let a = new i(), s = r2[1].slice(2);
              if (this.init(a, r2[2], r2[3]), a.source.end = { line: r2[4], column: r2[5] }, a.inline = true, a.raws.begin = "//", /^\s*$/.test(s)) a.text = "", a.raws.left = s, a.raws.right = "";
              else {
                let f = s.match(/^(\s*)([^]*[^\s])(\s*)$/);
                [, a.raws.left, a.text, a.raws.right] = f;
              }
            }
            mixin(r2) {
              let [a] = r2, s = a[1].slice(0, 1), f = r2.findIndex((d) => d[0] === "brackets"), g = r2.findIndex((d) => d[0] === "("), v = "";
              if ((f < 0 || f > 3) && g > 0) {
                let d = r2.reduce((V, B, O) => B[0] === ")" ? O : V), k = r2.slice(g, d + g).map((V) => V[1]).join(""), [x] = r2.slice(g), N = [x[2], x[3]], [I] = r2.slice(d, d + 1), W = [I[2], I[3]], $ = ["brackets", k].concat(N, W), H = r2.slice(0, g), D = r2.slice(d + 1);
                r2 = H, r2.push($), r2 = r2.concat(D);
              }
              let y = [];
              for (let d of r2) if ((d[1] === "!" || y.length) && y.push(d), d[1] === "important") break;
              if (y.length) {
                let [d] = y, _ = r2.indexOf(d), k = y[y.length - 1], x = [d[2], d[3]], N = [k[4], k[5]], W = ["word", y.map(($) => $[1]).join("")].concat(x, N);
                r2.splice(_, y.length, W);
              }
              let w = r2.findIndex((d) => c2.test(d[1]));
              w > 0 && ([, v] = r2[w], r2.splice(w, 1));
              for (let d of r2.reverse()) this.tokenizer.back(d);
              this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = s, v && (this.lastNode.important = true, this.lastNode.raws.important = v);
            }
            other(r2) {
              o.bind(this)(r2) || super.other(r2);
            }
            rule(r2) {
              let a = r2[r2.length - 1], s = r2[r2.length - 2];
              if (s[0] === "at-word" && a[0] === "{" && (this.tokenizer.back(a), h.bind(this)(s))) {
                let g = this.tokenizer.nextToken();
                r2 = r2.slice(0, r2.length - 2).concat([g]);
                for (let v of r2.reverse()) this.tokenizer.back(v);
                return;
              }
              super.rule(r2), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
            }
            unknownWord(r2) {
              let [a] = r2;
              if (r2[0][1] === "each" && r2[1][0] === "(") {
                this.each(r2);
                return;
              }
              if (l(a)) {
                this.mixin(r2);
                return;
              }
              super.unknownWord(r2);
            }
          };
        } }), $f = P({ "node_modules/postcss-less/lib/LessStringifier.js"(e, n) {
          A();
          var i = Sr();
          n.exports = class extends i {
            atrule(o, h) {
              if (!o.mixin && !o.variable && !o.function) {
                super.atrule(o, h);
                return;
              }
              let p = `${o.function ? "" : o.raws.identifier || "@"}${o.name}`, m = o.params ? this.rawValue(o, "params") : "", c2 = o.raws.important || "";
              if (o.variable && (m = o.value), typeof o.raws.afterName < "u" ? p += o.raws.afterName : m && (p += " "), o.nodes) this.block(o, p + m + c2);
              else {
                let t = (o.raws.between || "") + c2 + (h ? ";" : "");
                this.builder(p + m + t, o);
              }
            }
            comment(o) {
              if (o.inline) {
                let h = this.raw(o, "left", "commentLeft"), l = this.raw(o, "right", "commentRight");
                this.builder(`//${h}${o.text}${l}`, o);
              } else super.comment(o);
            }
          };
        } }), Wf = P({ "node_modules/postcss-less/lib/index.js"(e, n) {
          A();
          var i = xr(), u = Uf(), o = $f();
          n.exports = { parse(h, l) {
            let p = new i(h, l), m = new u(p);
            return m.parse(), m.root;
          }, stringify(h, l) {
            new o(l).stringify(h);
          }, nodeToString(h) {
            let l = "";
            return n.exports.stringify(h, (p) => {
              l += p;
            }), l;
          } };
        } }), Vf = P({ "node_modules/postcss-scss/lib/scss-stringifier.js"(e, n) {
          A();
          function i(h, l) {
            h.prototype = Object.create(l.prototype), h.prototype.constructor = h, h.__proto__ = l;
          }
          var u = Sr(), o = (function(h) {
            i(l, h);
            function l() {
              return h.apply(this, arguments) || this;
            }
            var p = l.prototype;
            return p.comment = function(c2) {
              var t = this.raw(c2, "left", "commentLeft"), r2 = this.raw(c2, "right", "commentRight");
              if (c2.raws.inline) {
                var a = c2.raws.text || c2.text;
                this.builder("//" + t + a + r2, c2);
              } else this.builder("/*" + t + c2.text + r2 + "*/", c2);
            }, p.decl = function(c2, t) {
              if (!c2.isNested) h.prototype.decl.call(this, c2, t);
              else {
                var r2 = this.raw(c2, "between", "colon"), a = c2.prop + r2 + this.rawValue(c2, "value");
                c2.important && (a += c2.raws.important || " !important"), this.builder(a + "{", c2, "start");
                var s;
                c2.nodes && c2.nodes.length ? (this.body(c2), s = this.raw(c2, "after")) : s = this.raw(c2, "after", "emptyBody"), s && this.builder(s), this.builder("}", c2, "end");
              }
            }, p.rawValue = function(c2, t) {
              var r2 = c2[t], a = c2.raws[t];
              return a && a.value === r2 ? a.scss ? a.scss : a.raw : r2;
            }, l;
          })(u);
          n.exports = o;
        } }), Gf = P({ "node_modules/postcss-scss/lib/scss-stringify.js"(e, n) {
          A();
          var i = Vf();
          n.exports = function(o, h) {
            var l = new i(h);
            l.stringify(o);
          };
        } }), Hf = P({ "node_modules/postcss-scss/lib/nested-declaration.js"(e, n) {
          A();
          function i(h, l) {
            h.prototype = Object.create(l.prototype), h.prototype.constructor = h, h.__proto__ = l;
          }
          var u = Or(), o = (function(h) {
            i(l, h);
            function l(p) {
              var m;
              return m = h.call(this, p) || this, m.type = "decl", m.isNested = true, m.nodes || (m.nodes = []), m;
            }
            return l;
          })(u);
          n.exports = o;
        } }), Jf = P({ "node_modules/postcss-scss/lib/scss-tokenize.js"(e, n) {
          A();
          var i = "'".charCodeAt(0), u = '"'.charCodeAt(0), o = "\\".charCodeAt(0), h = "/".charCodeAt(0), l = `
`.charCodeAt(0), p = " ".charCodeAt(0), m = "\f".charCodeAt(0), c2 = "	".charCodeAt(0), t = "\r".charCodeAt(0), r2 = "[".charCodeAt(0), a = "]".charCodeAt(0), s = "(".charCodeAt(0), f = ")".charCodeAt(0), g = "{".charCodeAt(0), v = "}".charCodeAt(0), y = ";".charCodeAt(0), w = "*".charCodeAt(0), d = ":".charCodeAt(0), _ = "@".charCodeAt(0), k = ",".charCodeAt(0), x = "#".charCodeAt(0), N = /[ \n\t\r\f{}()'"\\;/[\]#]/g, I = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, W = /.[\\/("'\n]/, $ = /[a-f0-9]/i, H = /[\r\f\n]/g;
          n.exports = function(V, B) {
            B === void 0 && (B = {});
            var O = V.css.valueOf(), j = B.ignoreErrors, C, R, X, Z, Q, K, J, M, Y, G, E, S, b, L, q = O.length, T = -1, F = 1, z = 0, ee = [], te = [];
            function ue(ie) {
              throw V.error("Unclosed " + ie, F, z - T);
            }
            function le() {
              return te.length === 0 && z >= q;
            }
            function re() {
              for (var ie = 1, ce = false, fe = false; ie > 0; ) R += 1, O.length <= R && ue("interpolation"), C = O.charCodeAt(R), S = O.charCodeAt(R + 1), ce ? !fe && C === ce ? (ce = false, fe = false) : C === o ? fe = !G : fe && (fe = false) : C === i || C === u ? ce = C : C === v ? ie -= 1 : C === x && S === g && (ie += 1);
            }
            function ne() {
              if (te.length) return te.pop();
              if (!(z >= q)) {
                switch (C = O.charCodeAt(z), (C === l || C === m || C === t && O.charCodeAt(z + 1) !== l) && (T = z, F += 1), C) {
                  case l:
                  case p:
                  case c2:
                  case t:
                  case m:
                    R = z;
                    do
                      R += 1, C = O.charCodeAt(R), C === l && (T = R, F += 1);
                    while (C === p || C === l || C === c2 || C === t || C === m);
                    b = ["space", O.slice(z, R)], z = R - 1;
                    break;
                  case r2:
                    b = ["[", "[", F, z - T];
                    break;
                  case a:
                    b = ["]", "]", F, z - T];
                    break;
                  case g:
                    b = ["{", "{", F, z - T];
                    break;
                  case v:
                    b = ["}", "}", F, z - T];
                    break;
                  case k:
                    b = ["word", ",", F, z - T, F, z - T + 1];
                    break;
                  case d:
                    b = [":", ":", F, z - T];
                    break;
                  case y:
                    b = [";", ";", F, z - T];
                    break;
                  case s:
                    if (E = ee.length ? ee.pop()[1] : "", S = O.charCodeAt(z + 1), E === "url" && S !== i && S !== u) {
                      for (L = 1, G = false, R = z + 1; R <= O.length - 1; ) {
                        if (S = O.charCodeAt(R), S === o) G = !G;
                        else if (S === s) L += 1;
                        else if (S === f && (L -= 1, L === 0)) break;
                        R += 1;
                      }
                      K = O.slice(z, R + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = R - Z[Q].length) : (M = F, Y = T), b = ["brackets", K, F, z - T, M, R - Y], T = Y, F = M, z = R;
                    } else R = O.indexOf(")", z + 1), K = O.slice(z, R + 1), R === -1 || W.test(K) ? b = ["(", "(", F, z - T] : (b = ["brackets", K, F, z - T, F, R - T], z = R);
                    break;
                  case f:
                    b = [")", ")", F, z - T];
                    break;
                  case i:
                  case u:
                    for (X = C, R = z, G = false; R < q && (R++, R === q && ue("string"), C = O.charCodeAt(R), S = O.charCodeAt(R + 1), !(!G && C === X)); ) C === o ? G = !G : G ? G = false : C === x && S === g && re();
                    K = O.slice(z, R + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = R - Z[Q].length) : (M = F, Y = T), b = ["string", O.slice(z, R + 1), F, z - T, M, R - Y], T = Y, F = M, z = R;
                    break;
                  case _:
                    N.lastIndex = z + 1, N.test(O), N.lastIndex === 0 ? R = O.length - 1 : R = N.lastIndex - 2, b = ["at-word", O.slice(z, R + 1), F, z - T, F, R - T], z = R;
                    break;
                  case o:
                    for (R = z, J = true; O.charCodeAt(R + 1) === o; ) R += 1, J = !J;
                    if (C = O.charCodeAt(R + 1), J && C !== h && C !== p && C !== l && C !== c2 && C !== t && C !== m && (R += 1, $.test(O.charAt(R)))) {
                      for (; $.test(O.charAt(R + 1)); ) R += 1;
                      O.charCodeAt(R + 1) === p && (R += 1);
                    }
                    b = ["word", O.slice(z, R + 1), F, z - T, F, R - T], z = R;
                    break;
                  default:
                    S = O.charCodeAt(z + 1), C === x && S === g ? (R = z, re(), K = O.slice(z, R + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = R - Z[Q].length) : (M = F, Y = T), b = ["word", K, F, z - T, M, R - Y], T = Y, F = M, z = R) : C === h && S === w ? (R = O.indexOf("*/", z + 2) + 1, R === 0 && (j ? R = O.length : ue("comment")), K = O.slice(z, R + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = R - Z[Q].length) : (M = F, Y = T), b = ["comment", K, F, z - T, M, R - Y], T = Y, F = M, z = R) : C === h && S === h ? (H.lastIndex = z + 1, H.test(O), H.lastIndex === 0 ? R = O.length - 1 : R = H.lastIndex - 2, K = O.slice(z, R + 1), b = ["comment", K, F, z - T, F, R - T, "inline"], z = R) : (I.lastIndex = z + 1, I.test(O), I.lastIndex === 0 ? R = O.length - 1 : R = I.lastIndex - 2, b = ["word", O.slice(z, R + 1), F, z - T, F, R - T], ee.push(b), z = R);
                    break;
                }
                return z++, b;
              }
            }
            function oe(ie) {
              te.push(ie);
            }
            return { back: oe, nextToken: ne, endOfFile: le };
          };
        } }), Kf = P({ "node_modules/postcss-scss/lib/scss-parser.js"(e, n) {
          A();
          function i(m, c2) {
            m.prototype = Object.create(c2.prototype), m.prototype.constructor = m, m.__proto__ = c2;
          }
          var u = kr(), o = $t(), h = Hf(), l = Jf(), p = (function(m) {
            i(c2, m);
            function c2() {
              return m.apply(this, arguments) || this;
            }
            var t = c2.prototype;
            return t.createTokenizer = function() {
              this.tokenizer = l(this.input);
            }, t.rule = function(a) {
              for (var s = false, f = 0, g = "", w = a, v = Array.isArray(w), y = 0, w = v ? w : w[Symbol.iterator](); ; ) {
                var d;
                if (v) {
                  if (y >= w.length) break;
                  d = w[y++];
                } else {
                  if (y = w.next(), y.done) break;
                  d = y.value;
                }
                var _ = d;
                if (s) _[0] !== "comment" && _[0] !== "{" && (g += _[1]);
                else {
                  if (_[0] === "space" && _[1].indexOf(`
`) !== -1) break;
                  _[0] === "(" ? f += 1 : _[0] === ")" ? f -= 1 : f === 0 && _[0] === ":" && (s = true);
                }
              }
              if (!s || g.trim() === "" || /^[a-zA-Z-:#]/.test(g)) m.prototype.rule.call(this, a);
              else {
                a.pop();
                var k = new h();
                this.init(k);
                var x = a[a.length - 1];
                for (x[4] ? k.source.end = { line: x[4], column: x[5] } : k.source.end = { line: x[2], column: x[3] }; a[0][0] !== "word"; ) k.raws.before += a.shift()[1];
                for (k.source.start = { line: a[0][2], column: a[0][3] }, k.prop = ""; a.length; ) {
                  var N = a[0][0];
                  if (N === ":" || N === "space" || N === "comment") break;
                  k.prop += a.shift()[1];
                }
                k.raws.between = "";
                for (var I; a.length; ) if (I = a.shift(), I[0] === ":") {
                  k.raws.between += I[1];
                  break;
                } else k.raws.between += I[1];
                (k.prop[0] === "_" || k.prop[0] === "*") && (k.raws.before += k.prop[0], k.prop = k.prop.slice(1)), k.raws.between += this.spacesAndCommentsFromStart(a), this.precheckMissedSemicolon(a);
                for (var W = a.length - 1; W > 0; W--) {
                  if (I = a[W], I[1] === "!important") {
                    k.important = true;
                    var $ = this.stringFrom(a, W);
                    $ = this.spacesFromEnd(a) + $, $ !== " !important" && (k.raws.important = $);
                    break;
                  } else if (I[1] === "important") {
                    for (var H = a.slice(0), D = "", V = W; V > 0; V--) {
                      var B = H[V][0];
                      if (D.trim().indexOf("!") === 0 && B !== "space") break;
                      D = H.pop()[1] + D;
                    }
                    D.trim().indexOf("!") === 0 && (k.important = true, k.raws.important = D, a = H);
                  }
                  if (I[0] !== "space" && I[0] !== "comment") break;
                }
                this.raw(k, "value", a), k.value.indexOf(":") !== -1 && this.checkMissedSemicolon(a), this.current = k;
              }
            }, t.comment = function(a) {
              if (a[6] === "inline") {
                var s = new u();
                this.init(s, a[2], a[3]), s.raws.inline = true, s.source.end = { line: a[4], column: a[5] };
                var f = a[1].slice(2);
                if (/^\s*$/.test(f)) s.text = "", s.raws.left = f, s.raws.right = "";
                else {
                  var g = f.match(/^(\s*)([^]*[^\s])(\s*)$/), v = g[2].replace(/(\*\/|\/\*)/g, "*//*");
                  s.text = v, s.raws.left = g[1], s.raws.right = g[3], s.raws.text = g[2];
                }
              } else m.prototype.comment.call(this, a);
            }, t.raw = function(a, s, f) {
              if (m.prototype.raw.call(this, a, s, f), a.raws[s]) {
                var g = a.raws[s].raw;
                a.raws[s].raw = f.reduce(function(v, y) {
                  if (y[0] === "comment" && y[6] === "inline") {
                    var w = y[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
                    return v + "/*" + w + "*/";
                  } else return v + y[1];
                }, ""), g !== a.raws[s].raw && (a.raws[s].scss = g);
              }
            }, c2;
          })(o);
          n.exports = p;
        } }), Qf = P({ "node_modules/postcss-scss/lib/scss-parse.js"(e, n) {
          A();
          var i = xr(), u = Kf();
          n.exports = function(h, l) {
            var p = new i(h, l), m = new u(p);
            return m.parse(), m.root;
          };
        } }), Yf = P({ "node_modules/postcss-scss/lib/scss-syntax.js"(e, n) {
          A();
          var i = Gf(), u = Qf();
          n.exports = { parse: u, stringify: i };
        } });
        A();
        var Xf = Sl(), mt = Us(), Zf = $s(), { hasPragma: ep } = Cl(), { locStart: rp, locEnd: tp } = no(), { calculateLoc: np, replaceQuotesInInlineComments: ip } = no(), sp = Dl(), op = Ll(), gt = zl(), da = Bl(), ap = Fl(), up = Ul(), cp = $l(), lp = Wl(), fp = (e) => {
          for (; e.parent; ) e = e.parent;
          return e;
        };
        function pp(e, n) {
          let { nodes: i } = e, u = { open: null, close: null, groups: [], type: "paren_group" }, o = [u], h = u, l = { groups: [], type: "comma_group" }, p = [l];
          for (let m = 0; m < i.length; ++m) {
            let c2 = i[m];
            if (da(n.parser, c2.value) && c2.type === "number" && c2.unit === ".." && mt(c2.value) === "." && (c2.value = c2.value.slice(0, -1), c2.unit = "..."), c2.type === "func" && c2.value === "selector" && (c2.group.groups = [Re(fp(e).text.slice(c2.group.open.sourceIndex + 1, c2.group.close.sourceIndex))]), c2.type === "func" && c2.value === "url") {
              let t = c2.group && c2.group.groups || [], r2 = [];
              for (let a = 0; a < t.length; a++) {
                let s = t[a];
                s.type === "comma_group" ? r2 = [...r2, ...s.groups] : r2.push(s);
              }
              if (sp(r2) || !op(r2) && !up(r2[0])) {
                let a = cp({ groups: c2.group.groups });
                c2.group.groups = [a.trim()];
              }
            }
            if (c2.type === "paren" && c2.value === "(") u = { open: c2, close: null, groups: [], type: "paren_group" }, o.push(u), l = { groups: [], type: "comma_group" }, p.push(l);
            else if (c2.type === "paren" && c2.value === ")") {
              if (l.groups.length > 0 && u.groups.push(l), u.close = c2, p.length === 1) throw new Error("Unbalanced parenthesis");
              p.pop(), l = mt(p), l.groups.push(u), o.pop(), u = mt(o);
            } else c2.type === "comma" ? (u.groups.push(l), l = { groups: [], type: "comma_group" }, p[p.length - 1] = l) : l.groups.push(c2);
          }
          return l.groups.length > 0 && u.groups.push(l), h;
        }
        function vr(e) {
          return e.type === "paren_group" && !e.open && !e.close && e.groups.length === 1 || e.type === "comma_group" && e.groups.length === 1 ? vr(e.groups[0]) : e.type === "paren_group" || e.type === "comma_group" ? Object.assign(Object.assign({}, e), {}, { groups: e.groups.map(vr) }) : e;
        }
        function Xe(e, n, i) {
          if (e && typeof e == "object") {
            delete e.parent;
            for (let u in e) Xe(e[u], n, i), u === "type" && typeof e[u] == "string" && !e[u].startsWith(n) && (!i || !i.test(e[u])) && (e[u] = n + e[u]);
          }
          return e;
        }
        function va(e) {
          if (e && typeof e == "object") {
            delete e.parent;
            for (let n in e) va(e[n]);
            !Array.isArray(e) && e.value && !e.type && (e.type = "unknown");
          }
          return e;
        }
        function ma(e, n) {
          if (e && typeof e == "object") {
            for (let i in e) i !== "parent" && (ma(e[i], n), i === "nodes" && (e.group = vr(pp(e, n)), delete e[i]));
            delete e.parent;
          }
          return e;
        }
        function Pe(e, n) {
          let i = gf(), u = null;
          try {
            u = i(e, { loose: true }).parse();
          } catch {
            return { type: "value-unknown", value: e };
          }
          u.text = e;
          let o = ma(u, n);
          return Xe(o, "value-", /^selector-/);
        }
        function Re(e) {
          if (/\/\/|\/\*/.test(e)) return { type: "selector-unknown", value: e.trim() };
          let n = xf(), i = null;
          try {
            n((u) => {
              i = u;
            }).process(e);
          } catch {
            return { type: "selector-unknown", value: e };
          }
          return Xe(i, "selector-");
        }
        function hp(e) {
          let n = kf().default, i = null;
          try {
            i = n(e);
          } catch {
            return { type: "selector-unknown", value: e };
          }
          return Xe(va(i), "media-");
        }
        var dp = /(\s*)(!default).*$/, vp = /(\s*)(!global).*$/;
        function ga(e, n) {
          if (e && typeof e == "object") {
            delete e.parent;
            for (let m in e) ga(e[m], n);
            if (!e.type) return e;
            e.raws || (e.raws = {});
            let h = "";
            if (typeof e.selector == "string") {
              var i;
              h = e.raws.selector ? (i = e.raws.selector.scss) !== null && i !== void 0 ? i : e.raws.selector.raw : e.selector, e.raws.between && e.raws.between.trim().length > 0 && (h += e.raws.between), e.raws.selector = h;
            }
            let l = "";
            if (typeof e.value == "string") {
              var u;
              l = e.raws.value ? (u = e.raws.value.scss) !== null && u !== void 0 ? u : e.raws.value.raw : e.value, l = l.trim(), e.raws.value = l;
            }
            let p = "";
            if (typeof e.params == "string") {
              var o;
              p = e.raws.params ? (o = e.raws.params.scss) !== null && o !== void 0 ? o : e.raws.params.raw : e.params, e.raws.afterName && e.raws.afterName.trim().length > 0 && (p = e.raws.afterName + p), e.raws.between && e.raws.between.trim().length > 0 && (p = p + e.raws.between), p = p.trim(), e.raws.params = p;
            }
            if (h.trim().length > 0) return h.startsWith("@") && h.endsWith(":") ? e : e.mixin ? (e.selector = Pe(h, n), e) : (ap(e) && (e.isSCSSNesterProperty = true), e.selector = Re(h), e);
            if (l.length > 0) {
              let m = l.match(dp);
              m && (l = l.slice(0, m.index), e.scssDefault = true, m[0].trim() !== "!default" && (e.raws.scssDefault = m[0]));
              let c2 = l.match(vp);
              if (c2 && (l = l.slice(0, c2.index), e.scssGlobal = true, c2[0].trim() !== "!global" && (e.raws.scssGlobal = c2[0])), l.startsWith("progid:")) return { type: "value-unknown", value: l };
              e.value = Pe(l, n);
            }
            if (gt(n) && e.type === "css-decl" && l.startsWith("extend(") && (e.extend || (e.extend = e.raws.between === ":"), e.extend && !e.selector && (delete e.value, e.selector = Re(l.slice(7, -1)))), e.type === "css-atrule") {
              if (gt(n)) {
                if (e.mixin) {
                  let m = e.raws.identifier + e.name + e.raws.afterName + e.raws.params;
                  return e.selector = Re(m), delete e.params, e;
                }
                if (e.function) return e;
              }
              if (n.parser === "css" && e.name === "custom-selector") {
                let m = e.params.match(/:--\S+\s+/)[0].trim();
                return e.customSelector = m, e.selector = Re(e.params.slice(m.length).trim()), delete e.params, e;
              }
              if (gt(n)) {
                if (e.name.includes(":") && !e.params) {
                  e.variable = true;
                  let m = e.name.split(":");
                  e.name = m[0], e.value = Pe(m.slice(1).join(":"), n);
                }
                if (!["page", "nest", "keyframes"].includes(e.name) && e.params && e.params[0] === ":") {
                  e.variable = true;
                  let m = e.params.slice(1);
                  m && (e.value = Pe(m, n)), e.raws.afterName += ":";
                }
                if (e.variable) return delete e.params, e.value || delete e.value, e;
              }
            }
            if (e.type === "css-atrule" && p.length > 0) {
              let { name: m } = e, c2 = e.name.toLowerCase();
              return m === "warn" || m === "error" ? (e.params = { type: "media-unknown", value: p }, e) : m === "extend" || m === "nest" ? (e.selector = Re(p), delete e.params, e) : m === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(p) ? e.params = Pe(p, n) : (e.selector = Re(p), delete e.params), e) : lp(c2) ? (e.import = true, delete e.filename, e.params = Pe(p, n), e) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(m) ? (p = p.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), p = p.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), e.value = Pe(p, n), delete e.params, e) : ["media", "custom-media"].includes(c2) ? p.includes("#{") ? { type: "media-unknown", value: p } : (e.params = hp(p), e) : (e.params = p, e);
            }
          }
          return e;
        }
        function ya(e, n, i) {
          let u = Zf(n), { frontMatter: o } = u;
          n = u.content;
          let h;
          try {
            h = e(n);
          } catch (l) {
            let { name: p, reason: m, line: c2, column: t } = l;
            throw typeof c2 != "number" ? l : Xf(`${p}: ${m}`, { start: { line: c2, column: t } });
          }
          return h = ga(Xe(h, "css-"), i), np(h, n), o && (o.source = { startOffset: 0, endOffset: o.raw.length }, h.nodes.unshift(o)), h;
        }
        function mp(e, n) {
          let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = da(i.parser, e) ? [Tt, Ot] : [Ot, Tt], h;
          for (let l of o) try {
            return l(e, n, i);
          } catch (p) {
            h = h || p;
          }
          if (h) throw h;
        }
        function Ot(e, n) {
          let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u = Wf();
          return ya((o) => u.parse(ip(o)), e, i);
        }
        function Tt(e, n) {
          let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, { parse: u } = Yf();
          return ya(u, e, i);
        }
        var yt = { astFormat: "postcss", hasPragma: ep, locStart: rp, locEnd: tp };
        wa.exports = { parsers: { css: Object.assign(Object.assign({}, yt), {}, { parse: mp }), less: Object.assign(Object.assign({}, yt), {}, { parse: Ot }), scss: Object.assign(Object.assign({}, yt), {}, { parse: Tt }) } };
      });
      return gp();
    });
  }
});

// ../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/standalone.js
var require_standalone = __commonJS({
  "../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/standalone.js"(exports, module) {
    init_esm_shims();
    (function(e) {
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var f = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        f.prettier = e();
      }
    })(function() {
      var xe = (e, r2) => () => (r2 || e((r2 = { exports: {} }).exports, r2), r2.exports);
      var pt = xe((r0, pu) => {
        var ir = function(e) {
          return e && e.Math == Math && e;
        };
        pu.exports = ir(typeof globalThis == "object" && globalThis) || ir(typeof window == "object" && window) || ir(typeof self == "object" && self) || ir(typeof global == "object" && global) || /* @__PURE__ */ (function() {
          return this;
        })() || Function("return this")();
      });
      var Dt = xe((n0, fu) => {
        fu.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var yt = xe((u0, Du) => {
        var Mo = Dt();
        Du.exports = !Mo(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var ar = xe((s0, mu) => {
        var Ro = Dt();
        mu.exports = !Ro(function() {
          var e = function() {
          }.bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var At = xe((i0, du) => {
        var $o = ar(), or = Function.prototype.call;
        du.exports = $o ? or.bind(or) : function() {
          return or.apply(or, arguments);
        };
      });
      var vu = xe((hu) => {
        var gu = {}.propertyIsEnumerable, yu = Object.getOwnPropertyDescriptor, Vo = yu && !gu.call({ 1: 2 }, 1);
        hu.f = Vo ? function(r2) {
          var t = yu(this, r2);
          return !!t && t.enumerable;
        } : gu;
      });
      var lr = xe((o0, Cu) => {
        Cu.exports = function(e, r2) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r2 };
        };
      });
      var mt = xe((l0, Au) => {
        var Eu = ar(), Fu = Function.prototype, Wr = Fu.call, Wo = Eu && Fu.bind.bind(Wr, Wr);
        Au.exports = Eu ? Wo : function(e) {
          return function() {
            return Wr.apply(e, arguments);
          };
        };
      });
      var Vt = xe((c0, xu) => {
        var Su = mt(), Ho = Su({}.toString), Go = Su("".slice);
        xu.exports = function(e) {
          return Go(Ho(e), 8, -1);
        };
      });
      var Tu = xe((p0, bu) => {
        var Uo = mt(), Jo = Dt(), zo = Vt(), Hr = Object, Xo = Uo("".split);
        bu.exports = Jo(function() {
          return !Hr("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return zo(e) == "String" ? Xo(e, "") : Hr(e);
        } : Hr;
      });
      var cr = xe((f0, Bu) => {
        Bu.exports = function(e) {
          return e == null;
        };
      });
      var Gr = xe((D0, Nu) => {
        var Ko = cr(), Yo = TypeError;
        Nu.exports = function(e) {
          if (Ko(e)) throw Yo("Can't call method on " + e);
          return e;
        };
      });
      var pr = xe((m0, wu) => {
        var Qo = Tu(), Zo = Gr();
        wu.exports = function(e) {
          return Qo(Zo(e));
        };
      });
      var Jr = xe((d0, _u) => {
        var Ur = typeof document == "object" && document.all, el = typeof Ur > "u" && Ur !== void 0;
        _u.exports = { all: Ur, IS_HTMLDDA: el };
      });
      var ot = xe((g0, Iu) => {
        var Pu = Jr(), tl = Pu.all;
        Iu.exports = Pu.IS_HTMLDDA ? function(e) {
          return typeof e == "function" || e === tl;
        } : function(e) {
          return typeof e == "function";
        };
      });
      var St = xe((y0, Ou) => {
        var ku = ot(), Lu = Jr(), rl = Lu.all;
        Ou.exports = Lu.IS_HTMLDDA ? function(e) {
          return typeof e == "object" ? e !== null : ku(e) || e === rl;
        } : function(e) {
          return typeof e == "object" ? e !== null : ku(e);
        };
      });
      var Wt = xe((h0, ju) => {
        var zr = pt(), nl = ot(), ul = function(e) {
          return nl(e) ? e : void 0;
        };
        ju.exports = function(e, r2) {
          return arguments.length < 2 ? ul(zr[e]) : zr[e] && zr[e][r2];
        };
      });
      var Xr = xe((v0, qu) => {
        var sl = mt();
        qu.exports = sl({}.isPrototypeOf);
      });
      var Ru = xe((C0, Mu) => {
        var il = Wt();
        Mu.exports = il("navigator", "userAgent") || "";
      });
      var Ju = xe((E0, Uu) => {
        var Gu = pt(), Kr = Ru(), $u = Gu.process, Vu = Gu.Deno, Wu = $u && $u.versions || Vu && Vu.version, Hu = Wu && Wu.v8, dt, fr;
        Hu && (dt = Hu.split("."), fr = dt[0] > 0 && dt[0] < 4 ? 1 : +(dt[0] + dt[1]));
        !fr && Kr && (dt = Kr.match(/Edge\/(\d+)/), (!dt || dt[1] >= 74) && (dt = Kr.match(/Chrome\/(\d+)/), dt && (fr = +dt[1])));
        Uu.exports = fr;
      });
      var Yr = xe((F0, Xu) => {
        var zu = Ju(), al = Dt();
        Xu.exports = !!Object.getOwnPropertySymbols && !al(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && zu && zu < 41;
        });
      });
      var Qr = xe((A0, Ku) => {
        var ol = Yr();
        Ku.exports = ol && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Zr = xe((S0, Yu) => {
        var ll = Wt(), cl = ot(), pl = Xr(), fl = Qr(), Dl = Object;
        Yu.exports = fl ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var r2 = ll("Symbol");
          return cl(r2) && pl(r2.prototype, Dl(e));
        };
      });
      var Dr = xe((x0, Qu) => {
        var ml = String;
        Qu.exports = function(e) {
          try {
            return ml(e);
          } catch {
            return "Object";
          }
        };
      });
      var Ht = xe((b0, Zu) => {
        var dl = ot(), gl = Dr(), yl = TypeError;
        Zu.exports = function(e) {
          if (dl(e)) return e;
          throw yl(gl(e) + " is not a function");
        };
      });
      var mr = xe((T0, es) => {
        var hl = Ht(), vl = cr();
        es.exports = function(e, r2) {
          var t = e[r2];
          return vl(t) ? void 0 : hl(t);
        };
      });
      var rs = xe((B0, ts) => {
        var en = At(), tn = ot(), rn = St(), Cl = TypeError;
        ts.exports = function(e, r2) {
          var t, s;
          if (r2 === "string" && tn(t = e.toString) && !rn(s = en(t, e)) || tn(t = e.valueOf) && !rn(s = en(t, e)) || r2 !== "string" && tn(t = e.toString) && !rn(s = en(t, e))) return s;
          throw Cl("Can't convert object to primitive value");
        };
      });
      var us = xe((N0, ns) => {
        ns.exports = false;
      });
      var dr = xe((w0, is) => {
        var ss = pt(), El = Object.defineProperty;
        is.exports = function(e, r2) {
          try {
            El(ss, e, { value: r2, configurable: true, writable: true });
          } catch {
            ss[e] = r2;
          }
          return r2;
        };
      });
      var gr = xe((_0, os) => {
        var Fl = pt(), Al = dr(), as = "__core-js_shared__", Sl = Fl[as] || Al(as, {});
        os.exports = Sl;
      });
      var nn = xe((P0, cs) => {
        var xl = us(), ls = gr();
        (cs.exports = function(e, r2) {
          return ls[e] || (ls[e] = r2 !== void 0 ? r2 : {});
        })("versions", []).push({ version: "3.26.1", mode: xl ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var yr = xe((I0, ps) => {
        var bl = Gr(), Tl = Object;
        ps.exports = function(e) {
          return Tl(bl(e));
        };
      });
      var Ct = xe((k0, fs) => {
        var Bl = mt(), Nl = yr(), wl = Bl({}.hasOwnProperty);
        fs.exports = Object.hasOwn || function(r2, t) {
          return wl(Nl(r2), t);
        };
      });
      var un = xe((L0, Ds) => {
        var _l = mt(), Pl = 0, Il = Math.random(), kl = _l(1 .toString);
        Ds.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + kl(++Pl + Il, 36);
        };
      });
      var bt = xe((O0, hs) => {
        var Ll = pt(), Ol = nn(), ms = Ct(), jl = un(), ds = Yr(), ys = Qr(), It = Ol("wks"), xt = Ll.Symbol, gs = xt && xt.for, ql = ys ? xt : xt && xt.withoutSetter || jl;
        hs.exports = function(e) {
          if (!ms(It, e) || !(ds || typeof It[e] == "string")) {
            var r2 = "Symbol." + e;
            ds && ms(xt, e) ? It[e] = xt[e] : ys && gs ? It[e] = gs(r2) : It[e] = ql(r2);
          }
          return It[e];
        };
      });
      var Fs = xe((j0, Es) => {
        var Ml = At(), vs = St(), Cs = Zr(), Rl = mr(), $l = rs(), Vl = bt(), Wl = TypeError, Hl = Vl("toPrimitive");
        Es.exports = function(e, r2) {
          if (!vs(e) || Cs(e)) return e;
          var t = Rl(e, Hl), s;
          if (t) {
            if (r2 === void 0 && (r2 = "default"), s = Ml(t, e, r2), !vs(s) || Cs(s)) return s;
            throw Wl("Can't convert object to primitive value");
          }
          return r2 === void 0 && (r2 = "number"), $l(e, r2);
        };
      });
      var hr = xe((q0, As) => {
        var Gl = Fs(), Ul = Zr();
        As.exports = function(e) {
          var r2 = Gl(e, "string");
          return Ul(r2) ? r2 : r2 + "";
        };
      });
      var bs = xe((M0, xs) => {
        var Jl = pt(), Ss = St(), sn = Jl.document, zl = Ss(sn) && Ss(sn.createElement);
        xs.exports = function(e) {
          return zl ? sn.createElement(e) : {};
        };
      });
      var an = xe((R0, Ts) => {
        var Xl = yt(), Kl = Dt(), Yl = bs();
        Ts.exports = !Xl && !Kl(function() {
          return Object.defineProperty(Yl("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var on = xe((Ns) => {
        var Ql = yt(), Zl = At(), ec = vu(), tc = lr(), rc = pr(), nc = hr(), uc = Ct(), sc = an(), Bs = Object.getOwnPropertyDescriptor;
        Ns.f = Ql ? Bs : function(r2, t) {
          if (r2 = rc(r2), t = nc(t), sc) try {
            return Bs(r2, t);
          } catch {
          }
          if (uc(r2, t)) return tc(!Zl(ec.f, r2, t), r2[t]);
        };
      });
      var _s = xe((V0, ws) => {
        var ic = yt(), ac = Dt();
        ws.exports = ic && ac(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Tt = xe((W0, Ps) => {
        var oc = St(), lc = String, cc = TypeError;
        Ps.exports = function(e) {
          if (oc(e)) return e;
          throw cc(lc(e) + " is not an object");
        };
      });
      var kt = xe((ks) => {
        var pc = yt(), fc = an(), Dc = _s(), vr = Tt(), Is = hr(), mc = TypeError, ln = Object.defineProperty, dc = Object.getOwnPropertyDescriptor, cn = "enumerable", pn = "configurable", fn = "writable";
        ks.f = pc ? Dc ? function(r2, t, s) {
          if (vr(r2), t = Is(t), vr(s), typeof r2 == "function" && t === "prototype" && "value" in s && fn in s && !s[fn]) {
            var a = dc(r2, t);
            a && a[fn] && (r2[t] = s.value, s = { configurable: pn in s ? s[pn] : a[pn], enumerable: cn in s ? s[cn] : a[cn], writable: false });
          }
          return ln(r2, t, s);
        } : ln : function(r2, t, s) {
          if (vr(r2), t = Is(t), vr(s), fc) try {
            return ln(r2, t, s);
          } catch {
          }
          if ("get" in s || "set" in s) throw mc("Accessors not supported");
          return "value" in s && (r2[t] = s.value), r2;
        };
      });
      var Dn = xe((G0, Ls) => {
        var gc = yt(), yc = kt(), hc = lr();
        Ls.exports = gc ? function(e, r2, t) {
          return yc.f(e, r2, hc(1, t));
        } : function(e, r2, t) {
          return e[r2] = t, e;
        };
      });
      var qs = xe((U0, js) => {
        var mn = yt(), vc = Ct(), Os = Function.prototype, Cc = mn && Object.getOwnPropertyDescriptor, dn = vc(Os, "name"), Ec = dn && function() {
        }.name === "something", Fc = dn && (!mn || mn && Cc(Os, "name").configurable);
        js.exports = { EXISTS: dn, PROPER: Ec, CONFIGURABLE: Fc };
      });
      var yn = xe((J0, Ms) => {
        var Ac = mt(), Sc = ot(), gn = gr(), xc = Ac(Function.toString);
        Sc(gn.inspectSource) || (gn.inspectSource = function(e) {
          return xc(e);
        });
        Ms.exports = gn.inspectSource;
      });
      var Vs = xe((z0, $s) => {
        var bc = pt(), Tc = ot(), Rs = bc.WeakMap;
        $s.exports = Tc(Rs) && /native code/.test(String(Rs));
      });
      var Gs = xe((X0, Hs) => {
        var Bc = nn(), Nc = un(), Ws = Bc("keys");
        Hs.exports = function(e) {
          return Ws[e] || (Ws[e] = Nc(e));
        };
      });
      var hn = xe((K0, Us) => {
        Us.exports = {};
      });
      var Ks = xe((Y0, Xs) => {
        var wc = Vs(), zs = pt(), _c = St(), Pc = Dn(), vn = Ct(), Cn = gr(), Ic = Gs(), kc = hn(), Js = "Object already initialized", En = zs.TypeError, Lc = zs.WeakMap, Cr, Gt, Er, Oc = function(e) {
          return Er(e) ? Gt(e) : Cr(e, {});
        }, jc = function(e) {
          return function(r2) {
            var t;
            if (!_c(r2) || (t = Gt(r2)).type !== e) throw En("Incompatible receiver, " + e + " required");
            return t;
          };
        };
        wc || Cn.state ? (gt = Cn.state || (Cn.state = new Lc()), gt.get = gt.get, gt.has = gt.has, gt.set = gt.set, Cr = function(e, r2) {
          if (gt.has(e)) throw En(Js);
          return r2.facade = e, gt.set(e, r2), r2;
        }, Gt = function(e) {
          return gt.get(e) || {};
        }, Er = function(e) {
          return gt.has(e);
        }) : (Bt = Ic("state"), kc[Bt] = true, Cr = function(e, r2) {
          if (vn(e, Bt)) throw En(Js);
          return r2.facade = e, Pc(e, Bt, r2), r2;
        }, Gt = function(e) {
          return vn(e, Bt) ? e[Bt] : {};
        }, Er = function(e) {
          return vn(e, Bt);
        });
        var gt, Bt;
        Xs.exports = { set: Cr, get: Gt, has: Er, enforce: Oc, getterFor: jc };
      });
      var An = xe((Q0, Qs) => {
        var qc = Dt(), Mc = ot(), Fr = Ct(), Fn = yt(), Rc = qs().CONFIGURABLE, $c = yn(), Ys = Ks(), Vc = Ys.enforce, Wc = Ys.get, Ar = Object.defineProperty, Hc = Fn && !qc(function() {
          return Ar(function() {
          }, "length", { value: 8 }).length !== 8;
        }), Gc = String(String).split("String"), Uc = Qs.exports = function(e, r2, t) {
          String(r2).slice(0, 7) === "Symbol(" && (r2 = "[" + String(r2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t && t.getter && (r2 = "get " + r2), t && t.setter && (r2 = "set " + r2), (!Fr(e, "name") || Rc && e.name !== r2) && (Fn ? Ar(e, "name", { value: r2, configurable: true }) : e.name = r2), Hc && t && Fr(t, "arity") && e.length !== t.arity && Ar(e, "length", { value: t.arity });
          try {
            t && Fr(t, "constructor") && t.constructor ? Fn && Ar(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
          } catch {
          }
          var s = Vc(e);
          return Fr(s, "source") || (s.source = Gc.join(typeof r2 == "string" ? r2 : "")), e;
        };
        Function.prototype.toString = Uc(function() {
          return Mc(this) && Wc(this).source || $c(this);
        }, "toString");
      });
      var ei = xe((Z0, Zs) => {
        var Jc = ot(), zc = kt(), Xc = An(), Kc = dr();
        Zs.exports = function(e, r2, t, s) {
          s || (s = {});
          var a = s.enumerable, n = s.name !== void 0 ? s.name : r2;
          if (Jc(t) && Xc(t, n, s), s.global) a ? e[r2] = t : Kc(r2, t);
          else {
            try {
              s.unsafe ? e[r2] && (a = true) : delete e[r2];
            } catch {
            }
            a ? e[r2] = t : zc.f(e, r2, { value: t, enumerable: false, configurable: !s.nonConfigurable, writable: !s.nonWritable });
          }
          return e;
        };
      });
      var ri = xe((ey, ti) => {
        var Yc = Math.ceil, Qc = Math.floor;
        ti.exports = Math.trunc || function(r2) {
          var t = +r2;
          return (t > 0 ? Qc : Yc)(t);
        };
      });
      var Sr = xe((ty, ni) => {
        var Zc = ri();
        ni.exports = function(e) {
          var r2 = +e;
          return r2 !== r2 || r2 === 0 ? 0 : Zc(r2);
        };
      });
      var si = xe((ry, ui) => {
        var ep = Sr(), tp = Math.max, rp = Math.min;
        ui.exports = function(e, r2) {
          var t = ep(e);
          return t < 0 ? tp(t + r2, 0) : rp(t, r2);
        };
      });
      var ai = xe((ny, ii) => {
        var np = Sr(), up = Math.min;
        ii.exports = function(e) {
          return e > 0 ? up(np(e), 9007199254740991) : 0;
        };
      });
      var Lt = xe((uy, oi) => {
        var sp = ai();
        oi.exports = function(e) {
          return sp(e.length);
        };
      });
      var pi = xe((sy, ci) => {
        var ip = pr(), ap = si(), op = Lt(), li = function(e) {
          return function(r2, t, s) {
            var a = ip(r2), n = op(a), u = ap(s, n), i;
            if (e && t != t) {
              for (; n > u; ) if (i = a[u++], i != i) return true;
            } else for (; n > u; u++) if ((e || u in a) && a[u] === t) return e || u || 0;
            return !e && -1;
          };
        };
        ci.exports = { includes: li(true), indexOf: li(false) };
      });
      var mi = xe((iy, Di) => {
        var lp = mt(), Sn = Ct(), cp = pr(), pp = pi().indexOf, fp = hn(), fi = lp([].push);
        Di.exports = function(e, r2) {
          var t = cp(e), s = 0, a = [], n;
          for (n in t) !Sn(fp, n) && Sn(t, n) && fi(a, n);
          for (; r2.length > s; ) Sn(t, n = r2[s++]) && (~pp(a, n) || fi(a, n));
          return a;
        };
      });
      var gi = xe((ay, di) => {
        di.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var hi = xe((yi) => {
        var Dp = mi(), mp = gi(), dp = mp.concat("length", "prototype");
        yi.f = Object.getOwnPropertyNames || function(r2) {
          return Dp(r2, dp);
        };
      });
      var Ci = xe((vi) => {
        vi.f = Object.getOwnPropertySymbols;
      });
      var Fi = xe((cy, Ei) => {
        var gp = Wt(), yp = mt(), hp = hi(), vp = Ci(), Cp = Tt(), Ep = yp([].concat);
        Ei.exports = gp("Reflect", "ownKeys") || function(r2) {
          var t = hp.f(Cp(r2)), s = vp.f;
          return s ? Ep(t, s(r2)) : t;
        };
      });
      var xi = xe((py, Si) => {
        var Ai = Ct(), Fp = Fi(), Ap = on(), Sp = kt();
        Si.exports = function(e, r2, t) {
          for (var s = Fp(r2), a = Sp.f, n = Ap.f, u = 0; u < s.length; u++) {
            var i = s[u];
            !Ai(e, i) && !(t && Ai(t, i)) && a(e, i, n(r2, i));
          }
        };
      });
      var Ti = xe((fy, bi) => {
        var xp = Dt(), bp = ot(), Tp = /#|\.prototype\./, Ut = function(e, r2) {
          var t = Np[Bp(e)];
          return t == _p ? true : t == wp ? false : bp(r2) ? xp(r2) : !!r2;
        }, Bp = Ut.normalize = function(e) {
          return String(e).replace(Tp, ".").toLowerCase();
        }, Np = Ut.data = {}, wp = Ut.NATIVE = "N", _p = Ut.POLYFILL = "P";
        bi.exports = Ut;
      });
      var Jt = xe((Dy, Bi) => {
        var xn = pt(), Pp = on().f, Ip = Dn(), kp = ei(), Lp = dr(), Op = xi(), jp = Ti();
        Bi.exports = function(e, r2) {
          var t = e.target, s = e.global, a = e.stat, n, u, i, l, p, y;
          if (s ? u = xn : a ? u = xn[t] || Lp(t, {}) : u = (xn[t] || {}).prototype, u) for (i in r2) {
            if (p = r2[i], e.dontCallGetSet ? (y = Pp(u, i), l = y && y.value) : l = u[i], n = jp(s ? i : t + (a ? "." : "#") + i, e.forced), !n && l !== void 0) {
              if (typeof p == typeof l) continue;
              Op(p, l);
            }
            (e.sham || l && l.sham) && Ip(p, "sham", true), kp(u, i, p, e);
          }
        };
      });
      var bn = xe((my, Ni) => {
        var qp = Vt();
        Ni.exports = Array.isArray || function(r2) {
          return qp(r2) == "Array";
        };
      });
      var _i = xe((dy, wi) => {
        var Mp = TypeError, Rp = 9007199254740991;
        wi.exports = function(e) {
          if (e > Rp) throw Mp("Maximum allowed index exceeded");
          return e;
        };
      });
      var Ii = xe((gy, Pi) => {
        var $p = Vt(), Vp = mt();
        Pi.exports = function(e) {
          if ($p(e) === "Function") return Vp(e);
        };
      });
      var Tn = xe((yy, Li) => {
        var ki = Ii(), Wp = Ht(), Hp = ar(), Gp = ki(ki.bind);
        Li.exports = function(e, r2) {
          return Wp(e), r2 === void 0 ? e : Hp ? Gp(e, r2) : function() {
            return e.apply(r2, arguments);
          };
        };
      });
      var Bn = xe((hy, ji) => {
        var Up = bn(), Jp = Lt(), zp = _i(), Xp = Tn(), Oi = function(e, r2, t, s, a, n, u, i) {
          for (var l = a, p = 0, y = u ? Xp(u, i) : false, h, g; p < s; ) p in t && (h = y ? y(t[p], p, r2) : t[p], n > 0 && Up(h) ? (g = Jp(h), l = Oi(e, r2, h, g, l, n - 1) - 1) : (zp(l + 1), e[l] = h), l++), p++;
          return l;
        };
        ji.exports = Oi;
      });
      var Ri = xe((vy, Mi) => {
        var Kp = bt(), Yp = Kp("toStringTag"), qi = {};
        qi[Yp] = "z";
        Mi.exports = String(qi) === "[object z]";
      });
      var Nn = xe((Cy, $i) => {
        var Qp = Ri(), Zp = ot(), xr = Vt(), ef = bt(), tf = ef("toStringTag"), rf = Object, nf = xr(/* @__PURE__ */ (function() {
          return arguments;
        })()) == "Arguments", uf = function(e, r2) {
          try {
            return e[r2];
          } catch {
          }
        };
        $i.exports = Qp ? xr : function(e) {
          var r2, t, s;
          return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = uf(r2 = rf(e), tf)) == "string" ? t : nf ? xr(r2) : (s = xr(r2)) == "Object" && Zp(r2.callee) ? "Arguments" : s;
        };
      });
      var Ji = xe((Ey, Ui) => {
        var sf = mt(), af = Dt(), Vi = ot(), of = Nn(), lf = Wt(), cf = yn(), Wi = function() {
        }, pf = [], Hi = lf("Reflect", "construct"), wn = /^\s*(?:class|function)\b/, ff = sf(wn.exec), Df = !wn.exec(Wi), zt = function(r2) {
          if (!Vi(r2)) return false;
          try {
            return Hi(Wi, pf, r2), true;
          } catch {
            return false;
          }
        }, Gi = function(r2) {
          if (!Vi(r2)) return false;
          switch (of(r2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Df || !!ff(wn, cf(r2));
          } catch {
            return true;
          }
        };
        Gi.sham = true;
        Ui.exports = !Hi || af(function() {
          var e;
          return zt(zt.call) || !zt(Object) || !zt(function() {
            e = true;
          }) || e;
        }) ? Gi : zt;
      });
      var Yi = xe((Fy, Ki) => {
        var zi = bn(), mf = Ji(), df = St(), gf = bt(), yf = gf("species"), Xi = Array;
        Ki.exports = function(e) {
          var r2;
          return zi(e) && (r2 = e.constructor, mf(r2) && (r2 === Xi || zi(r2.prototype)) ? r2 = void 0 : df(r2) && (r2 = r2[yf], r2 === null && (r2 = void 0))), r2 === void 0 ? Xi : r2;
        };
      });
      var _n = xe((Ay, Qi) => {
        var hf = Yi();
        Qi.exports = function(e, r2) {
          return new (hf(e))(r2 === 0 ? 0 : r2);
        };
      });
      var Zi = xe(() => {
        var vf = Jt(), Cf = Bn(), Ef = Ht(), Ff = yr(), Af = Lt(), Sf = _n();
        vf({ target: "Array", proto: true }, { flatMap: function(r2) {
          var t = Ff(this), s = Af(t), a;
          return Ef(r2), a = Sf(t, 0), a.length = Cf(a, t, t, s, 0, 1, r2, arguments.length > 1 ? arguments[1] : void 0), a;
        } });
      });
      var Pn = xe((by, ea) => {
        ea.exports = {};
      });
      var ra = xe((Ty, ta) => {
        var xf = bt(), bf = Pn(), Tf = xf("iterator"), Bf = Array.prototype;
        ta.exports = function(e) {
          return e !== void 0 && (bf.Array === e || Bf[Tf] === e);
        };
      });
      var In = xe((By, ua) => {
        var Nf = Nn(), na = mr(), wf = cr(), _f = Pn(), Pf = bt(), If = Pf("iterator");
        ua.exports = function(e) {
          if (!wf(e)) return na(e, If) || na(e, "@@iterator") || _f[Nf(e)];
        };
      });
      var ia = xe((Ny, sa) => {
        var kf = At(), Lf = Ht(), Of = Tt(), jf = Dr(), qf = In(), Mf = TypeError;
        sa.exports = function(e, r2) {
          var t = arguments.length < 2 ? qf(e) : r2;
          if (Lf(t)) return Of(kf(t, e));
          throw Mf(jf(e) + " is not iterable");
        };
      });
      var la = xe((wy, oa) => {
        var Rf = At(), aa = Tt(), $f = mr();
        oa.exports = function(e, r2, t) {
          var s, a;
          aa(e);
          try {
            if (s = $f(e, "return"), !s) {
              if (r2 === "throw") throw t;
              return t;
            }
            s = Rf(s, e);
          } catch (n) {
            a = true, s = n;
          }
          if (r2 === "throw") throw t;
          if (a) throw s;
          return aa(s), t;
        };
      });
      var ma = xe((_y, Da) => {
        var Vf = Tn(), Wf = At(), Hf = Tt(), Gf = Dr(), Uf = ra(), Jf = Lt(), ca = Xr(), zf = ia(), Xf = In(), pa = la(), Kf = TypeError, br = function(e, r2) {
          this.stopped = e, this.result = r2;
        }, fa = br.prototype;
        Da.exports = function(e, r2, t) {
          var s = t && t.that, a = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_RECORD), u = !!(t && t.IS_ITERATOR), i = !!(t && t.INTERRUPTED), l = Vf(r2, s), p, y, h, g, c2, f, F, _ = function(E) {
            return p && pa(p, "normal", E), new br(true, E);
          }, w = function(E) {
            return a ? (Hf(E), i ? l(E[0], E[1], _) : l(E[0], E[1])) : i ? l(E, _) : l(E);
          };
          if (n) p = e.iterator;
          else if (u) p = e;
          else {
            if (y = Xf(e), !y) throw Kf(Gf(e) + " is not iterable");
            if (Uf(y)) {
              for (h = 0, g = Jf(e); g > h; h++) if (c2 = w(e[h]), c2 && ca(fa, c2)) return c2;
              return new br(false);
            }
            p = zf(e, y);
          }
          for (f = n ? e.next : p.next; !(F = Wf(f, p)).done; ) {
            try {
              c2 = w(F.value);
            } catch (E) {
              pa(p, "throw", E);
            }
            if (typeof c2 == "object" && c2 && ca(fa, c2)) return c2;
          }
          return new br(false);
        };
      });
      var ga = xe((Py, da) => {
        var Yf = hr(), Qf = kt(), Zf = lr();
        da.exports = function(e, r2, t) {
          var s = Yf(r2);
          s in e ? Qf.f(e, s, Zf(0, t)) : e[s] = t;
        };
      });
      var ya = xe(() => {
        var eD = Jt(), tD = ma(), rD = ga();
        eD({ target: "Object", stat: true }, { fromEntries: function(r2) {
          var t = {};
          return tD(r2, function(s, a) {
            rD(t, s, a);
          }, { AS_ENTRIES: true }), t;
        } });
      });
      var Ca = xe((Ly, va) => {
        var ha = An(), nD = kt();
        va.exports = function(e, r2, t) {
          return t.get && ha(t.get, r2, { getter: true }), t.set && ha(t.set, r2, { setter: true }), nD.f(e, r2, t);
        };
      });
      var Fa = xe((Oy, Ea) => {
        var uD = Tt();
        Ea.exports = function() {
          var e = uD(this), r2 = "";
          return e.hasIndices && (r2 += "d"), e.global && (r2 += "g"), e.ignoreCase && (r2 += "i"), e.multiline && (r2 += "m"), e.dotAll && (r2 += "s"), e.unicode && (r2 += "u"), e.unicodeSets && (r2 += "v"), e.sticky && (r2 += "y"), r2;
        };
      });
      var xa = xe(() => {
        var sD = pt(), iD = yt(), aD = Ca(), oD = Fa(), lD = Dt(), Aa = sD.RegExp, Sa = Aa.prototype, cD = iD && lD(function() {
          var e = true;
          try {
            Aa(".", "d");
          } catch {
            e = false;
          }
          var r2 = {}, t = "", s = e ? "dgimsy" : "gimsy", a = function(l, p) {
            Object.defineProperty(r2, l, { get: function() {
              return t += p, true;
            } });
          }, n = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
          e && (n.hasIndices = "d");
          for (var u in n) a(u, n[u]);
          var i = Object.getOwnPropertyDescriptor(Sa, "flags").get.call(r2);
          return i !== s || t !== s;
        });
        cD && aD(Sa, "flags", { configurable: true, get: oD });
      });
      var ba = xe(() => {
        var pD = Jt(), kn = pt();
        pD({ global: true, forced: kn.globalThis !== kn }, { globalThis: kn });
      });
      var Ta = xe(() => {
        ba();
      });
      var Ba = xe(() => {
        var fD = Jt(), DD = Bn(), mD = yr(), dD = Lt(), gD = Sr(), yD = _n();
        fD({ target: "Array", proto: true }, { flat: function() {
          var r2 = arguments.length ? arguments[0] : void 0, t = mD(this), s = dD(t), a = yD(t, 0);
          return a.length = DD(a, t, t, s, 0, r2 === void 0 ? 1 : gD(r2)), a;
        } });
      });
      var e0 = xe((Uy, jo) => {
        var hD = ["cliName", "cliCategory", "cliDescription"], vD = ["_"], CD = ["languageId"];
        function Hn(e, r2) {
          if (e == null) return {};
          var t = ED(e, r2), s, a;
          if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            for (a = 0; a < n.length; a++) s = n[a], !(r2.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s) && (t[s] = e[s]);
          }
          return t;
        }
        function ED(e, r2) {
          if (e == null) return {};
          var t = {}, s = Object.keys(e), a, n;
          for (n = 0; n < s.length; n++) a = s[n], !(r2.indexOf(a) >= 0) && (t[a] = e[a]);
          return t;
        }
        Zi();
        ya();
        xa();
        Ta();
        Ba();
        var FD = Object.create, _r = Object.defineProperty, AD = Object.getOwnPropertyDescriptor, Gn = Object.getOwnPropertyNames, SD = Object.getPrototypeOf, xD = Object.prototype.hasOwnProperty, ht = (e, r2) => function() {
          return e && (r2 = (0, e[Gn(e)[0]])(e = 0)), r2;
        }, te = (e, r2) => function() {
          return r2 || (0, e[Gn(e)[0]])((r2 = { exports: {} }).exports, r2), r2.exports;
        }, Kt = (e, r2) => {
          for (var t in r2) _r(e, t, { get: r2[t], enumerable: true });
        }, Pa = (e, r2, t, s) => {
          if (r2 && typeof r2 == "object" || typeof r2 == "function") for (let a of Gn(r2)) !xD.call(e, a) && a !== t && _r(e, a, { get: () => r2[a], enumerable: !(s = AD(r2, a)) || s.enumerable });
          return e;
        }, bD = (e, r2, t) => (t = e != null ? FD(SD(e)) : {}, Pa(!e || !e.__esModule ? _r(t, "default", { value: e, enumerable: true }) : t, e)), ft = (e) => Pa(_r({}, "__esModule", { value: true }), e), wt, ne = ht({ "<define:process>"() {
          wt = { env: {}, argv: [] };
        } }), Ia = te({ "package.json"(e, r2) {
          r2.exports = { version: "2.8.8" };
        } }), TD = te({ "node_modules/diff/lib/diff/base.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true }), e.default = r2;
          function r2() {
          }
          r2.prototype = { diff: function(n, u) {
            var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
            typeof i == "function" && (l = i, i = {}), this.options = i;
            var p = this;
            function y(N) {
              return l ? (setTimeout(function() {
                l(void 0, N);
              }, 0), true) : N;
            }
            n = this.castInput(n), u = this.castInput(u), n = this.removeEmpty(this.tokenize(n)), u = this.removeEmpty(this.tokenize(u));
            var h = u.length, g = n.length, c2 = 1, f = h + g, F = [{ newPos: -1, components: [] }], _ = this.extractCommon(F[0], u, n, 0);
            if (F[0].newPos + 1 >= h && _ + 1 >= g) return y([{ value: this.join(u), count: u.length }]);
            function w() {
              for (var N = -1 * c2; N <= c2; N += 2) {
                var x = void 0, I = F[N - 1], P = F[N + 1], $ = (P ? P.newPos : 0) - N;
                I && (F[N - 1] = void 0);
                var D = I && I.newPos + 1 < h, T = P && 0 <= $ && $ < g;
                if (!D && !T) {
                  F[N] = void 0;
                  continue;
                }
                if (!D || T && I.newPos < P.newPos ? (x = s(P), p.pushComponent(x.components, void 0, true)) : (x = I, x.newPos++, p.pushComponent(x.components, true, void 0)), $ = p.extractCommon(x, u, n, N), x.newPos + 1 >= h && $ + 1 >= g) return y(t(p, x.components, u, n, p.useLongestToken));
                F[N] = x;
              }
              c2++;
            }
            if (l) (function N() {
              setTimeout(function() {
                if (c2 > f) return l();
                w() || N();
              }, 0);
            })();
            else for (; c2 <= f; ) {
              var E = w();
              if (E) return E;
            }
          }, pushComponent: function(n, u, i) {
            var l = n[n.length - 1];
            l && l.added === u && l.removed === i ? n[n.length - 1] = { count: l.count + 1, added: u, removed: i } : n.push({ count: 1, added: u, removed: i });
          }, extractCommon: function(n, u, i, l) {
            for (var p = u.length, y = i.length, h = n.newPos, g = h - l, c2 = 0; h + 1 < p && g + 1 < y && this.equals(u[h + 1], i[g + 1]); ) h++, g++, c2++;
            return c2 && n.components.push({ count: c2 }), n.newPos = h, g;
          }, equals: function(n, u) {
            return this.options.comparator ? this.options.comparator(n, u) : n === u || this.options.ignoreCase && n.toLowerCase() === u.toLowerCase();
          }, removeEmpty: function(n) {
            for (var u = [], i = 0; i < n.length; i++) n[i] && u.push(n[i]);
            return u;
          }, castInput: function(n) {
            return n;
          }, tokenize: function(n) {
            return n.split("");
          }, join: function(n) {
            return n.join("");
          } };
          function t(a, n, u, i, l) {
            for (var p = 0, y = n.length, h = 0, g = 0; p < y; p++) {
              var c2 = n[p];
              if (c2.removed) {
                if (c2.value = a.join(i.slice(g, g + c2.count)), g += c2.count, p && n[p - 1].added) {
                  var F = n[p - 1];
                  n[p - 1] = n[p], n[p] = F;
                }
              } else {
                if (!c2.added && l) {
                  var f = u.slice(h, h + c2.count);
                  f = f.map(function(w, E) {
                    var N = i[g + E];
                    return N.length > w.length ? N : w;
                  }), c2.value = a.join(f);
                } else c2.value = a.join(u.slice(h, h + c2.count));
                h += c2.count, c2.added || (g += c2.count);
              }
            }
            var _ = n[y - 1];
            return y > 1 && typeof _.value == "string" && (_.added || _.removed) && a.equals("", _.value) && (n[y - 2].value += _.value, n.pop()), n;
          }
          function s(a) {
            return { newPos: a.newPos, components: a.components.slice(0) };
          }
        } }), BD = te({ "node_modules/diff/lib/diff/array.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
          var r2 = t(TD());
          function t(n) {
            return n && n.__esModule ? n : { default: n };
          }
          var s = new r2.default();
          e.arrayDiff = s, s.tokenize = function(n) {
            return n.slice();
          }, s.join = s.removeEmpty = function(n) {
            return n;
          };
          function a(n, u, i) {
            return s.diff(n, u, i);
          }
        } }), Un = te({ "src/document/doc-builders.js"(e, r2) {
          ne();
          function t(C) {
            return { type: "concat", parts: C };
          }
          function s(C) {
            return { type: "indent", contents: C };
          }
          function a(C, o) {
            return { type: "align", contents: o, n: C };
          }
          function n(C) {
            let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return { type: "group", id: o.id, contents: C, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
          }
          function u(C) {
            return a(Number.NEGATIVE_INFINITY, C);
          }
          function i(C) {
            return a({ type: "root" }, C);
          }
          function l(C) {
            return a(-1, C);
          }
          function p(C, o) {
            return n(C[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C }));
          }
          function y(C) {
            return { type: "fill", parts: C };
          }
          function h(C, o) {
            let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return { type: "if-break", breakContents: C, flatContents: o, groupId: d.groupId };
          }
          function g(C, o) {
            return { type: "indent-if-break", contents: C, groupId: o.groupId, negate: o.negate };
          }
          function c2(C) {
            return { type: "line-suffix", contents: C };
          }
          var f = { type: "line-suffix-boundary" }, F = { type: "break-parent" }, _ = { type: "trim" }, w = { type: "line", hard: true }, E = { type: "line", hard: true, literal: true }, N = { type: "line" }, x = { type: "line", soft: true }, I = t([w, F]), P = t([E, F]), $ = { type: "cursor", placeholder: Symbol("cursor") };
          function D(C, o) {
            let d = [];
            for (let v = 0; v < o.length; v++) v !== 0 && d.push(C), d.push(o[v]);
            return t(d);
          }
          function T(C, o, d) {
            let v = C;
            if (o > 0) {
              for (let S = 0; S < Math.floor(o / d); ++S) v = s(v);
              v = a(o % d, v), v = a(Number.NEGATIVE_INFINITY, v);
            }
            return v;
          }
          function m(C, o) {
            return { type: "label", label: C, contents: o };
          }
          r2.exports = { concat: t, join: D, line: N, softline: x, hardline: I, literalline: P, group: n, conditionalGroup: p, fill: y, lineSuffix: c2, lineSuffixBoundary: f, cursor: $, breakParent: F, ifBreak: h, trim: _, indent: s, indentIfBreak: g, align: a, addAlignmentToDoc: T, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w, literallineWithoutBreakParent: E, label: m };
        } }), Jn = te({ "src/common/end-of-line.js"(e, r2) {
          ne();
          function t(u) {
            let i = u.indexOf("\r");
            return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function s(u) {
            switch (u) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function a(u, i) {
            let l;
            switch (i) {
              case `
`:
                l = /\n/g;
                break;
              case "\r":
                l = /\r/g;
                break;
              case `\r
`:
                l = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
            }
            let p = u.match(l);
            return p ? p.length : 0;
          }
          function n(u) {
            return u.replace(/\r\n?/g, `
`);
          }
          r2.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: n };
        } }), lt = te({ "src/utils/get-last.js"(e, r2) {
          ne();
          var t = (s) => s[s.length - 1];
          r2.exports = t;
        } });
        function ND() {
          let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(r2, e ? void 0 : "g");
        }
        var wD = ht({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          ne();
        } });
        function _D(e) {
          if (typeof e != "string") throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
          return e.replace(ND(), "");
        }
        var PD = ht({ "node_modules/strip-ansi/index.js"() {
          ne(), wD();
        } });
        function ID(e) {
          return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
        }
        var kD = ht({ "node_modules/is-fullwidth-code-point/index.js"() {
          ne();
        } }), LD = te({ "node_modules/emoji-regex/index.js"(e, r2) {
          ne(), r2.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), ka = {};
        Kt(ka, { default: () => OD });
        function OD(e) {
          if (typeof e != "string" || e.length === 0 || (e = _D(e), e.length === 0)) return 0;
          e = e.replace((0, La.default)(), "  ");
          let r2 = 0;
          for (let t = 0; t < e.length; t++) {
            let s = e.codePointAt(t);
            s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, r2 += ID(s) ? 2 : 1);
          }
          return r2;
        }
        var La, jD = ht({ "node_modules/string-width/index.js"() {
          ne(), PD(), kD(), La = bD(LD());
        } }), Oa = te({ "src/utils/get-string-width.js"(e, r2) {
          ne();
          var t = (jD(), ft(ka)).default, s = /[^\x20-\x7F]/;
          function a(n) {
            return n ? s.test(n) ? t(n) : n.length : 0;
          }
          r2.exports = a;
        } }), Yt = te({ "src/document/doc-utils.js"(e, r2) {
          ne();
          var t = lt(), { literalline: s, join: a } = Un(), n = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
            if (Array.isArray(o)) return o;
            if (o.type !== "concat" && o.type !== "fill") throw new Error("Expect doc type to be `concat` or `fill`.");
            return o.parts;
          }, i = {};
          function l(o, d, v, S) {
            let b = [o];
            for (; b.length > 0; ) {
              let B = b.pop();
              if (B === i) {
                v(b.pop());
                continue;
              }
              if (v && b.push(B, i), !d || d(B) !== false) if (n(B) || B.type === "fill") {
                let k = u(B);
                for (let M = k.length, R = M - 1; R >= 0; --R) b.push(k[R]);
              } else if (B.type === "if-break") B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
              else if (B.type === "group" && B.expandedStates) if (S) for (let k = B.expandedStates.length, M = k - 1; M >= 0; --M) b.push(B.expandedStates[M]);
              else b.push(B.contents);
              else B.contents && b.push(B.contents);
            }
          }
          function p(o, d) {
            let v = /* @__PURE__ */ new Map();
            return S(o);
            function S(B) {
              if (v.has(B)) return v.get(B);
              let k = b(B);
              return v.set(B, k), k;
            }
            function b(B) {
              if (Array.isArray(B)) return d(B.map(S));
              if (B.type === "concat" || B.type === "fill") {
                let k = B.parts.map(S);
                return d(Object.assign(Object.assign({}, B), {}, { parts: k }));
              }
              if (B.type === "if-break") {
                let k = B.breakContents && S(B.breakContents), M = B.flatContents && S(B.flatContents);
                return d(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M }));
              }
              if (B.type === "group" && B.expandedStates) {
                let k = B.expandedStates.map(S), M = k[0];
                return d(Object.assign(Object.assign({}, B), {}, { contents: M, expandedStates: k }));
              }
              if (B.contents) {
                let k = S(B.contents);
                return d(Object.assign(Object.assign({}, B), {}, { contents: k }));
              }
              return d(B);
            }
          }
          function y(o, d, v) {
            let S = v, b = false;
            function B(k) {
              let M = d(k);
              if (M !== void 0 && (b = true, S = M), b) return false;
            }
            return l(o, B), S;
          }
          function h(o) {
            if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent") return true;
          }
          function g(o) {
            return y(o, h, false);
          }
          function c2(o) {
            if (o.length > 0) {
              let d = t(o);
              !d.expandedStates && !d.break && (d.break = "propagated");
            }
            return null;
          }
          function f(o) {
            let d = /* @__PURE__ */ new Set(), v = [];
            function S(B) {
              if (B.type === "break-parent" && c2(v), B.type === "group") {
                if (v.push(B), d.has(B)) return false;
                d.add(B);
              }
            }
            function b(B) {
              B.type === "group" && v.pop().break && c2(v);
            }
            l(o, S, b, true);
          }
          function F(o) {
            return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
          }
          function _(o) {
            return p(o, F);
          }
          var w = (o, d) => o && o.type === "line" && o.hard && d && d.type === "break-parent";
          function E(o) {
            if (!o) return o;
            if (n(o) || o.type === "fill") {
              let d = u(o);
              for (; d.length > 1 && w(...d.slice(-2)); ) d.length -= 2;
              if (d.length > 0) {
                let v = E(t(d));
                d[d.length - 1] = v;
              }
              return Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
            }
            switch (o.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label": {
                let d = E(o.contents);
                return Object.assign(Object.assign({}, o), {}, { contents: d });
              }
              case "if-break": {
                let d = E(o.breakContents), v = E(o.flatContents);
                return Object.assign(Object.assign({}, o), {}, { breakContents: d, flatContents: v });
              }
            }
            return o;
          }
          function N(o) {
            return E(I(o));
          }
          function x(o) {
            switch (o.type) {
              case "fill":
                if (o.parts.every((v) => v === "")) return "";
                break;
              case "group":
                if (!o.contents && !o.id && !o.break && !o.expandedStates) return "";
                if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates) return o.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!o.contents) return "";
                break;
              case "if-break":
                if (!o.flatContents && !o.breakContents) return "";
                break;
            }
            if (!n(o)) return o;
            let d = [];
            for (let v of u(o)) {
              if (!v) continue;
              let [S, ...b] = n(v) ? u(v) : [v];
              typeof S == "string" && typeof t(d) == "string" ? d[d.length - 1] += S : d.push(S), d.push(...b);
            }
            return d.length === 0 ? "" : d.length === 1 ? d[0] : Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
          }
          function I(o) {
            return p(o, (d) => x(d));
          }
          function P(o) {
            let d = [], v = o.filter(Boolean);
            for (; v.length > 0; ) {
              let S = v.shift();
              if (S) {
                if (n(S)) {
                  v.unshift(...u(S));
                  continue;
                }
                if (d.length > 0 && typeof t(d) == "string" && typeof S == "string") {
                  d[d.length - 1] += S;
                  continue;
                }
                d.push(S);
              }
            }
            return d;
          }
          function $(o) {
            return p(o, (d) => Array.isArray(d) ? P(d) : d.parts ? Object.assign(Object.assign({}, d), {}, { parts: P(d.parts) }) : d);
          }
          function D(o) {
            return p(o, (d) => typeof d == "string" && d.includes(`
`) ? T(d) : d);
          }
          function T(o) {
            let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
            return a(d, o.split(`
`)).parts;
          }
          function m(o) {
            if (o.type === "line") return true;
          }
          function C(o) {
            return y(o, m, false);
          }
          r2.exports = { isConcat: n, getDocParts: u, willBreak: g, traverseDoc: l, findInDoc: y, mapDoc: p, propagateBreaks: f, removeLines: _, stripTrailingHardline: N, normalizeParts: P, normalizeDoc: $, cleanDoc: I, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C };
        } }), qD = te({ "src/document/doc-printer.js"(e, r2) {
          ne();
          var { convertEndOfLineToChars: t } = Jn(), s = lt(), a = Oa(), { fill: n, cursor: u, indent: i } = Un(), { isConcat: l, getDocParts: p } = Yt(), y, h = 1, g = 2;
          function c2() {
            return { value: "", length: 0, queue: [] };
          }
          function f(x, I) {
            return _(x, { type: "indent" }, I);
          }
          function F(x, I, P) {
            return I === Number.NEGATIVE_INFINITY ? x.root || c2() : I < 0 ? _(x, { type: "dedent" }, P) : I ? I.type === "root" ? Object.assign(Object.assign({}, x), {}, { root: x }) : _(x, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P) : x;
          }
          function _(x, I, P) {
            let $ = I.type === "dedent" ? x.queue.slice(0, -1) : [...x.queue, I], D = "", T = 0, m = 0, C = 0;
            for (let k of $) switch (k.type) {
              case "indent":
                v(), P.useTabs ? o(1) : d(P.tabWidth);
                break;
              case "stringAlign":
                v(), D += k.n, T += k.n.length;
                break;
              case "numberAlign":
                m += 1, C += k.n;
                break;
              default:
                throw new Error(`Unexpected type '${k.type}'`);
            }
            return b(), Object.assign(Object.assign({}, x), {}, { value: D, length: T, queue: $ });
            function o(k) {
              D += "	".repeat(k), T += P.tabWidth * k;
            }
            function d(k) {
              D += " ".repeat(k), T += k;
            }
            function v() {
              P.useTabs ? S() : b();
            }
            function S() {
              m > 0 && o(m), B();
            }
            function b() {
              C > 0 && d(C), B();
            }
            function B() {
              m = 0, C = 0;
            }
          }
          function w(x) {
            if (x.length === 0) return 0;
            let I = 0;
            for (; x.length > 0 && typeof s(x) == "string" && /^[\t ]*$/.test(s(x)); ) I += x.pop().length;
            if (x.length > 0 && typeof s(x) == "string") {
              let P = s(x).replace(/[\t ]*$/, "");
              I += s(x).length - P.length, x[x.length - 1] = P;
            }
            return I;
          }
          function E(x, I, P, $, D) {
            let T = I.length, m = [x], C = [];
            for (; P >= 0; ) {
              if (m.length === 0) {
                if (T === 0) return true;
                m.push(I[--T]);
                continue;
              }
              let { mode: o, doc: d } = m.pop();
              if (typeof d == "string") C.push(d), P -= a(d);
              else if (l(d) || d.type === "fill") {
                let v = p(d);
                for (let S = v.length - 1; S >= 0; S--) m.push({ mode: o, doc: v[S] });
              } else switch (d.type) {
                case "indent":
                case "align":
                case "indent-if-break":
                case "label":
                  m.push({ mode: o, doc: d.contents });
                  break;
                case "trim":
                  P += w(C);
                  break;
                case "group": {
                  if (D && d.break) return false;
                  let v = d.break ? h : o, S = d.expandedStates && v === h ? s(d.expandedStates) : d.contents;
                  m.push({ mode: v, doc: S });
                  break;
                }
                case "if-break": {
                  let S = (d.groupId ? y[d.groupId] || g : o) === h ? d.breakContents : d.flatContents;
                  S && m.push({ mode: o, doc: S });
                  break;
                }
                case "line":
                  if (o === h || d.hard) return true;
                  d.soft || (C.push(" "), P--);
                  break;
                case "line-suffix":
                  $ = true;
                  break;
                case "line-suffix-boundary":
                  if ($) return false;
                  break;
              }
            }
            return false;
          }
          function N(x, I) {
            y = {};
            let P = I.printWidth, $ = t(I.endOfLine), D = 0, T = [{ ind: c2(), mode: h, doc: x }], m = [], C = false, o = [];
            for (; T.length > 0; ) {
              let { ind: v, mode: S, doc: b } = T.pop();
              if (typeof b == "string") {
                let B = $ !== `
` ? b.replace(/\n/g, $) : b;
                m.push(B), D += a(B);
              } else if (l(b)) {
                let B = p(b);
                for (let k = B.length - 1; k >= 0; k--) T.push({ ind: v, mode: S, doc: B[k] });
              } else switch (b.type) {
                case "cursor":
                  m.push(u.placeholder);
                  break;
                case "indent":
                  T.push({ ind: f(v, I), mode: S, doc: b.contents });
                  break;
                case "align":
                  T.push({ ind: F(v, b.n, I), mode: S, doc: b.contents });
                  break;
                case "trim":
                  D -= w(m);
                  break;
                case "group":
                  switch (S) {
                    case g:
                      if (!C) {
                        T.push({ ind: v, mode: b.break ? h : g, doc: b.contents });
                        break;
                      }
                    case h: {
                      C = false;
                      let B = { ind: v, mode: g, doc: b.contents }, k = P - D, M = o.length > 0;
                      if (!b.break && E(B, T, k, M)) T.push(B);
                      else if (b.expandedStates) {
                        let R = s(b.expandedStates);
                        if (b.break) {
                          T.push({ ind: v, mode: h, doc: R });
                          break;
                        } else for (let q = 1; q < b.expandedStates.length + 1; q++) if (q >= b.expandedStates.length) {
                          T.push({ ind: v, mode: h, doc: R });
                          break;
                        } else {
                          let J = b.expandedStates[q], L = { ind: v, mode: g, doc: J };
                          if (E(L, T, k, M)) {
                            T.push(L);
                            break;
                          }
                        }
                      } else T.push({ ind: v, mode: h, doc: b.contents });
                      break;
                    }
                  }
                  b.id && (y[b.id] = s(T).mode);
                  break;
                case "fill": {
                  let B = P - D, { parts: k } = b;
                  if (k.length === 0) break;
                  let [M, R] = k, q = { ind: v, mode: g, doc: M }, J = { ind: v, mode: h, doc: M }, L = E(q, [], B, o.length > 0, true);
                  if (k.length === 1) {
                    L ? T.push(q) : T.push(J);
                    break;
                  }
                  let Q = { ind: v, mode: g, doc: R }, V = { ind: v, mode: h, doc: R };
                  if (k.length === 2) {
                    L ? T.push(Q, q) : T.push(V, J);
                    break;
                  }
                  k.splice(0, 2);
                  let j = { ind: v, mode: S, doc: n(k) }, Y = k[0];
                  E({ ind: v, mode: g, doc: [M, R, Y] }, [], B, o.length > 0, true) ? T.push(j, Q, q) : L ? T.push(j, V, q) : T.push(j, V, J);
                  break;
                }
                case "if-break":
                case "indent-if-break": {
                  let B = b.groupId ? y[b.groupId] : S;
                  if (B === h) {
                    let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
                    k && T.push({ ind: v, mode: S, doc: k });
                  }
                  if (B === g) {
                    let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
                    k && T.push({ ind: v, mode: S, doc: k });
                  }
                  break;
                }
                case "line-suffix":
                  o.push({ ind: v, mode: S, doc: b.contents });
                  break;
                case "line-suffix-boundary":
                  o.length > 0 && T.push({ ind: v, mode: S, doc: { type: "line", hard: true } });
                  break;
                case "line":
                  switch (S) {
                    case g:
                      if (b.hard) C = true;
                      else {
                        b.soft || (m.push(" "), D += 1);
                        break;
                      }
                    case h:
                      if (o.length > 0) {
                        T.push({ ind: v, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                        break;
                      }
                      b.literal ? v.root ? (m.push($, v.root.value), D = v.root.length) : (m.push($), D = 0) : (D -= w(m), m.push($ + v.value), D = v.length);
                      break;
                  }
                  break;
                case "label":
                  T.push({ ind: v, mode: S, doc: b.contents });
                  break;
              }
              T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
            }
            let d = m.indexOf(u.placeholder);
            if (d !== -1) {
              let v = m.indexOf(u.placeholder, d + 1), S = m.slice(0, d).join(""), b = m.slice(d + 1, v).join(""), B = m.slice(v + 1).join("");
              return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
            }
            return { formatted: m.join("") };
          }
          r2.exports = { printDocToString: N };
        } }), MD = te({ "src/document/doc-debug.js"(e, r2) {
          ne();
          var { isConcat: t, getDocParts: s } = Yt();
          function a(u) {
            if (!u) return "";
            if (t(u)) {
              let i = [];
              for (let l of s(u)) if (t(l)) i.push(...a(l).parts);
              else {
                let p = a(l);
                p !== "" && i.push(p);
              }
              return { type: "concat", parts: i };
            }
            return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
          }
          function n(u) {
            let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
            return p(a(u));
            function p(h, g, c2) {
              if (typeof h == "string") return JSON.stringify(h);
              if (t(h)) {
                let f = s(h).map(p).filter(Boolean);
                return f.length === 1 ? f[0] : `[${f.join(", ")}]`;
              }
              if (h.type === "line") {
                let f = Array.isArray(c2) && c2[g + 1] && c2[g + 1].type === "break-parent";
                return h.literal ? f ? "literalline" : "literallineWithoutBreakParent" : h.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : h.soft ? "softline" : "line";
              }
              if (h.type === "break-parent") return Array.isArray(c2) && c2[g - 1] && c2[g - 1].type === "line" && c2[g - 1].hard ? void 0 : "breakParent";
              if (h.type === "trim") return "trim";
              if (h.type === "indent") return "indent(" + p(h.contents) + ")";
              if (h.type === "align") return h.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p(h.contents) + ")" : h.n < 0 ? "dedent(" + p(h.contents) + ")" : h.n.type === "root" ? "markAsRoot(" + p(h.contents) + ")" : "align(" + JSON.stringify(h.n) + ", " + p(h.contents) + ")";
              if (h.type === "if-break") return "ifBreak(" + p(h.breakContents) + (h.flatContents ? ", " + p(h.flatContents) : "") + (h.groupId ? (h.flatContents ? "" : ', ""') + `, { groupId: ${y(h.groupId)} }` : "") + ")";
              if (h.type === "indent-if-break") {
                let f = [];
                h.negate && f.push("negate: true"), h.groupId && f.push(`groupId: ${y(h.groupId)}`);
                let F = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                return `indentIfBreak(${p(h.contents)}${F})`;
              }
              if (h.type === "group") {
                let f = [];
                h.break && h.break !== "propagated" && f.push("shouldBreak: true"), h.id && f.push(`id: ${y(h.id)}`);
                let F = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                return h.expandedStates ? `conditionalGroup([${h.expandedStates.map((_) => p(_)).join(",")}]${F})` : `group(${p(h.contents)}${F})`;
              }
              if (h.type === "fill") return `fill([${h.parts.map((f) => p(f)).join(", ")}])`;
              if (h.type === "line-suffix") return "lineSuffix(" + p(h.contents) + ")";
              if (h.type === "line-suffix-boundary") return "lineSuffixBoundary";
              if (h.type === "label") return `label(${JSON.stringify(h.label)}, ${p(h.contents)})`;
              throw new Error("Unknown doc type " + h.type);
            }
            function y(h) {
              if (typeof h != "symbol") return JSON.stringify(String(h));
              if (h in i) return i[h];
              let g = String(h).slice(7, -1) || "symbol";
              for (let c2 = 0; ; c2++) {
                let f = g + (c2 > 0 ? ` #${c2}` : "");
                if (!l.has(f)) return l.add(f), i[h] = `Symbol.for(${JSON.stringify(f)})`;
              }
            }
          }
          r2.exports = { printDocToDebug: n };
        } }), qe = te({ "src/document/index.js"(e, r2) {
          ne(), r2.exports = { builders: Un(), printer: qD(), utils: Yt(), debug: MD() };
        } }), ja = {};
        Kt(ja, { default: () => RD });
        function RD(e) {
          if (typeof e != "string") throw new TypeError("Expected a string");
          return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var $D = ht({ "node_modules/escape-string-regexp/index.js"() {
          ne();
        } }), qa = te({ "node_modules/semver/internal/debug.js"(e, r2) {
          ne();
          var t = typeof wt == "object" && wt.env && wt.env.NODE_DEBUG && /\bsemver\b/i.test(wt.env.NODE_DEBUG) ? function() {
            for (var s = arguments.length, a = new Array(s), n = 0; n < s; n++) a[n] = arguments[n];
            return console.error("SEMVER", ...a);
          } : () => {
          };
          r2.exports = t;
        } }), Ma = te({ "node_modules/semver/internal/constants.js"(e, r2) {
          ne();
          var t = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
          r2.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: n };
        } }), VD = te({ "node_modules/semver/internal/re.js"(e, r2) {
          ne();
          var { MAX_SAFE_COMPONENT_LENGTH: t } = Ma(), s = qa();
          e = r2.exports = {};
          var a = e.re = [], n = e.src = [], u = e.t = {}, i = 0, l = (p, y, h) => {
            let g = i++;
            s(p, g, y), u[p] = g, n[g] = y, a[g] = new RegExp(y, h ? "g" : void 0);
          };
          l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\.${n[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n[u.BUILDIDENTIFIER]}(?:\\.${n[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`), l("FULL", `^${n[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`), l("LOOSE", `^${n[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`), l("XRANGE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", n[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n[u.GTLT]}\\s*(${n[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n[u.XRANGEPLAIN]})\\s+-\\s+(${n[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), WD = te({ "node_modules/semver/internal/parse-options.js"(e, r2) {
          ne();
          var t = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t.filter((n) => a[n]).reduce((n, u) => (n[u] = true, n), {}) : {};
          r2.exports = s;
        } }), HD = te({ "node_modules/semver/internal/identifiers.js"(e, r2) {
          ne();
          var t = /^[0-9]+$/, s = (n, u) => {
            let i = t.test(n), l = t.test(u);
            return i && l && (n = +n, u = +u), n === u ? 0 : i && !l ? -1 : l && !i ? 1 : n < u ? -1 : 1;
          }, a = (n, u) => s(u, n);
          r2.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
        } }), GD = te({ "node_modules/semver/classes/semver.js"(e, r2) {
          ne();
          var t = qa(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = Ma(), { re: n, t: u } = VD(), i = WD(), { compareIdentifiers: l } = HD(), p = class {
            constructor(y, h) {
              if (h = i(h), y instanceof p) {
                if (y.loose === !!h.loose && y.includePrerelease === !!h.includePrerelease) return y;
                y = y.version;
              } else if (typeof y != "string") throw new TypeError(`Invalid Version: ${y}`);
              if (y.length > s) throw new TypeError(`version is longer than ${s} characters`);
              t("SemVer", y, h), this.options = h, this.loose = !!h.loose, this.includePrerelease = !!h.includePrerelease;
              let g = y.trim().match(h.loose ? n[u.LOOSE] : n[u.FULL]);
              if (!g) throw new TypeError(`Invalid Version: ${y}`);
              if (this.raw = y, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a || this.major < 0) throw new TypeError("Invalid major version");
              if (this.minor > a || this.minor < 0) throw new TypeError("Invalid minor version");
              if (this.patch > a || this.patch < 0) throw new TypeError("Invalid patch version");
              g[4] ? this.prerelease = g[4].split(".").map((c2) => {
                if (/^[0-9]+$/.test(c2)) {
                  let f = +c2;
                  if (f >= 0 && f < a) return f;
                }
                return c2;
              }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
            }
            format() {
              return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
            }
            toString() {
              return this.version;
            }
            compare(y) {
              if (t("SemVer.compare", this.version, this.options, y), !(y instanceof p)) {
                if (typeof y == "string" && y === this.version) return 0;
                y = new p(y, this.options);
              }
              return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);
            }
            compareMain(y) {
              return y instanceof p || (y = new p(y, this.options)), l(this.major, y.major) || l(this.minor, y.minor) || l(this.patch, y.patch);
            }
            comparePre(y) {
              if (y instanceof p || (y = new p(y, this.options)), this.prerelease.length && !y.prerelease.length) return -1;
              if (!this.prerelease.length && y.prerelease.length) return 1;
              if (!this.prerelease.length && !y.prerelease.length) return 0;
              let h = 0;
              do {
                let g = this.prerelease[h], c2 = y.prerelease[h];
                if (t("prerelease compare", h, g, c2), g === void 0 && c2 === void 0) return 0;
                if (c2 === void 0) return 1;
                if (g === void 0) return -1;
                if (g === c2) continue;
                return l(g, c2);
              } while (++h);
            }
            compareBuild(y) {
              y instanceof p || (y = new p(y, this.options));
              let h = 0;
              do {
                let g = this.build[h], c2 = y.build[h];
                if (t("prerelease compare", h, g, c2), g === void 0 && c2 === void 0) return 0;
                if (c2 === void 0) return 1;
                if (g === void 0) return -1;
                if (g === c2) continue;
                return l(g, c2);
              } while (++h);
            }
            inc(y, h) {
              switch (y) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", h), this.inc("pre", h);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", h), this.inc("pre", h);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0) this.prerelease = [0];
                  else {
                    let g = this.prerelease.length;
                    for (; --g >= 0; ) typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
                    g === -1 && this.prerelease.push(0);
                  }
                  h && (l(this.prerelease[0], h) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h, 0]) : this.prerelease = [h, 0]);
                  break;
                default:
                  throw new Error(`invalid increment argument: ${y}`);
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          r2.exports = p;
        } }), zn = te({ "node_modules/semver/functions/compare.js"(e, r2) {
          ne();
          var t = GD(), s = (a, n, u) => new t(a, u).compare(new t(n, u));
          r2.exports = s;
        } }), UD = te({ "node_modules/semver/functions/lt.js"(e, r2) {
          ne();
          var t = zn(), s = (a, n, u) => t(a, n, u) < 0;
          r2.exports = s;
        } }), JD = te({ "node_modules/semver/functions/gte.js"(e, r2) {
          ne();
          var t = zn(), s = (a, n, u) => t(a, n, u) >= 0;
          r2.exports = s;
        } }), zD = te({ "src/utils/arrayify.js"(e, r2) {
          ne(), r2.exports = (t, s) => Object.entries(t).map((a) => {
            let [n, u] = a;
            return Object.assign({ [s]: n }, u);
          });
        } }), XD = te({ "node_modules/outdent/lib/index.js"(e, r2) {
          ne(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
          function t() {
            for (var E = [], N = 0; N < arguments.length; N++) E[N] = arguments[N];
          }
          function s() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
          }
          function a() {
            return { add: t, delete: t, get: t, set: t, has: function(E) {
              return false;
            } };
          }
          var n = Object.prototype.hasOwnProperty, u = function(E, N) {
            return n.call(E, N);
          };
          function i(E, N) {
            for (var x in N) u(N, x) && (E[x] = N[x]);
            return E;
          }
          var l = /^[ \t]*(?:\r\n|\r|\n)/, p = /(?:\r\n|\r|\n)[ \t]*$/, y = /^(?:[\r\n]|$)/, h = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function c2(E, N, x) {
            var I = 0, P = E[0].match(h);
            P && (I = P[1].length);
            var $ = "(\\r\\n|\\r|\\n).{0," + I + "}", D = new RegExp($, "g");
            N && (E = E.slice(1));
            var T = x.newline, m = x.trimLeadingNewline, C = x.trimTrailingNewline, o = typeof T == "string", d = E.length, v = E.map(function(S, b) {
              return S = S.replace(D, "$1"), b === 0 && m && (S = S.replace(l, "")), b === d - 1 && C && (S = S.replace(p, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
                return T;
              })), S;
            });
            return v;
          }
          function f(E, N) {
            for (var x = "", I = 0, P = E.length; I < P; I++) x += E[I], I < P - 1 && (x += N[I]);
            return x;
          }
          function F(E) {
            return u(E, "raw") && u(E, "length");
          }
          function _(E) {
            var N = s(), x = s();
            function I($) {
              for (var D = [], T = 1; T < arguments.length; T++) D[T - 1] = arguments[T];
              if (F($)) {
                var m = $, C = (D[0] === I || D[0] === w) && g.test(m[0]) && y.test(m[1]), o = C ? x : N, d = o.get(m);
                if (d || (d = c2(m, C, E), o.set(m, d)), D.length === 0) return d[0];
                var v = f(d, C ? D.slice(1) : D);
                return v;
              } else return _(i(i({}, E), $ || {}));
            }
            var P = i(I, { string: function($) {
              return c2([$], false, E)[0];
            } });
            return P;
          }
          var w = _({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e.outdent = w, e.default = w, typeof r2 < "u") try {
            r2.exports = w, Object.defineProperty(w, "__esModule", { value: true }), w.default = w, w.outdent = w;
          } catch {
          }
        } }), KD = te({ "src/main/core-options.js"(e, r2) {
          ne();
          var { outdent: t } = XD(), s = "Config", a = "Editor", n = "Format", u = "Other", i = "Output", l = "Global", p = "Special", y = { cursorOffset: { since: "1.4.0", category: p, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h) => typeof h == "string" || typeof h == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: p, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: p, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          r2.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: n, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p, options: y };
        } }), Xn = te({ "src/main/support.js"(e, r2) {
          ne();
          var t = { compare: zn(), lt: UD(), gte: JD() }, s = zD(), a = Ia().version, n = KD().options;
          function u() {
            let { plugins: l = [], showUnreleased: p = false, showDeprecated: y = false, showInternal: h = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = a.split("-", 1)[0], c2 = l.flatMap((E) => E.languages || []).filter(F), f = s(Object.assign({}, ...l.map((E) => {
              let { options: N } = E;
              return N;
            }), n), "name").filter((E) => F(E) && _(E)).sort((E, N) => E.name === N.name ? 0 : E.name < N.name ? -1 : 1).map(w).map((E) => {
              E = Object.assign({}, E), Array.isArray(E.default) && (E.default = E.default.length === 1 ? E.default[0].value : E.default.filter(F).sort((x, I) => t.compare(I.since, x.since))[0].value), Array.isArray(E.choices) && (E.choices = E.choices.filter((x) => F(x) && _(x)), E.name === "parser" && i(E, c2, l));
              let N = Object.fromEntries(l.filter((x) => x.defaultOptions && x.defaultOptions[E.name] !== void 0).map((x) => [x.name, x.defaultOptions[E.name]]));
              return Object.assign(Object.assign({}, E), {}, { pluginDefaults: N });
            });
            return { languages: c2, options: f };
            function F(E) {
              return p || !("since" in E) || E.since && t.gte(g, E.since);
            }
            function _(E) {
              return y || !("deprecated" in E) || E.deprecated && t.lt(g, E.deprecated);
            }
            function w(E) {
              if (h) return E;
              let { cliName: N, cliCategory: x, cliDescription: I } = E;
              return Hn(E, hD);
            }
          }
          function i(l, p, y) {
            let h = new Set(l.choices.map((g) => g.value));
            for (let g of p) if (g.parsers) {
              for (let c2 of g.parsers) if (!h.has(c2)) {
                h.add(c2);
                let f = y.find((_) => _.parsers && _.parsers[c2]), F = g.name;
                f && f.name && (F += ` (plugin: ${f.name})`), l.choices.push({ value: c2, description: F });
              }
            }
          }
          r2.exports = { getSupportInfo: u };
        } }), Kn = te({ "src/utils/is-non-empty-array.js"(e, r2) {
          ne();
          function t(s) {
            return Array.isArray(s) && s.length > 0;
          }
          r2.exports = t;
        } }), Pr = te({ "src/utils/text/skip.js"(e, r2) {
          ne();
          function t(i) {
            return (l, p, y) => {
              let h = y && y.backwards;
              if (p === false) return false;
              let { length: g } = l, c2 = p;
              for (; c2 >= 0 && c2 < g; ) {
                let f = l.charAt(c2);
                if (i instanceof RegExp) {
                  if (!i.test(f)) return c2;
                } else if (!i.includes(f)) return c2;
                h ? c2-- : c2++;
              }
              return c2 === -1 || c2 === g ? c2 : false;
            };
          }
          var s = t(/\s/), a = t(" 	"), n = t(",; 	"), u = t(/[^\n\r]/);
          r2.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: n, skipEverythingButNewLine: u };
        } }), Ra = te({ "src/utils/text/skip-inline-comment.js"(e, r2) {
          ne();
          function t(s, a) {
            if (a === false) return false;
            if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
              for (let n = a + 2; n < s.length; ++n) if (s.charAt(n) === "*" && s.charAt(n + 1) === "/") return n + 2;
            }
            return a;
          }
          r2.exports = t;
        } }), $a = te({ "src/utils/text/skip-trailing-comment.js"(e, r2) {
          ne();
          var { skipEverythingButNewLine: t } = Pr();
          function s(a, n) {
            return n === false ? false : a.charAt(n) === "/" && a.charAt(n + 1) === "/" ? t(a, n) : n;
          }
          r2.exports = s;
        } }), Va = te({ "src/utils/text/skip-newline.js"(e, r2) {
          ne();
          function t(s, a, n) {
            let u = n && n.backwards;
            if (a === false) return false;
            let i = s.charAt(a);
            if (u) {
              if (s.charAt(a - 1) === "\r" && i === `
`) return a - 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return a - 1;
            } else {
              if (i === "\r" && s.charAt(a + 1) === `
`) return a + 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return a + 1;
            }
            return a;
          }
          r2.exports = t;
        } }), YD = te({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r2) {
          ne();
          var t = Ra(), s = Va(), a = $a(), { skipSpaces: n } = Pr();
          function u(i, l) {
            let p = null, y = l;
            for (; y !== p; ) p = y, y = n(i, y), y = t(i, y), y = a(i, y), y = s(i, y);
            return y;
          }
          r2.exports = u;
        } }), Ue = te({ "src/common/util.js"(e, r2) {
          ne();
          var { default: t } = ($D(), ft(ja)), s = lt(), { getSupportInfo: a } = Xn(), n = Kn(), u = Oa(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y } = Pr(), h = Ra(), g = $a(), c2 = Va(), f = YD(), F = (V) => V[V.length - 2];
          function _(V) {
            return (j, Y, ie) => {
              let ee = ie && ie.backwards;
              if (Y === false) return false;
              let { length: ce } = j, W = Y;
              for (; W >= 0 && W < ce; ) {
                let K = j.charAt(W);
                if (V instanceof RegExp) {
                  if (!V.test(K)) return W;
                } else if (!V.includes(K)) return W;
                ee ? W-- : W++;
              }
              return W === -1 || W === ce ? W : false;
            };
          }
          function w(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie = l(V, Y.backwards ? j - 1 : j, Y), ee = c2(V, ie, Y);
            return ie !== ee;
          }
          function E(V, j, Y) {
            for (let ie = j; ie < Y; ++ie) if (V.charAt(ie) === `
`) return true;
            return false;
          }
          function N(V, j, Y) {
            let ie = Y(j) - 1;
            ie = l(V, ie, { backwards: true }), ie = c2(V, ie, { backwards: true }), ie = l(V, ie, { backwards: true });
            let ee = c2(V, ie, { backwards: true });
            return ie !== ee;
          }
          function x(V, j) {
            let Y = null, ie = j;
            for (; ie !== Y; ) Y = ie, ie = p(V, ie), ie = h(V, ie), ie = l(V, ie);
            return ie = g(V, ie), ie = c2(V, ie), ie !== false && w(V, ie);
          }
          function I(V, j, Y) {
            return x(V, Y(j));
          }
          function P(V, j, Y) {
            return f(V, Y(j));
          }
          function $(V, j, Y) {
            return V.charAt(P(V, j, Y));
          }
          function D(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return l(V, Y.backwards ? j - 1 : j, Y) !== j;
          }
          function T(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie = 0;
            for (let ee = Y; ee < V.length; ++ee) V[ee] === "	" ? ie = ie + j - ie % j : ie++;
            return ie;
          }
          function m(V, j) {
            let Y = V.lastIndexOf(`
`);
            return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\t ]*/)[0], j);
          }
          function C(V, j) {
            let Y = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee = j === "'" ? ie : Y, ce = ee === ie ? Y : ie, W = ee;
            if (V.includes(ee.quote) || V.includes(ce.quote)) {
              let K = (V.match(ee.regex) || []).length, de = (V.match(ce.regex) || []).length;
              W = K > de ? ce : ee;
            }
            return W;
          }
          function o(V, j) {
            let Y = V.slice(1, -1), ie = j.parser === "json" || j.parser === "json5" && j.quoteProps === "preserve" && !j.singleQuote ? '"' : j.__isInHtmlAttribute ? "'" : C(Y, j.singleQuote ? "'" : '"').quote;
            return d(Y, ie, !(j.parser === "css" || j.parser === "less" || j.parser === "scss" || j.__embeddedInHtml));
          }
          function d(V, j, Y) {
            let ie = j === '"' ? "'" : '"', ee = /\\(.)|(["'])/gs, ce = V.replace(ee, (W, K, de) => K === ie ? K : de === j ? "\\" + de : de || (Y && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K) ? K : "\\" + K));
            return j + ce + j;
          }
          function v(V) {
            return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function S(V, j) {
            let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
            return Y === null ? 0 : Y.reduce((ie, ee) => Math.max(ie, ee.length / j.length), 0);
          }
          function b(V, j) {
            let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
            if (Y === null) return 0;
            let ie = /* @__PURE__ */ new Map(), ee = 0;
            for (let ce of Y) {
              let W = ce.length / j.length;
              ie.set(W, true), W > ee && (ee = W);
            }
            for (let ce = 1; ce < ee; ce++) if (!ie.get(ce)) return ce;
            return ee + 1;
          }
          function B(V, j) {
            (V.comments || (V.comments = [])).push(j), j.printed = false, j.nodeDescription = Q(V);
          }
          function k(V, j) {
            j.leading = true, j.trailing = false, B(V, j);
          }
          function M(V, j, Y) {
            j.leading = false, j.trailing = false, Y && (j.marker = Y), B(V, j);
          }
          function R(V, j) {
            j.leading = false, j.trailing = true, B(V, j);
          }
          function q(V, j) {
            let { languages: Y } = a({ plugins: j.plugins }), ie = Y.find((ee) => {
              let { name: ce } = ee;
              return ce.toLowerCase() === V;
            }) || Y.find((ee) => {
              let { aliases: ce } = ee;
              return Array.isArray(ce) && ce.includes(V);
            }) || Y.find((ee) => {
              let { extensions: ce } = ee;
              return Array.isArray(ce) && ce.includes(`.${V}`);
            });
            return ie && ie.parsers[0];
          }
          function J(V) {
            return V && V.type === "front-matter";
          }
          function L(V) {
            let j = /* @__PURE__ */ new WeakMap();
            return function(Y) {
              return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);
            };
          }
          function Q(V) {
            let j = V.type || V.kind || "(unknown type)", Y = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
            return Y.length > 20 && (Y = Y.slice(0, 19) + "\u2026"), j + (Y ? " " + Y : "");
          }
          r2.exports = { inferParserByLanguage: q, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: F, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $, skip: _, skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y, skipInlineComment: h, skipTrailingComment: g, skipNewline: c2, isNextLineEmptyAfterIndex: x, isNextLineEmpty: I, isPreviousLineEmpty: N, hasNewline: w, hasNewlineInRange: E, hasSpaces: D, getAlignmentSize: T, getIndentSize: m, getPreferredQuote: C, printString: o, printNumber: v, makeString: d, addLeadingComment: k, addDanglingComment: M, addTrailingComment: R, isFrontMatterNode: J, isNonEmptyArray: n, createGroupIdMapper: L };
        } }), Wa = {};
        Kt(Wa, { basename: () => za, default: () => Ka, delimiter: () => Mn, dirname: () => Ja, extname: () => Xa, isAbsolute: () => Qn, join: () => Ga, normalize: () => Yn, relative: () => Ua, resolve: () => wr, sep: () => qn });
        function Ha(e, r2) {
          for (var t = 0, s = e.length - 1; s >= 0; s--) {
            var a = e[s];
            a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
          }
          if (r2) for (; t--; t) e.unshift("..");
          return e;
        }
        function wr() {
          for (var e = "", r2 = false, t = arguments.length - 1; t >= -1 && !r2; t--) {
            var s = t >= 0 ? arguments[t] : "/";
            if (typeof s != "string") throw new TypeError("Arguments to path.resolve must be strings");
            if (!s) continue;
            e = s + "/" + e, r2 = s.charAt(0) === "/";
          }
          return e = Ha(Zn(e.split("/"), function(a) {
            return !!a;
          }), !r2).join("/"), (r2 ? "/" : "") + e || ".";
        }
        function Yn(e) {
          var r2 = Qn(e), t = Ya(e, -1) === "/";
          return e = Ha(Zn(e.split("/"), function(s) {
            return !!s;
          }), !r2).join("/"), !e && !r2 && (e = "."), e && t && (e += "/"), (r2 ? "/" : "") + e;
        }
        function Qn(e) {
          return e.charAt(0) === "/";
        }
        function Ga() {
          var e = Array.prototype.slice.call(arguments, 0);
          return Yn(Zn(e, function(r2, t) {
            if (typeof r2 != "string") throw new TypeError("Arguments to path.join must be strings");
            return r2;
          }).join("/"));
        }
        function Ua(e, r2) {
          e = wr(e).substr(1), r2 = wr(r2).substr(1);
          function t(p) {
            for (var y = 0; y < p.length && p[y] === ""; y++) ;
            for (var h = p.length - 1; h >= 0 && p[h] === ""; h--) ;
            return y > h ? [] : p.slice(y, h - y + 1);
          }
          for (var s = t(e.split("/")), a = t(r2.split("/")), n = Math.min(s.length, a.length), u = n, i = 0; i < n; i++) if (s[i] !== a[i]) {
            u = i;
            break;
          }
          for (var l = [], i = u; i < s.length; i++) l.push("..");
          return l = l.concat(a.slice(u)), l.join("/");
        }
        function Ja(e) {
          var r2 = Ir(e), t = r2[0], s = r2[1];
          return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
        }
        function za(e, r2) {
          var t = Ir(e)[2];
          return r2 && t.substr(-1 * r2.length) === r2 && (t = t.substr(0, t.length - r2.length)), t;
        }
        function Xa(e) {
          return Ir(e)[3];
        }
        function Zn(e, r2) {
          if (e.filter) return e.filter(r2);
          for (var t = [], s = 0; s < e.length; s++) r2(e[s], s, e) && t.push(e[s]);
          return t;
        }
        var Na, Ir, qn, Mn, Ka, Ya, QD = ht({ "node-modules-polyfills:path"() {
          ne(), Na = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Ir = function(e) {
            return Na.exec(e).slice(1);
          }, qn = "/", Mn = ":", Ka = { extname: Xa, basename: za, dirname: Ja, sep: qn, delimiter: Mn, relative: Ua, join: Ga, isAbsolute: Qn, normalize: Yn, resolve: wr }, Ya = "ab".substr(-1) === "b" ? function(e, r2, t) {
            return e.substr(r2, t);
          } : function(e, r2, t) {
            return r2 < 0 && (r2 = e.length + r2), e.substr(r2, t);
          };
        } }), ZD = te({ "node-modules-polyfills-commonjs:path"(e, r2) {
          ne();
          var t = (QD(), ft(Wa));
          if (t && t.default) {
            r2.exports = t.default;
            for (let s in t) r2.exports[s] = t[s];
          } else t && (r2.exports = t);
        } }), Qt = te({ "src/common/errors.js"(e, r2) {
          ne();
          var t = class extends Error {
          }, s = class extends Error {
          }, a = class extends Error {
          }, n = class extends Error {
          };
          r2.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: n };
        } }), vt = {};
        Kt(vt, { __assign: () => Nr, __asyncDelegator: () => fm, __asyncGenerator: () => pm, __asyncValues: () => Dm, __await: () => Xt, __awaiter: () => sm, __classPrivateFieldGet: () => ym, __classPrivateFieldSet: () => hm, __createBinding: () => am, __decorate: () => rm, __exportStar: () => om, __extends: () => em, __generator: () => im, __importDefault: () => gm, __importStar: () => dm, __makeTemplateObject: () => mm, __metadata: () => um, __param: () => nm, __read: () => Qa, __rest: () => tm, __spread: () => lm, __spreadArrays: () => cm, __values: () => Rn });
        function em(e, r2) {
          Br(e, r2);
          function t() {
            this.constructor = e;
          }
          e.prototype = r2 === null ? Object.create(r2) : (t.prototype = r2.prototype, new t());
        }
        function tm(e, r2) {
          var t = {};
          for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && r2.indexOf(s) < 0 && (t[s] = e[s]);
          if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++) r2.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);
          return t;
        }
        function rm(e, r2, t, s) {
          var a = arguments.length, n = a < 3 ? r2 : s === null ? s = Object.getOwnPropertyDescriptor(r2, t) : s, u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") n = Reflect.decorate(e, r2, t, s);
          else for (var i = e.length - 1; i >= 0; i--) (u = e[i]) && (n = (a < 3 ? u(n) : a > 3 ? u(r2, t, n) : u(r2, t)) || n);
          return a > 3 && n && Object.defineProperty(r2, t, n), n;
        }
        function nm(e, r2) {
          return function(t, s) {
            r2(t, s, e);
          };
        }
        function um(e, r2) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(e, r2);
        }
        function sm(e, r2, t, s) {
          function a(n) {
            return n instanceof t ? n : new t(function(u) {
              u(n);
            });
          }
          return new (t || (t = Promise))(function(n, u) {
            function i(y) {
              try {
                p(s.next(y));
              } catch (h) {
                u(h);
              }
            }
            function l(y) {
              try {
                p(s.throw(y));
              } catch (h) {
                u(h);
              }
            }
            function p(y) {
              y.done ? n(y.value) : a(y.value).then(i, l);
            }
            p((s = s.apply(e, r2 || [])).next());
          });
        }
        function im(e, r2) {
          var t = { label: 0, sent: function() {
            if (n[0] & 1) throw n[1];
            return n[1];
          }, trys: [], ops: [] }, s, a, n, u;
          return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
            return this;
          }), u;
          function i(p) {
            return function(y) {
              return l([p, y]);
            };
          }
          function l(p) {
            if (s) throw new TypeError("Generator is already executing.");
            for (; t; ) try {
              if (s = 1, a && (n = p[0] & 2 ? a.return : p[0] ? a.throw || ((n = a.return) && n.call(a), 0) : a.next) && !(n = n.call(a, p[1])).done) return n;
              switch (a = 0, n && (p = [p[0] & 2, n.value]), p[0]) {
                case 0:
                case 1:
                  n = p;
                  break;
                case 4:
                  return t.label++, { value: p[1], done: false };
                case 5:
                  t.label++, a = p[1], p = [0];
                  continue;
                case 7:
                  p = t.ops.pop(), t.trys.pop();
                  continue;
                default:
                  if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                    t = 0;
                    continue;
                  }
                  if (p[0] === 3 && (!n || p[1] > n[0] && p[1] < n[3])) {
                    t.label = p[1];
                    break;
                  }
                  if (p[0] === 6 && t.label < n[1]) {
                    t.label = n[1], n = p;
                    break;
                  }
                  if (n && t.label < n[2]) {
                    t.label = n[2], t.ops.push(p);
                    break;
                  }
                  n[2] && t.ops.pop(), t.trys.pop();
                  continue;
              }
              p = r2.call(e, t);
            } catch (y) {
              p = [6, y], a = 0;
            } finally {
              s = n = 0;
            }
            if (p[0] & 5) throw p[1];
            return { value: p[0] ? p[1] : void 0, done: true };
          }
        }
        function am(e, r2, t, s) {
          s === void 0 && (s = t), e[s] = r2[t];
        }
        function om(e, r2) {
          for (var t in e) t !== "default" && !r2.hasOwnProperty(t) && (r2[t] = e[t]);
        }
        function Rn(e) {
          var r2 = typeof Symbol == "function" && Symbol.iterator, t = r2 && e[r2], s = 0;
          if (t) return t.call(e);
          if (e && typeof e.length == "number") return { next: function() {
            return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
          } };
          throw new TypeError(r2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function Qa(e, r2) {
          var t = typeof Symbol == "function" && e[Symbol.iterator];
          if (!t) return e;
          var s = t.call(e), a, n = [], u;
          try {
            for (; (r2 === void 0 || r2-- > 0) && !(a = s.next()).done; ) n.push(a.value);
          } catch (i) {
            u = { error: i };
          } finally {
            try {
              a && !a.done && (t = s.return) && t.call(s);
            } finally {
              if (u) throw u.error;
            }
          }
          return n;
        }
        function lm() {
          for (var e = [], r2 = 0; r2 < arguments.length; r2++) e = e.concat(Qa(arguments[r2]));
          return e;
        }
        function cm() {
          for (var e = 0, r2 = 0, t = arguments.length; r2 < t; r2++) e += arguments[r2].length;
          for (var s = Array(e), a = 0, r2 = 0; r2 < t; r2++) for (var n = arguments[r2], u = 0, i = n.length; u < i; u++, a++) s[a] = n[u];
          return s;
        }
        function Xt(e) {
          return this instanceof Xt ? (this.v = e, this) : new Xt(e);
        }
        function pm(e, r2, t) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var s = t.apply(e, r2 || []), a, n = [];
          return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
            return this;
          }, a;
          function u(g) {
            s[g] && (a[g] = function(c2) {
              return new Promise(function(f, F) {
                n.push([g, c2, f, F]) > 1 || i(g, c2);
              });
            });
          }
          function i(g, c2) {
            try {
              l(s[g](c2));
            } catch (f) {
              h(n[0][3], f);
            }
          }
          function l(g) {
            g.value instanceof Xt ? Promise.resolve(g.value.v).then(p, y) : h(n[0][2], g);
          }
          function p(g) {
            i("next", g);
          }
          function y(g) {
            i("throw", g);
          }
          function h(g, c2) {
            g(c2), n.shift(), n.length && i(n[0][0], n[0][1]);
          }
        }
        function fm(e) {
          var r2, t;
          return r2 = {}, s("next"), s("throw", function(a) {
            throw a;
          }), s("return"), r2[Symbol.iterator] = function() {
            return this;
          }, r2;
          function s(a, n) {
            r2[a] = e[a] ? function(u) {
              return (t = !t) ? { value: Xt(e[a](u)), done: a === "return" } : n ? n(u) : u;
            } : n;
          }
        }
        function Dm(e) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var r2 = e[Symbol.asyncIterator], t;
          return r2 ? r2.call(e) : (e = typeof Rn == "function" ? Rn(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
            return this;
          }, t);
          function s(n) {
            t[n] = e[n] && function(u) {
              return new Promise(function(i, l) {
                u = e[n](u), a(i, l, u.done, u.value);
              });
            };
          }
          function a(n, u, i, l) {
            Promise.resolve(l).then(function(p) {
              n({ value: p, done: i });
            }, u);
          }
        }
        function mm(e, r2) {
          return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r2 }) : e.raw = r2, e;
        }
        function dm(e) {
          if (e && e.__esModule) return e;
          var r2 = {};
          if (e != null) for (var t in e) Object.hasOwnProperty.call(e, t) && (r2[t] = e[t]);
          return r2.default = e, r2;
        }
        function gm(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function ym(e, r2) {
          if (!r2.has(e)) throw new TypeError("attempted to get private field on non-instance");
          return r2.get(e);
        }
        function hm(e, r2, t) {
          if (!r2.has(e)) throw new TypeError("attempted to set private field on non-instance");
          return r2.set(e, t), t;
        }
        var Br, Nr, Et = ht({ "node_modules/tslib/tslib.es6.js"() {
          ne(), Br = function(e, r2) {
            return Br = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
              t.__proto__ = s;
            } || function(t, s) {
              for (var a in s) s.hasOwnProperty(a) && (t[a] = s[a]);
            }, Br(e, r2);
          }, Nr = function() {
            return Nr = Object.assign || function(r2) {
              for (var t, s = 1, a = arguments.length; s < a; s++) {
                t = arguments[s];
                for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (r2[n] = t[n]);
              }
              return r2;
            }, Nr.apply(this, arguments);
          };
        } }), Za = te({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (r2) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r2) ? r2 : JSON.stringify(r2), value(r2) {
            if (r2 === null || typeof r2 != "object") return JSON.stringify(r2);
            if (Array.isArray(r2)) return `[${r2.map((s) => e.apiDescriptor.value(s)).join(", ")}]`;
            let t = Object.keys(r2);
            return t.length === 0 ? "{}" : `{ ${t.map((s) => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(r2[s])}`).join(", ")} }`;
          }, pair: (r2) => {
            let { key: t, value: s } = r2;
            return e.apiDescriptor.value({ [t]: s });
          } };
        } }), vm = te({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = (Et(), ft(vt));
          r2.__exportStar(Za(), e);
        } }), kr = te({ "scripts/build/shims/chalk.cjs"(e, r2) {
          ne();
          var t = (s) => s;
          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, r2.exports = t;
        } }), eo = te({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = kr();
          e.commonDeprecatedHandler = (t, s, a) => {
            let { descriptor: n } = a, u = [`${r2.default.yellow(typeof t == "string" ? n.key(t) : n.pair(t))} is deprecated`];
            return s && u.push(`we now treat it as ${r2.default.blue(typeof s == "string" ? n.key(s) : n.pair(s))}`), u.join("; ") + ".";
          };
        } }), Cm = te({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = (Et(), ft(vt));
          r2.__exportStar(eo(), e);
        } }), Em = te({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = kr();
          e.commonInvalidHandler = (t, s, a) => [`Invalid ${r2.default.red(a.descriptor.key(t))} value.`, `Expected ${r2.default.blue(a.schemas[t].expected(a))},`, `but received ${r2.default.red(a.descriptor.value(s))}.`].join(" ");
        } }), to = te({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = (Et(), ft(vt));
          r2.__exportStar(Em(), e);
        } }), Fm = te({ "node_modules/vnopts/node_modules/leven/index.js"(e, r2) {
          ne();
          var t = [], s = [];
          r2.exports = function(a, n) {
            if (a === n) return 0;
            var u = a;
            a.length > n.length && (a = n, n = u);
            var i = a.length, l = n.length;
            if (i === 0) return l;
            if (l === 0) return i;
            for (; i > 0 && a.charCodeAt(~-i) === n.charCodeAt(~-l); ) i--, l--;
            if (i === 0) return l;
            for (var p = 0; p < i && a.charCodeAt(p) === n.charCodeAt(p); ) p++;
            if (i -= p, l -= p, i === 0) return l;
            for (var y, h, g, c2, f = 0, F = 0; f < i; ) s[p + f] = a.charCodeAt(p + f), t[f] = ++f;
            for (; F < l; ) for (y = n.charCodeAt(p + F), g = F++, h = F, f = 0; f < i; f++) c2 = y === s[p + f] ? g : g + 1, g = t[f], h = t[f] = g > h ? c2 > h ? h + 1 : c2 : c2 > g ? g + 1 : c2;
            return h;
          };
        } }), ro = te({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = kr(), t = Fm();
          e.levenUnknownHandler = (s, a, n) => {
            let { descriptor: u, logger: i, schemas: l } = n, p = [`Ignored unknown option ${r2.default.yellow(u.pair({ key: s, value: a }))}.`], y = Object.keys(l).sort().find((h) => t(s, h) < 3);
            y && p.push(`Did you mean ${r2.default.blue(u.key(y))}?`), i.warn(p.join(" "));
          };
        } }), Am = te({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = (Et(), ft(vt));
          r2.__exportStar(ro(), e);
        } }), Sm = te({ "node_modules/vnopts/lib/handlers/index.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = (Et(), ft(vt));
          r2.__exportStar(Cm(), e), r2.__exportStar(to(), e), r2.__exportStar(Am(), e);
        } }), Ft = te({ "node_modules/vnopts/lib/schema.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t(n, u) {
            let i = new n(u), l = Object.create(i);
            for (let p of r2) p in u && (l[p] = a(u[p], i, s.prototype[p].length));
            return l;
          }
          e.createSchema = t;
          var s = class {
            constructor(n) {
              this.name = n.name;
            }
            static create(n) {
              return t(this, n);
            }
            default(n) {
            }
            expected(n) {
              return "nothing";
            }
            validate(n, u) {
              return false;
            }
            deprecated(n, u) {
              return false;
            }
            forward(n, u) {
            }
            redirect(n, u) {
            }
            overlap(n, u, i) {
              return n;
            }
            preprocess(n, u) {
              return n;
            }
            postprocess(n, u) {
              return n;
            }
          };
          e.Schema = s;
          function a(n, u, i) {
            return typeof n == "function" ? function() {
              for (var l = arguments.length, p = new Array(l), y = 0; y < l; y++) p[y] = arguments[y];
              return n(...p.slice(0, i - 1), u, ...p.slice(i - 1));
            } : () => n;
          }
        } }), xm = te({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = Ft(), t = class extends r2.Schema {
            constructor(s) {
              super(s), this._sourceName = s.sourceName;
            }
            expected(s) {
              return s.schemas[this._sourceName].expected(s);
            }
            validate(s, a) {
              return a.schemas[this._sourceName].validate(s, a);
            }
            redirect(s, a) {
              return this._sourceName;
            }
          };
          e.AliasSchema = t;
        } }), bm = te({ "node_modules/vnopts/lib/schemas/any.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = Ft(), t = class extends r2.Schema {
            expected() {
              return "anything";
            }
            validate() {
              return true;
            }
          };
          e.AnySchema = t;
        } }), Tm = te({ "node_modules/vnopts/lib/schemas/array.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = (Et(), ft(vt)), t = Ft(), s = class extends t.Schema {
            constructor(n) {
              var { valueSchema: u, name: i = u.name } = n, l = r2.__rest(n, ["valueSchema", "name"]);
              super(Object.assign({}, l, { name: i })), this._valueSchema = u;
            }
            expected(n) {
              return `an array of ${this._valueSchema.expected(n)}`;
            }
            validate(n, u) {
              if (!Array.isArray(n)) return false;
              let i = [];
              for (let l of n) {
                let p = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
                p !== true && i.push(p.value);
              }
              return i.length === 0 ? true : { value: i };
            }
            deprecated(n, u) {
              let i = [];
              for (let l of n) {
                let p = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
                p !== false && i.push(...p.map((y) => {
                  let { value: h } = y;
                  return { value: [h] };
                }));
              }
              return i;
            }
            forward(n, u) {
              let i = [];
              for (let l of n) {
                let p = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
                i.push(...p.map(a));
              }
              return i;
            }
            redirect(n, u) {
              let i = [], l = [];
              for (let p of n) {
                let y = u.normalizeRedirectResult(this._valueSchema.redirect(p, u), p);
                "remain" in y && i.push(y.remain), l.push(...y.redirect.map(a));
              }
              return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
            }
            overlap(n, u) {
              return n.concat(u);
            }
          };
          e.ArraySchema = s;
          function a(n) {
            let { from: u, to: i } = n;
            return { from: [u], to: i };
          }
        } }), Bm = te({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = Ft(), t = class extends r2.Schema {
            expected() {
              return "true or false";
            }
            validate(s) {
              return typeof s == "boolean";
            }
          };
          e.BooleanSchema = t;
        } }), eu = te({ "node_modules/vnopts/lib/utils.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          function r2(c2, f) {
            let F = /* @__PURE__ */ Object.create(null);
            for (let _ of c2) {
              let w = _[f];
              if (F[w]) throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
              F[w] = _;
            }
            return F;
          }
          e.recordFromArray = r2;
          function t(c2, f) {
            let F = /* @__PURE__ */ new Map();
            for (let _ of c2) {
              let w = _[f];
              if (F.has(w)) throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
              F.set(w, _);
            }
            return F;
          }
          e.mapFromArray = t;
          function s() {
            let c2 = /* @__PURE__ */ Object.create(null);
            return (f) => {
              let F = JSON.stringify(f);
              return c2[F] ? true : (c2[F] = true, false);
            };
          }
          e.createAutoChecklist = s;
          function a(c2, f) {
            let F = [], _ = [];
            for (let w of c2) f(w) ? F.push(w) : _.push(w);
            return [F, _];
          }
          e.partition = a;
          function n(c2) {
            return c2 === Math.floor(c2);
          }
          e.isInt = n;
          function u(c2, f) {
            if (c2 === f) return 0;
            let F = typeof c2, _ = typeof f, w = ["undefined", "object", "boolean", "number", "string"];
            return F !== _ ? w.indexOf(F) - w.indexOf(_) : F !== "string" ? Number(c2) - Number(f) : c2.localeCompare(f);
          }
          e.comparePrimitive = u;
          function i(c2) {
            return c2 === void 0 ? {} : c2;
          }
          e.normalizeDefaultResult = i;
          function l(c2, f) {
            return c2 === true ? true : c2 === false ? { value: f } : c2;
          }
          e.normalizeValidateResult = l;
          function p(c2, f) {
            let F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return c2 === false ? false : c2 === true ? F ? true : [{ value: f }] : "value" in c2 ? [c2] : c2.length === 0 ? false : c2;
          }
          e.normalizeDeprecatedResult = p;
          function y(c2, f) {
            return typeof c2 == "string" || "key" in c2 ? { from: f, to: c2 } : "from" in c2 ? { from: c2.from, to: c2.to } : { from: f, to: c2.to };
          }
          e.normalizeTransferResult = y;
          function h(c2, f) {
            return c2 === void 0 ? [] : Array.isArray(c2) ? c2.map((F) => y(F, f)) : [y(c2, f)];
          }
          e.normalizeForwardResult = h;
          function g(c2, f) {
            let F = h(typeof c2 == "object" && "redirect" in c2 ? c2.redirect : c2, f);
            return F.length === 0 ? { remain: f, redirect: F } : typeof c2 == "object" && "remain" in c2 ? { remain: c2.remain, redirect: F } : { redirect: F };
          }
          e.normalizeRedirectResult = g;
        } }), Nm = te({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = Ft(), t = eu(), s = class extends r2.Schema {
            constructor(a) {
              super(a), this._choices = t.mapFromArray(a.choices.map((n) => n && typeof n == "object" ? n : { value: n }), "value");
            }
            expected(a) {
              let { descriptor: n } = a, u = Array.from(this._choices.keys()).map((p) => this._choices.get(p)).filter((p) => !p.deprecated).map((p) => p.value).sort(t.comparePrimitive).map(n.value), i = u.slice(0, -2), l = u.slice(-2);
              return i.concat(l.join(" or ")).join(", ");
            }
            validate(a) {
              return this._choices.has(a);
            }
            deprecated(a) {
              let n = this._choices.get(a);
              return n && n.deprecated ? { value: a } : false;
            }
            forward(a) {
              let n = this._choices.get(a);
              return n ? n.forward : void 0;
            }
            redirect(a) {
              let n = this._choices.get(a);
              return n ? n.redirect : void 0;
            }
          };
          e.ChoiceSchema = s;
        } }), no = te({ "node_modules/vnopts/lib/schemas/number.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = Ft(), t = class extends r2.Schema {
            expected() {
              return "a number";
            }
            validate(s, a) {
              return typeof s == "number";
            }
          };
          e.NumberSchema = t;
        } }), wm = te({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = eu(), t = no(), s = class extends t.NumberSchema {
            expected() {
              return "an integer";
            }
            validate(a, n) {
              return n.normalizeValidateResult(super.validate(a, n), a) === true && r2.isInt(a);
            }
          };
          e.IntegerSchema = s;
        } }), _m = te({ "node_modules/vnopts/lib/schemas/string.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = Ft(), t = class extends r2.Schema {
            expected() {
              return "a string";
            }
            validate(s) {
              return typeof s == "string";
            }
          };
          e.StringSchema = t;
        } }), Pm = te({ "node_modules/vnopts/lib/schemas/index.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = (Et(), ft(vt));
          r2.__exportStar(xm(), e), r2.__exportStar(bm(), e), r2.__exportStar(Tm(), e), r2.__exportStar(Bm(), e), r2.__exportStar(Nm(), e), r2.__exportStar(wm(), e), r2.__exportStar(no(), e), r2.__exportStar(_m(), e);
        } }), Im = te({ "node_modules/vnopts/lib/defaults.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = Za(), t = eo(), s = to(), a = ro();
          e.defaultDescriptor = r2.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
        } }), km = te({ "node_modules/vnopts/lib/normalize.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = Im(), t = eu();
          e.normalize = (a, n, u) => new s(n, u).normalize(a);
          var s = class {
            constructor(a, n) {
              let { logger: u = console, descriptor: i = r2.defaultDescriptor, unknown: l = r2.defaultUnknownHandler, invalid: p = r2.defaultInvalidHandler, deprecated: y = r2.defaultDeprecatedHandler } = n || {};
              this._utils = { descriptor: i, logger: u || { warn: () => {
              } }, schemas: t.recordFromArray(a, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p, this._deprecatedHandler = y, this.cleanHistory();
            }
            cleanHistory() {
              this._hasDeprecationWarned = t.createAutoChecklist();
            }
            normalize(a) {
              let n = {}, u = [a], i = () => {
                for (; u.length !== 0; ) {
                  let l = u.shift(), p = this._applyNormalization(l, n);
                  u.push(...p);
                }
              };
              i();
              for (let l of Object.keys(this._utils.schemas)) {
                let p = this._utils.schemas[l];
                if (!(l in n)) {
                  let y = t.normalizeDefaultResult(p.default(this._utils));
                  "value" in y && u.push({ [l]: y.value });
                }
              }
              i();
              for (let l of Object.keys(this._utils.schemas)) {
                let p = this._utils.schemas[l];
                l in n && (n[l] = p.postprocess(n[l], this._utils));
              }
              return n;
            }
            _applyNormalization(a, n) {
              let u = [], [i, l] = t.partition(Object.keys(a), (p) => p in this._utils.schemas);
              for (let p of i) {
                let y = this._utils.schemas[p], h = y.preprocess(a[p], this._utils), g = t.normalizeValidateResult(y.validate(h, this._utils), h);
                if (g !== true) {
                  let { value: w } = g, E = this._invalidHandler(p, w, this._utils);
                  throw typeof E == "string" ? new Error(E) : E;
                }
                let c2 = (w) => {
                  let { from: E, to: N } = w;
                  u.push(typeof N == "string" ? { [N]: E } : { [N.key]: N.value });
                }, f = (w) => {
                  let { value: E, redirectTo: N } = w, x = t.normalizeDeprecatedResult(y.deprecated(E, this._utils), h, true);
                  if (x !== false) if (x === true) this._hasDeprecationWarned(p) || this._utils.logger.warn(this._deprecatedHandler(p, N, this._utils));
                  else for (let { value: I } of x) {
                    let P = { key: p, value: I };
                    if (!this._hasDeprecationWarned(P)) {
                      let $ = typeof N == "string" ? { key: N, value: I } : N;
                      this._utils.logger.warn(this._deprecatedHandler(P, $, this._utils));
                    }
                  }
                };
                t.normalizeForwardResult(y.forward(h, this._utils), h).forEach(c2);
                let _ = t.normalizeRedirectResult(y.redirect(h, this._utils), h);
                if (_.redirect.forEach(c2), "remain" in _) {
                  let w = _.remain;
                  n[p] = p in n ? y.overlap(n[p], w, this._utils) : w, f({ value: w });
                }
                for (let { from: w, to: E } of _.redirect) f({ value: w, redirectTo: E });
              }
              for (let p of l) {
                let y = a[p], h = this._unknownHandler(p, y, this._utils);
                if (h) for (let g of Object.keys(h)) {
                  let c2 = { [g]: h[g] };
                  g in this._utils.schemas ? u.push(c2) : Object.assign(n, c2);
                }
              }
              return u;
            }
          };
          e.Normalizer = s;
        } }), Lm = te({ "node_modules/vnopts/lib/index.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = (Et(), ft(vt));
          r2.__exportStar(vm(), e), r2.__exportStar(Sm(), e), r2.__exportStar(Pm(), e), r2.__exportStar(km(), e), r2.__exportStar(Ft(), e);
        } }), Om = te({ "src/main/options-normalizer.js"(e, r2) {
          ne();
          var t = Lm(), s = lt(), a = { key: (g) => g.length === 1 ? `-${g}` : `--${g}`, value: (g) => t.apiDescriptor.value(g), pair: (g) => {
            let { key: c2, value: f } = g;
            return f === false ? `--no-${c2}` : f === true ? a.key(c2) : f === "" ? `${a.key(c2)} without an argument` : `${a.key(c2)}=${f}`;
          } }, n = (g) => {
            let { colorsModule: c2, levenshteinDistance: f } = g;
            return class extends t.ChoiceSchema {
              constructor(_) {
                let { name: w, flags: E } = _;
                super({ name: w, choices: E }), this._flags = [...E].sort();
              }
              preprocess(_, w) {
                if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
                  let E = this._flags.find((N) => f(N, _) < 3);
                  if (E) return w.logger.warn([`Unknown flag ${c2.yellow(w.descriptor.value(_))},`, `did you mean ${c2.blue(w.descriptor.value(E))}?`].join(" ")), E;
                }
                return _;
              }
              expected() {
                return "a flag";
              }
            };
          }, u;
          function i(g, c2) {
            let { logger: f = false, isCLI: F = false, passThrough: _ = false, colorsModule: w = null, levenshteinDistance: E = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N = _ ? Array.isArray(_) ? (T, m) => _.includes(T) ? { [T]: m } : void 0 : (T, m) => ({ [T]: m }) : (T, m, C) => {
              let o = C.schemas, { _: d } = o, v = Hn(o, vD);
              return t.levenUnknownHandler(T, m, Object.assign(Object.assign({}, C), {}, { schemas: v }));
            }, x = F ? a : t.apiDescriptor, I = l(c2, { isCLI: F, colorsModule: w, levenshteinDistance: E }), P = new t.Normalizer(I, { logger: f, unknown: N, descriptor: x }), $ = f !== false;
            $ && u && (P._hasDeprecationWarned = u);
            let D = P.normalize(g);
            return $ && (u = P._hasDeprecationWarned), F && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
          }
          function l(g, c2) {
            let { isCLI: f, colorsModule: F, levenshteinDistance: _ } = c2, w = [];
            f && w.push(t.AnySchema.create({ name: "_" }));
            for (let E of g) w.push(p(E, { isCLI: f, optionInfos: g, colorsModule: F, levenshteinDistance: _ })), E.alias && f && w.push(t.AliasSchema.create({ name: E.alias, sourceName: E.name }));
            return w;
          }
          function p(g, c2) {
            let { isCLI: f, optionInfos: F, colorsModule: _, levenshteinDistance: w } = c2, { name: E } = g;
            if (E === "plugin-search-dir" || E === "pluginSearchDirs") return t.AnySchema.create({ name: E, preprocess(P) {
              return P === false || (P = Array.isArray(P) ? P : [P]), P;
            }, validate(P) {
              return P === false ? true : P.every(($) => typeof $ == "string");
            }, expected() {
              return "false or paths to plugin search dir";
            } });
            let N = { name: E }, x, I = {};
            switch (g.type) {
              case "int":
                x = t.IntegerSchema, f && (N.preprocess = Number);
                break;
              case "string":
                x = t.StringSchema;
                break;
              case "choice":
                x = t.ChoiceSchema, N.choices = g.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g.name, value: P.redirect } } }) : P);
                break;
              case "boolean":
                x = t.BooleanSchema;
                break;
              case "flag":
                x = n({ colorsModule: _, levenshteinDistance: w }), N.flags = F.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
                break;
              case "path":
                x = t.StringSchema;
                break;
              default:
                throw new Error(`Unexpected type ${g.type}`);
            }
            if (g.exception ? N.validate = (P, $, D) => g.exception(P) || $.validate(P, D) : N.validate = (P, $, D) => P === void 0 || $.validate(P, D), g.redirect && (I.redirect = (P) => P ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (I.deprecated = true), f && !g.array) {
              let P = N.preprocess || (($) => $);
              N.preprocess = ($, D, T) => D.preprocess(P(Array.isArray($) ? s($) : $), T);
            }
            return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I), {}, { valueSchema: x.create(N) })) : x.create(Object.assign(Object.assign({}, N), I));
          }
          function y(g, c2, f) {
            return i(g, c2, f);
          }
          function h(g, c2, f) {
            return i(g, c2, Object.assign({ isCLI: true }, f));
          }
          r2.exports = { normalizeApiOptions: y, normalizeCliOptions: h };
        } }), ut = te({ "src/language-js/loc.js"(e, r2) {
          ne();
          var t = Kn();
          function s(l) {
            var p, y;
            let h = l.range ? l.range[0] : l.start, g = (p = (y = l.declaration) === null || y === void 0 ? void 0 : y.decorators) !== null && p !== void 0 ? p : l.decorators;
            return t(g) ? Math.min(s(g[0]), h) : h;
          }
          function a(l) {
            return l.range ? l.range[1] : l.end;
          }
          function n(l, p) {
            let y = s(l);
            return Number.isInteger(y) && y === s(p);
          }
          function u(l, p) {
            let y = a(l);
            return Number.isInteger(y) && y === a(p);
          }
          function i(l, p) {
            return n(l, p) && u(l, p);
          }
          r2.exports = { locStart: s, locEnd: a, hasSameLocStart: n, hasSameLoc: i };
        } }), jm = te({ "src/main/load-parser.js"(e, r2) {
          ne(), r2.exports = () => {
          };
        } }), qm = te({ "scripts/build/shims/babel-highlight.cjs"(e, r2) {
          ne();
          var t = kr(), s = { shouldHighlight: () => false, getChalk: () => t };
          r2.exports = s;
        } }), Mm = te({ "node_modules/@babel/code-frame/lib/index.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
          var r2 = qm(), t = false;
          function s(l) {
            return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
          }
          var a = /\r\n|[\n\r\u2028\u2029]/;
          function n(l, p, y) {
            let h = Object.assign({ column: 0, line: -1 }, l.start), g = Object.assign({}, h, l.end), { linesAbove: c2 = 2, linesBelow: f = 3 } = y || {}, F = h.line, _ = h.column, w = g.line, E = g.column, N = Math.max(F - (c2 + 1), 0), x = Math.min(p.length, w + f);
            F === -1 && (N = 0), w === -1 && (x = p.length);
            let I = w - F, P = {};
            if (I) for (let $ = 0; $ <= I; $++) {
              let D = $ + F;
              if (!_) P[D] = true;
              else if ($ === 0) {
                let T = p[D - 1].length;
                P[D] = [_, T - _ + 1];
              } else if ($ === I) P[D] = [0, E];
              else {
                let T = p[D - $].length;
                P[D] = [0, T];
              }
            }
            else _ === E ? _ ? P[F] = [_, 0] : P[F] = true : P[F] = [_, E - _];
            return { start: N, end: x, markerLines: P };
          }
          function u(l, p) {
            let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = (y.highlightCode || y.forceColor) && (0, r2.shouldHighlight)(y), g = (0, r2.getChalk)(y), c2 = s(g), f = ($, D) => h ? $(D) : D, F = l.split(a), { start: _, end: w, markerLines: E } = n(p, F, y), N = p.start && typeof p.start.column == "number", x = String(w).length, P = (h ? (0, r2.default)(l, y) : l).split(a, w).slice(_, w).map(($, D) => {
              let T = _ + 1 + D, C = ` ${` ${T}`.slice(-x)} |`, o = E[T], d = !E[T + 1];
              if (o) {
                let v = "";
                if (Array.isArray(o)) {
                  let S = $.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
                  v = [`
 `, f(c2.gutter, C.replace(/\d/g, " ")), " ", S, f(c2.marker, "^").repeat(b)].join(""), d && y.message && (v += " " + f(c2.message, y.message));
                }
                return [f(c2.marker, ">"), f(c2.gutter, C), $.length > 0 ? ` ${$}` : "", v].join("");
              } else return ` ${f(c2.gutter, C)}${$.length > 0 ? ` ${$}` : ""}`;
            }).join(`
`);
            return y.message && !N && (P = `${" ".repeat(x + 1)}${y.message}
${P}`), h ? g.reset(P) : P;
          }
          function i(l, p, y) {
            let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t) {
              t = true;
              let c2 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (wt.emitWarning) wt.emitWarning(c2, "DeprecationWarning");
              else {
                let f = new Error(c2);
                f.name = "DeprecationWarning", console.warn(new Error(c2));
              }
            }
            return y = Math.max(y, 0), u(l, { start: { column: y, line: p } }, h);
          }
        } }), tu = te({ "src/main/parser.js"(e, r2) {
          ne();
          var { ConfigError: t } = Qt(), s = ut(); jm(); var { locStart: n, locEnd: u } = s, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
          function p(g) {
            let c2 = {};
            for (let f of g.plugins) if (f.parsers) for (let F of i(f.parsers)) Object.defineProperty(c2, F, l(f.parsers, F));
            return c2;
          }
          function y(g) {
            let c2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p(g);
            if (typeof g.parser == "function") return { parse: g.parser, astFormat: "estree", locStart: n, locEnd: u };
            if (typeof g.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(c2, g.parser)) return c2[g.parser];
              throw new t(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`);
            }
          }
          function h(g, c2) {
            let f = p(c2), F = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((w) => [w, { enumerable: true, get() {
              return f[w].parse;
            } }]))), _ = y(c2, f);
            try {
              return _.preprocess && (g = _.preprocess(g, c2)), { text: g, ast: _.parse(g, F, c2) };
            } catch (w) {
              let { loc: E } = w;
              if (E) {
                let { codeFrameColumns: N } = Mm();
                throw w.codeFrame = N(g, E, { highlightCode: true }), w.message += `
` + w.codeFrame, w;
              }
              throw w;
            }
          }
          r2.exports = { parse: h, resolveParser: y };
        } }), uo = te({ "src/main/options.js"(e, r2) {
          ne();
          var t = ZD(), { UndefinedParserError: s } = Qt(), { getSupportInfo: a } = Xn(), n = Om(), { resolveParser: u } = tu(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
          function l(h) {
            let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c2 = Object.assign({}, h), f = a({ plugins: h.plugins, showUnreleased: true, showDeprecated: true }).options, F = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((x) => x.default !== void 0).map((x) => [x.name, x.default])));
            if (!c2.parser) {
              if (!c2.filepath) (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c2.parser = "babel";
              else if (c2.parser = y(c2.filepath, c2.plugins), !c2.parser) throw new s(`No parser could be inferred for file: ${c2.filepath}`);
            }
            let _ = u(n.normalizeApiOptions(c2, [f.find((x) => x.name === "parser")], { passThrough: true, logger: false }));
            c2.astFormat = _.astFormat, c2.locEnd = _.locEnd, c2.locStart = _.locStart;
            let w = p(c2);
            c2.printer = w.printers[c2.astFormat];
            let E = Object.fromEntries(f.filter((x) => x.pluginDefaults && x.pluginDefaults[w.name] !== void 0).map((x) => [x.name, x.pluginDefaults[w.name]])), N = Object.assign(Object.assign({}, F), E);
            for (let [x, I] of Object.entries(N)) (c2[x] === null || c2[x] === void 0) && (c2[x] = I);
            return c2.parser === "json" && (c2.trailingComma = "none"), n.normalizeApiOptions(c2, f, Object.assign({ passThrough: Object.keys(i) }, g));
          }
          function p(h) {
            let { astFormat: g } = h;
            if (!g) throw new Error("getPlugin() requires astFormat to be set");
            let c2 = h.plugins.find((f) => f.printers && f.printers[g]);
            if (!c2) throw new Error(`Couldn't find plugin for AST format "${g}"`);
            return c2;
          }
          function y(h, g) {
            let c2 = t.basename(h).toLowerCase(), F = a({ plugins: g }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w) => c2.endsWith(w)) || _.filenames && _.filenames.some((w) => w.toLowerCase() === c2));
            return F && F.parsers[0];
          }
          r2.exports = { normalize: l, hiddenDefaults: i, inferParser: y };
        } }), Rm = te({ "src/main/massage-ast.js"(e, r2) {
          ne();
          function t(s, a, n) {
            if (Array.isArray(s)) return s.map((p) => t(p, a, n)).filter(Boolean);
            if (!s || typeof s != "object") return s;
            let u = a.printer.massageAstNode, i;
            u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
            let l = {};
            for (let [p, y] of Object.entries(s)) !i.has(p) && typeof y != "function" && (l[p] = t(y, a, s));
            if (u) {
              let p = u(s, l, n);
              if (p === null) return;
              if (p) return p;
            }
            return l;
          }
          r2.exports = t;
        } }), Zt = te({ "scripts/build/shims/assert.cjs"(e, r2) {
          ne();
          var t = () => {
          };
          t.ok = t, t.strictEqual = t, r2.exports = t;
        } }), et = te({ "src/main/comments.js"(e, r2) {
          ne();
          var t = Zt(), { builders: { line: s, hardline: a, breakParent: n, indent: u, lineSuffix: i, join: l, cursor: p } } = qe(), { hasNewline: y, skipNewline: h, skipSpaces: g, isPreviousLineEmpty: c2, addLeadingComment: f, addDanglingComment: F, addTrailingComment: _ } = Ue(), w = /* @__PURE__ */ new WeakMap();
          function E(k, M, R) {
            if (!k) return;
            let { printer: q, locStart: J, locEnd: L } = M;
            if (R) {
              if (q.canAttachComment && q.canAttachComment(k)) {
                let V;
                for (V = R.length - 1; V >= 0 && !(J(R[V]) <= J(k) && L(R[V]) <= L(k)); --V) ;
                R.splice(V + 1, 0, k);
                return;
              }
            } else if (w.has(k)) return w.get(k);
            let Q = q.getCommentChildNodes && q.getCommentChildNodes(k, M) || typeof k == "object" && Object.entries(k).filter((V) => {
              let [j] = V;
              return j !== "enclosingNode" && j !== "precedingNode" && j !== "followingNode" && j !== "tokens" && j !== "comments" && j !== "parent";
            }).map((V) => {
              let [, j] = V;
              return j;
            });
            if (Q) {
              R || (R = [], w.set(k, R));
              for (let V of Q) E(V, M, R);
              return R;
            }
          }
          function N(k, M, R, q) {
            let { locStart: J, locEnd: L } = R, Q = J(M), V = L(M), j = E(k, R), Y, ie, ee = 0, ce = j.length;
            for (; ee < ce; ) {
              let W = ee + ce >> 1, K = j[W], de = J(K), ue = L(K);
              if (de <= Q && V <= ue) return N(K, M, R, K);
              if (ue <= Q) {
                Y = K, ee = W + 1;
                continue;
              }
              if (V <= de) {
                ie = K, ce = W;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if (q && q.type === "TemplateLiteral") {
              let { quasis: W } = q, K = C(W, M, R);
              Y && C(W, Y, R) !== K && (Y = null), ie && C(W, ie, R) !== K && (ie = null);
            }
            return { enclosingNode: q, precedingNode: Y, followingNode: ie };
          }
          var x = () => false;
          function I(k, M, R, q) {
            if (!Array.isArray(k)) return;
            let J = [], { locStart: L, locEnd: Q, printer: { handleComments: V = {} } } = q, { avoidAstMutation: j, ownLine: Y = x, endOfLine: ie = x, remaining: ee = x } = V, ce = k.map((W, K) => Object.assign(Object.assign({}, N(M, W, q)), {}, { comment: W, text: R, options: q, ast: M, isLastComment: k.length - 1 === K }));
            for (let [W, K] of ce.entries()) {
              let { comment: de, precedingNode: ue, enclosingNode: Fe, followingNode: z, text: U, options: Z, ast: se, isLastComment: fe } = K;
              if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                if (L(de) - L(se) <= 0) {
                  f(se, de);
                  continue;
                }
                if (Q(de) - Q(se) >= 0) {
                  _(se, de);
                  continue;
                }
              }
              let ge;
              if (j ? ge = [K] : (de.enclosingNode = Fe, de.precedingNode = ue, de.followingNode = z, ge = [de, U, Z, se, fe]), $(U, Z, ce, W)) de.placement = "ownLine", Y(...ge) || (z ? f(z, de) : ue ? _(ue, de) : F(Fe || se, de));
              else if (D(U, Z, ce, W)) de.placement = "endOfLine", ie(...ge) || (ue ? _(ue, de) : z ? f(z, de) : F(Fe || se, de));
              else if (de.placement = "remaining", !ee(...ge)) if (ue && z) {
                let he = J.length;
                he > 0 && J[he - 1].followingNode !== z && T(J, U, Z), J.push(K);
              } else ue ? _(ue, de) : z ? f(z, de) : F(Fe || se, de);
            }
            if (T(J, R, q), !j) for (let W of k) delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
          }
          var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
          function $(k, M, R, q) {
            let { comment: J, precedingNode: L } = R[q], { locStart: Q, locEnd: V } = M, j = Q(J);
            if (L) for (let Y = q - 1; Y >= 0; Y--) {
              let { comment: ie, precedingNode: ee } = R[Y];
              if (ee !== L || !P(k.slice(V(ie), j))) break;
              j = Q(ie);
            }
            return y(k, j, { backwards: true });
          }
          function D(k, M, R, q) {
            let { comment: J, followingNode: L } = R[q], { locStart: Q, locEnd: V } = M, j = V(J);
            if (L) for (let Y = q + 1; Y < R.length; Y++) {
              let { comment: ie, followingNode: ee } = R[Y];
              if (ee !== L || !P(k.slice(j, Q(ie)))) break;
              j = V(ie);
            }
            return y(k, j);
          }
          function T(k, M, R) {
            let q = k.length;
            if (q === 0) return;
            let { precedingNode: J, followingNode: L, enclosingNode: Q } = k[0], V = R.printer.getGapRegex && R.printer.getGapRegex(Q) || /^[\s(]*$/, j = R.locStart(L), Y;
            for (Y = q; Y > 0; --Y) {
              let { comment: ie, precedingNode: ee, followingNode: ce } = k[Y - 1];
              t.strictEqual(ee, J), t.strictEqual(ce, L);
              let W = M.slice(R.locEnd(ie), j);
              if (V.test(W)) j = R.locStart(ie);
              else break;
            }
            for (let [ie, { comment: ee }] of k.entries()) ie < Y ? _(J, ee) : f(L, ee);
            for (let ie of [J, L]) ie.comments && ie.comments.length > 1 && ie.comments.sort((ee, ce) => R.locStart(ee) - R.locStart(ce));
            k.length = 0;
          }
          function m(k, M) {
            let R = k.getValue();
            return R.printed = true, M.printer.printComment(k, M);
          }
          function C(k, M, R) {
            let q = R.locStart(M) - 1;
            for (let J = 1; J < k.length; ++J) if (q < R.locStart(k[J])) return J - 1;
            return 0;
          }
          function o(k, M) {
            let R = k.getValue(), q = [m(k, M)], { printer: J, originalText: L, locStart: Q, locEnd: V } = M;
            if (J.isBlockComment && J.isBlockComment(R)) {
              let ie = y(L, V(R)) ? y(L, Q(R), { backwards: true }) ? a : s : " ";
              q.push(ie);
            } else q.push(a);
            let Y = h(L, g(L, V(R)));
            return Y !== false && y(L, Y) && q.push(a), q;
          }
          function d(k, M) {
            let R = k.getValue(), q = m(k, M), { printer: J, originalText: L, locStart: Q } = M, V = J.isBlockComment && J.isBlockComment(R);
            if (y(L, Q(R), { backwards: true })) {
              let Y = c2(L, R, Q);
              return i([a, Y ? a : "", q]);
            }
            let j = [" ", q];
            return V || (j = [i(j), n]), j;
          }
          function v(k, M, R, q) {
            let J = [], L = k.getValue();
            return !L || !L.comments || (k.each(() => {
              let Q = k.getValue();
              !Q.leading && !Q.trailing && (!q || q(Q)) && J.push(m(k, M));
            }, "comments"), J.length === 0) ? "" : R ? l(a, J) : u([a, l(a, J)]);
          }
          function S(k, M, R) {
            let q = k.getValue();
            if (!q) return {};
            let J = q.comments || [];
            R && (J = J.filter((j) => !R.has(j)));
            let L = q === M.cursorNode;
            if (J.length === 0) {
              let j = L ? p : "";
              return { leading: j, trailing: j };
            }
            let Q = [], V = [];
            return k.each(() => {
              let j = k.getValue();
              if (R && R.has(j)) return;
              let { leading: Y, trailing: ie } = j;
              Y ? Q.push(o(k, M)) : ie && V.push(d(k, M));
            }, "comments"), L && (Q.unshift(p), V.push(p)), { leading: Q, trailing: V };
          }
          function b(k, M, R, q) {
            let { leading: J, trailing: L } = S(k, R, q);
            return !J && !L ? M : [J, M, L];
          }
          function B(k) {
            if (k) for (let M of k) {
              if (!M.printed) throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
              delete M.printed;
            }
          }
          r2.exports = { attach: I, printComments: b, printCommentsSeparately: S, printDanglingComments: v, getSortedChildNodes: E, ensureAllCommentsPrinted: B };
        } }), $m = te({ "src/common/ast-path.js"(e, r2) {
          ne();
          var t = lt();
          function s(u, i) {
            let l = a(u.stack, i);
            return l === -1 ? null : u.stack[l];
          }
          function a(u, i) {
            for (let l = u.length - 1; l >= 0; l -= 2) {
              let p = u[l];
              if (p && !Array.isArray(p) && --i < 0) return l;
            }
            return -1;
          }
          var n = class {
            constructor(u) {
              this.stack = [u];
            }
            getName() {
              let { stack: u } = this, { length: i } = u;
              return i > 1 ? u[i - 2] : null;
            }
            getValue() {
              return t(this.stack);
            }
            getNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u);
            }
            getParentNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u + 1);
            }
            call(u) {
              let { stack: i } = this, { length: l } = i, p = t(i);
              for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++) h[g - 1] = arguments[g];
              for (let f of h) p = p[f], i.push(f, p);
              let c2 = u(this);
              return i.length = l, c2;
            }
            callParent(u) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a(this.stack, i + 1), p = this.stack.splice(l + 1), y = u(this);
              return this.stack.push(...p), y;
            }
            each(u) {
              let { stack: i } = this, { length: l } = i, p = t(i);
              for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++) h[g - 1] = arguments[g];
              for (let c2 of h) p = p[c2], i.push(c2, p);
              for (let c2 = 0; c2 < p.length; ++c2) i.push(c2, p[c2]), u(this, c2, p), i.length -= 2;
              i.length = l;
            }
            map(u) {
              let i = [];
              for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++) p[y - 1] = arguments[y];
              return this.each((h, g, c2) => {
                i[g] = u(h, g, c2);
              }, ...p), i;
            }
            try(u) {
              let { stack: i } = this, l = [...i];
              try {
                return u();
              } finally {
                i.length = 0, i.push(...l);
              }
            }
            match() {
              let u = this.stack.length - 1, i = null, l = this.stack[u--];
              for (var p = arguments.length, y = new Array(p), h = 0; h < p; h++) y[h] = arguments[h];
              for (let g of y) {
                if (l === void 0) return false;
                let c2 = null;
                if (typeof i == "number" && (c2 = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, c2)) return false;
                i = this.stack[u--], l = this.stack[u--];
              }
              return true;
            }
            findAncestor(u) {
              let i = this.stack.length - 1, l = null, p = this.stack[i--];
              for (; p; ) {
                let y = null;
                if (typeof l == "number" && (y = l, l = this.stack[i--], p = this.stack[i--]), l !== null && u(p, l, y)) return p;
                l = this.stack[i--], p = this.stack[i--];
              }
            }
          };
          r2.exports = n;
        } }), Vm = te({ "src/main/multiparser.js"(e, r2) {
          ne();
          var { utils: { stripTrailingHardline: t } } = qe(), { normalize: s } = uo(), a = et();
          function n(i, l, p, y) {
            if (p.printer.embed && p.embeddedLanguageFormatting === "auto") return p.printer.embed(i, l, (h, g, c2) => u(h, g, p, y, c2), p);
          }
          function u(i, l, p, y) {
            let { stripTrailingHardline: h = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s(Object.assign(Object.assign(Object.assign({}, p), l), {}, { parentParser: p.parser, originalText: i }), { passThrough: true }), c2 = tu().parse(i, g), { ast: f } = c2;
            i = c2.text;
            let F = f.comments;
            delete f.comments, a.attach(F, f, i, g), g[Symbol.for("comments")] = F || [], g[Symbol.for("tokens")] = f.tokens || [];
            let _ = y(f, g);
            return a.ensureAllCommentsPrinted(F), h ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t(_) : _;
          }
          r2.exports = { printSubtree: n };
        } }), Wm = te({ "src/main/ast-to-doc.js"(e, r2) {
          ne();
          var t = $m(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: n } } = qe(), { printComments: u } = et(), i = Vm();
          function l(h, g) {
            let c2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g;
            f.preprocess && (h = f.preprocess(h, g));
            let F = /* @__PURE__ */ new Map(), _ = new t(h), w = E();
            return c2 > 0 && (w = a([s, w], c2, g.tabWidth)), n(w), w;
            function E(x, I) {
              return x === void 0 || x === _ ? N(I) : Array.isArray(x) ? _.call(() => N(I), ...x) : _.call(() => N(I), x);
            }
            function N(x) {
              let I = _.getValue(), P = I && typeof I == "object" && x === void 0;
              if (P && F.has(I)) return F.get(I);
              let $ = y(_, g, E, x);
              return P && F.set(I, $), $;
            }
          }
          function p(h, g) {
            let { originalText: c2, [Symbol.for("comments")]: f, locStart: F, locEnd: _ } = g, w = F(h), E = _(h), N = /* @__PURE__ */ new Set();
            for (let x of f) F(x) >= w && _(x) <= E && (x.printed = true, N.add(x));
            return { doc: c2.slice(w, E), printedComments: N };
          }
          function y(h, g, c2, f) {
            let F = h.getValue(), { printer: _ } = g, w, E;
            if (_.hasPrettierIgnore && _.hasPrettierIgnore(h)) ({ doc: w, printedComments: E } = p(F, g));
            else {
              if (F) try {
                w = i.printSubtree(h, c2, g, l);
              } catch (N) {
                if (globalThis.PRETTIER_DEBUG) throw N;
              }
              w || (w = _.print(h, g, c2, f));
            }
            return (!_.willPrintOwnComments || !_.willPrintOwnComments(h, g)) && (w = u(h, w, g, E)), w;
          }
          r2.exports = l;
        } }), Hm = te({ "src/main/range-util.js"(e, r2) {
          ne();
          var t = Zt(), s = et(), a = (f) => {
            let { parser: F } = f;
            return F === "json" || F === "json5" || F === "json-stringify";
          };
          function n(f, F) {
            let _ = [f.node, ...f.parentNodes], w = /* @__PURE__ */ new Set([F.node, ...F.parentNodes]);
            return _.find((E) => y.has(E.type) && w.has(E));
          }
          function u(f) {
            let F = f.length - 1;
            for (; ; ) {
              let _ = f[F];
              if (_ && (_.type === "Program" || _.type === "File")) F--;
              else break;
            }
            return f.slice(0, F + 1);
          }
          function i(f, F, _) {
            let { locStart: w, locEnd: E } = _, N = f.node, x = F.node;
            if (N === x) return { startNode: N, endNode: x };
            let I = w(f.node);
            for (let $ of u(F.parentNodes)) if (w($) >= I) x = $;
            else break;
            let P = E(F.node);
            for (let $ of u(f.parentNodes)) {
              if (E($) <= P) N = $;
              else break;
              if (N === x) break;
            }
            return { startNode: N, endNode: x };
          }
          function l(f, F, _, w) {
            let E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N = arguments.length > 5 ? arguments[5] : void 0, { locStart: x, locEnd: I } = _, P = x(f), $ = I(f);
            if (!(F > $ || F < P || N === "rangeEnd" && F === P || N === "rangeStart" && F === $)) {
              for (let D of s.getSortedChildNodes(f, _)) {
                let T = l(D, F, _, w, [f, ...E], N);
                if (T) return T;
              }
              if (!w || w(f, E[0])) return { node: f, parentNodes: E };
            }
          }
          function p(f, F) {
            return F !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
          }
          var y = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function g(f, F, _) {
            if (!F) return false;
            switch (f.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return p(F.type, _ && _.type);
              case "json":
              case "json5":
              case "json-stringify":
                return y.has(F.type);
              case "graphql":
                return h.has(F.kind);
              case "vue":
                return F.tag !== "root";
            }
            return false;
          }
          function c2(f, F, _) {
            let { rangeStart: w, rangeEnd: E, locStart: N, locEnd: x } = F;
            t.ok(E > w);
            let I = f.slice(w, E).search(/\S/), P = I === -1;
            if (!P) for (w += I; E > w && !/\S/.test(f[E - 1]); --E) ;
            let $ = l(_, w, F, (C, o) => g(F, C, o), [], "rangeStart"), D = P ? $ : l(_, E, F, (C) => g(F, C), [], "rangeEnd");
            if (!$ || !D) return { rangeStart: 0, rangeEnd: 0 };
            let T, m;
            if (a(F)) {
              let C = n($, D);
              T = C, m = C;
            } else ({ startNode: T, endNode: m } = i($, D, F));
            return { rangeStart: Math.min(N(T), N(m)), rangeEnd: Math.max(x(T), x(m)) };
          }
          r2.exports = { calculateRange: c2, findNodeAtOffset: l };
        } }), Gm = te({ "src/main/core.js"(e, r2) {
          ne();
          var { diffArrays: t } = BD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = qe(), { getAlignmentSize: n } = Ue(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: p } = Jn(), y = uo().normalize, h = Rm(), g = et(), c2 = tu(), f = Wm(), F = Hm(), _ = "\uFEFF", w = Symbol("cursor");
          function E(m, C, o) {
            let d = C.comments;
            return d && (delete C.comments, g.attach(d, C, m, o)), o[Symbol.for("comments")] = d || [], o[Symbol.for("tokens")] = C.tokens || [], o.originalText = m, d;
          }
          function N(m, C) {
            let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!m || m.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
            let { ast: d, text: v } = c2.parse(m, C);
            if (C.cursorOffset >= 0) {
              let k = F.findNodeAtOffset(d, C.cursorOffset, C);
              k && k.node && (C.cursorNode = k.node);
            }
            let S = E(v, d, C), b = f(d, C, o), B = s(b, C);
            if (g.ensureAllCommentsPrinted(S), o > 0) {
              let k = B.formatted.trim();
              B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);
            }
            if (C.cursorOffset >= 0) {
              let k, M, R, q, J;
              if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M = v.slice(k, C.locEnd(C.cursorNode)), R = C.cursorOffset - k, q = B.cursorNodeStart, J = B.cursorNodeText) : (k = 0, M = v, R = C.cursorOffset, q = 0, J = B.formatted), M === J) return { formatted: B.formatted, cursorOffset: q + R, comments: S };
              let L = [...M];
              L.splice(R, 0, w);
              let Q = [...J], V = t(L, Q), j = q;
              for (let Y of V) if (Y.removed) {
                if (Y.value.includes(w)) break;
              } else j += Y.count;
              return { formatted: B.formatted, cursorOffset: j, comments: S };
            }
            return { formatted: B.formatted, cursorOffset: -1, comments: S };
          }
          function x(m, C) {
            let { ast: o, text: d } = c2.parse(m, C), { rangeStart: v, rangeEnd: S } = F.calculateRange(d, C, o), b = d.slice(v, S), B = Math.min(v, d.lastIndexOf(`
`, v) + 1), k = d.slice(B, v).match(/^\s*/)[0], M = n(k, C.tabWidth), R = N(b, Object.assign(Object.assign({}, C), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C.cursorOffset > v && C.cursorOffset <= S ? C.cursorOffset - v : -1, endOfLine: "lf" }), M), q = R.formatted.trimEnd(), { cursorOffset: J } = C;
            J > S ? J += q.length - b.length : R.cursorOffset >= 0 && (J = R.cursorOffset + v);
            let L = d.slice(0, v) + q + d.slice(S);
            if (C.endOfLine !== "lf") {
              let Q = i(C.endOfLine);
              J >= 0 && Q === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Q);
            }
            return { formatted: L, cursorOffset: J, comments: R.comments };
          }
          function I(m, C, o) {
            return typeof C != "number" || Number.isNaN(C) || C < 0 || C > m.length ? o : C;
          }
          function P(m, C) {
            let { cursorOffset: o, rangeStart: d, rangeEnd: v } = C;
            return o = I(m, o, -1), d = I(m, d, 0), v = I(m, v, m.length), Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v });
          }
          function $(m, C) {
            let { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S } = P(m, C), b = m.charAt(0) === _;
            if (b && (m = m.slice(1), o--, d--, v--), S === "auto" && (S = u(m)), m.includes("\r")) {
              let B = (k) => l(m.slice(0, Math.max(k, 0)), `\r
`);
              o -= B(o), d -= B(d), v -= B(v), m = p(m);
            }
            return { hasBOM: b, text: m, options: P(m, Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S })) };
          }
          function D(m, C) {
            let o = c2.resolveParser(C);
            return !o.hasPragma || o.hasPragma(m);
          }
          function T(m, C) {
            let { hasBOM: o, text: d, options: v } = $(m, y(C));
            if (v.rangeStart >= v.rangeEnd && d !== "" || v.requirePragma && !D(d, v)) return { formatted: m, cursorOffset: C.cursorOffset, comments: [] };
            let S;
            return v.rangeStart > 0 || v.rangeEnd < d.length ? S = x(d, v) : (!v.requirePragma && v.insertPragma && v.printer.insertPragma && !D(d, v) && (d = v.printer.insertPragma(d)), S = N(d, v)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
          }
          r2.exports = { formatWithCursor: T, parse(m, C, o) {
            let { text: d, options: v } = $(m, y(C)), S = c2.parse(d, v);
            return o && (S.ast = h(S.ast, v)), S;
          }, formatAST(m, C) {
            C = y(C);
            let o = f(m, C);
            return s(o, C);
          }, formatDoc(m, C) {
            return T(a(m), Object.assign(Object.assign({}, C), {}, { parser: "__js_expression" })).formatted;
          }, printToDoc(m, C) {
            C = y(C);
            let { ast: o, text: d } = c2.parse(m, C);
            return E(d, o, C), f(o, C);
          }, printDocToString(m, C) {
            return s(m, y(C));
          } };
        } }), Um = te({ "src/common/util-shared.js"(e, r2) {
          ne();
          var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g, skipTrailingComment: c2, hasNewline: f, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D } = Ue();
          r2.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g, skipTrailingComment: c2, hasNewline: f, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D };
        } }), _t = te({ "src/utils/create-language.js"(e, r2) {
          ne(), r2.exports = function(t, s) {
            let { languageId: a } = t, n = Hn(t, CD);
            return Object.assign(Object.assign({ linguistLanguageId: a }, n), s(t));
          };
        } }), Jm = te({ "node_modules/esutils/lib/ast.js"(e, r2) {
          ne(), (function() {
            function t(l) {
              if (l == null) return false;
              switch (l.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            }
            function s(l) {
              if (l == null) return false;
              switch (l.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            }
            function a(l) {
              if (l == null) return false;
              switch (l.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }
              return false;
            }
            function n(l) {
              return a(l) || l != null && l.type === "FunctionDeclaration";
            }
            function u(l) {
              switch (l.type) {
                case "IfStatement":
                  return l.alternate != null ? l.alternate : l.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return l.body;
              }
              return null;
            }
            function i(l) {
              var p;
              if (l.type !== "IfStatement" || l.alternate == null) return false;
              p = l.consequent;
              do {
                if (p.type === "IfStatement" && p.alternate == null) return true;
                p = u(p);
              } while (p);
              return false;
            }
            r2.exports = { isExpression: t, isStatement: a, isIterationStatement: s, isSourceElement: n, isProblematicIfStatement: i, trailingStatement: u };
          })();
        } }), so = te({ "node_modules/esutils/lib/code.js"(e, r2) {
          ne(), (function() {
            var t, s, a, n, u, i;
            s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            function l(E) {
              return 48 <= E && E <= 57;
            }
            function p(E) {
              return 48 <= E && E <= 57 || 97 <= E && E <= 102 || 65 <= E && E <= 70;
            }
            function y(E) {
              return E >= 48 && E <= 55;
            }
            a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function h(E) {
              return E === 32 || E === 9 || E === 11 || E === 12 || E === 160 || E >= 5760 && a.indexOf(E) >= 0;
            }
            function g(E) {
              return E === 10 || E === 13 || E === 8232 || E === 8233;
            }
            function c2(E) {
              if (E <= 65535) return String.fromCharCode(E);
              var N = String.fromCharCode(Math.floor((E - 65536) / 1024) + 55296), x = String.fromCharCode((E - 65536) % 1024 + 56320);
              return N + x;
            }
            for (n = new Array(128), i = 0; i < 128; ++i) n[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
            for (u = new Array(128), i = 0; i < 128; ++i) u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
            function f(E) {
              return E < 128 ? n[E] : s.NonAsciiIdentifierStart.test(c2(E));
            }
            function F(E) {
              return E < 128 ? u[E] : s.NonAsciiIdentifierPart.test(c2(E));
            }
            function _(E) {
              return E < 128 ? n[E] : t.NonAsciiIdentifierStart.test(c2(E));
            }
            function w(E) {
              return E < 128 ? u[E] : t.NonAsciiIdentifierPart.test(c2(E));
            }
            r2.exports = { isDecimalDigit: l, isHexDigit: p, isOctalDigit: y, isWhiteSpace: h, isLineTerminator: g, isIdentifierStartES5: f, isIdentifierPartES5: F, isIdentifierStartES6: _, isIdentifierPartES6: w };
          })();
        } }), zm = te({ "node_modules/esutils/lib/keyword.js"(e, r2) {
          ne(), (function() {
            var t = so();
            function s(f) {
              switch (f) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }
            function a(f, F) {
              return !F && f === "yield" ? false : n(f, F);
            }
            function n(f, F) {
              if (F && s(f)) return true;
              switch (f.length) {
                case 2:
                  return f === "if" || f === "in" || f === "do";
                case 3:
                  return f === "var" || f === "for" || f === "new" || f === "try";
                case 4:
                  return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                case 5:
                  return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                case 6:
                  return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                case 7:
                  return f === "default" || f === "finally" || f === "extends";
                case 8:
                  return f === "function" || f === "continue" || f === "debugger";
                case 10:
                  return f === "instanceof";
                default:
                  return false;
              }
            }
            function u(f, F) {
              return f === "null" || f === "true" || f === "false" || a(f, F);
            }
            function i(f, F) {
              return f === "null" || f === "true" || f === "false" || n(f, F);
            }
            function l(f) {
              return f === "eval" || f === "arguments";
            }
            function p(f) {
              var F, _, w;
              if (f.length === 0 || (w = f.charCodeAt(0), !t.isIdentifierStartES5(w))) return false;
              for (F = 1, _ = f.length; F < _; ++F) if (w = f.charCodeAt(F), !t.isIdentifierPartES5(w)) return false;
              return true;
            }
            function y(f, F) {
              return (f - 55296) * 1024 + (F - 56320) + 65536;
            }
            function h(f) {
              var F, _, w, E, N;
              if (f.length === 0) return false;
              for (N = t.isIdentifierStartES6, F = 0, _ = f.length; F < _; ++F) {
                if (w = f.charCodeAt(F), 55296 <= w && w <= 56319) {
                  if (++F, F >= _ || (E = f.charCodeAt(F), !(56320 <= E && E <= 57343))) return false;
                  w = y(w, E);
                }
                if (!N(w)) return false;
                N = t.isIdentifierPartES6;
              }
              return true;
            }
            function g(f, F) {
              return p(f) && !u(f, F);
            }
            function c2(f, F) {
              return h(f) && !i(f, F);
            }
            r2.exports = { isKeywordES5: a, isKeywordES6: n, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: p, isIdentifierNameES6: h, isIdentifierES5: g, isIdentifierES6: c2 };
          })();
        } }), Xm = te({ "node_modules/esutils/lib/utils.js"(e) {
          ne(), (function() {
            e.ast = Jm(), e.code = so(), e.keyword = zm();
          })();
        } }), Pt = te({ "src/language-js/utils/is-block-comment.js"(e, r2) {
          ne();
          var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t.has(a == null ? void 0 : a.type);
          r2.exports = s;
        } }), Km = te({ "src/language-js/utils/is-node-matches.js"(e, r2) {
          ne();
          function t(a, n) {
            let u = n.split(".");
            for (let i = u.length - 1; i >= 0; i--) {
              let l = u[i];
              if (i === 0) return a.type === "Identifier" && a.name === l;
              if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== l) return false;
              a = a.object;
            }
          }
          function s(a, n) {
            return n.some((u) => t(a, u));
          }
          r2.exports = s;
        } }), Ke = te({ "src/language-js/utils/index.js"(e, r2) {
          ne();
          var t = Xm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: n, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ue(), { locStart: p, locEnd: y, hasSameLocStart: h } = ut(), g = Pt(), c2 = Km(), f = "(?:(?=.)\\s)", F = new RegExp(`^${f}*:`), _ = new RegExp(`^${f}*::`);
          function w(O) {
            var me, _e;
            return ((me = O.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g((_e = O.trailingComments) === null || _e === void 0 ? void 0 : _e[0]) && F.test(O.trailingComments[0].value);
          }
          function E(O) {
            let me = O == null ? void 0 : O[0];
            return g(me) && _.test(me.value);
          }
          function N(O, me) {
            if (!O || typeof O != "object") return false;
            if (Array.isArray(O)) return O.some((He) => N(He, me));
            let _e = me(O);
            return typeof _e == "boolean" ? _e : Object.values(O).some((He) => N(He, me));
          }
          function x(O) {
            return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || de(O) || ue(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || st(O) || O.type === "TSNonNullExpression";
          }
          function I(O) {
            var me, _e, He, Ge, it, Qe;
            return O.expressions ? O.expressions[0] : (me = (_e = (He = (Ge = (it = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it !== void 0 ? it : O.callee) !== null && Ge !== void 0 ? Ge : O.object) !== null && He !== void 0 ? He : O.tag) !== null && _e !== void 0 ? _e : O.argument) !== null && me !== void 0 ? me : O.expression;
          }
          function P(O, me) {
            if (me.expressions) return ["expressions", 0];
            if (me.left) return ["left"];
            if (me.test) return ["test"];
            if (me.object) return ["object"];
            if (me.callee) return ["callee"];
            if (me.tag) return ["tag"];
            if (me.argument) return ["argument"];
            if (me.expression) return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          function $(O) {
            return O = new Set(O), (me) => O.has(me == null ? void 0 : me.type);
          }
          var D = $(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function m(O) {
            let me = O.getParentNode();
            return O.getName() === "declaration" && T(me) ? me : null;
          }
          var C = $(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
          function o(O) {
            return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
          }
          function d(O) {
            return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && o(O.argument);
          }
          function v(O) {
            return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
          }
          var S = $(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $(["FunctionExpression", "ArrowFunctionExpression"]);
          function B(O) {
            return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
          }
          function k(O) {
            return de(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
          }
          var M = $(["JSXElement", "JSXFragment"]);
          function R(O, me) {
            if (O.parentParser !== "markdown" && O.parentParser !== "mdx") return false;
            let _e = me.getNode();
            if (!_e.expression || !M(_e.expression)) return false;
            let He = me.getParentNode();
            return He.type === "Program" && He.body.length === 1;
          }
          function q(O) {
            return O.kind === "get" || O.kind === "set";
          }
          function J(O) {
            return q(O) || h(O, O.value);
          }
          function L(O) {
            return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !J(O);
          }
          function Q(O) {
            return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !h(O, O.typeAnnotation);
          }
          var V = $(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function j(O) {
            return ue(O) || O.type === "BindExpression" && Boolean(O.object);
          }
          var Y = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function ie(O) {
            return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Y.has(O.type)) : false;
          }
          function ee(O) {
            let me = /^(?:before|after)(?:Each|All)$/;
            return O.callee.type === "Identifier" && me.test(O.callee.name) && O.arguments.length === 1;
          }
          var ce = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
          function W(O) {
            return c2(O, ce);
          }
          function K(O, me) {
            if (O.type !== "CallExpression") return false;
            if (O.arguments.length === 1) {
              if (k(O) && me && K(me)) return b(O.arguments[0]);
              if (ee(O)) return k(O.arguments[0]);
            } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || v(O.arguments[0])) && W(O.callee)) return O.arguments[2] && !o(O.arguments[2]) ? false : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve(O.arguments[1]).length <= 1) || k(O.arguments[1]);
            return false;
          }
          var de = $(["CallExpression", "OptionalCallExpression"]), ue = $(["MemberExpression", "OptionalMemberExpression"]);
          function Fe(O) {
            let me = "expressions";
            O.type === "TSTemplateLiteralType" && (me = "types");
            let _e = O[me];
            return _e.length === 0 ? false : _e.every((He) => {
              if (Me(He)) return false;
              if (He.type === "Identifier" || He.type === "ThisExpression") return true;
              if (ue(He)) {
                let Ge = He;
                for (; ue(Ge); ) if (Ge.property.type !== "Identifier" && Ge.property.type !== "Literal" && Ge.property.type !== "StringLiteral" && Ge.property.type !== "NumericLiteral" || (Ge = Ge.object, Me(Ge))) return false;
                return Ge.type === "Identifier" || Ge.type === "ThisExpression";
              }
              return false;
            });
          }
          function z(O, me) {
            return O === "+" || O === "-" ? O + me : me;
          }
          function U(O, me) {
            let _e = p(me), He = n(O, y(me));
            return He !== false && O.slice(_e, _e + 2) === "/*" && O.slice(He, He + 2) === "*/";
          }
          function Z(O, me) {
            return M(me) ? Oe(me) : Me(me, Te.Leading, (_e) => a(O, y(_e)));
          }
          function se(O, me) {
            return me.parser !== "json" && v(O.key) && oe(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(me.parser === "babel-ts" && O.type === "ClassProperty" || me.parser === "typescript" && O.type === "PropertyDefinition") || fe(O.key.value) && String(Number(O.key.value)) === O.key.value && (me.parser === "babel" || me.parser === "acorn" || me.parser === "espree" || me.parser === "meriyah" || me.parser === "__babel_estree"));
          }
          function fe(O) {
            return /^(?:\d+|\d+\.\d+)$/.test(O);
          }
          function ge(O, me) {
            let _e = /^[fx]?(?:describe|it|test)$/;
            return me.type === "TaggedTemplateExpression" && me.quasi === O && me.tag.type === "MemberExpression" && me.tag.property.type === "Identifier" && me.tag.property.name === "each" && (me.tag.object.type === "Identifier" && _e.test(me.tag.object.name) || me.tag.object.type === "MemberExpression" && me.tag.object.property.type === "Identifier" && (me.tag.object.property.name === "only" || me.tag.object.property.name === "skip") && me.tag.object.object.type === "Identifier" && _e.test(me.tag.object.object.name));
          }
          function he(O) {
            return O.quasis.some((me) => me.value.raw.includes(`
`));
          }
          function we(O, me) {
            return (O.type === "TemplateLiteral" && he(O) || O.type === "TaggedTemplateExpression" && he(O.quasi)) && !a(me, p(O), { backwards: true });
          }
          function ke(O) {
            if (!Me(O)) return false;
            let me = s(ae(O, Te.Dangling));
            return me && !g(me);
          }
          function Re(O) {
            if (O.length <= 1) return false;
            let me = 0;
            for (let _e of O) if (b(_e)) {
              if (me += 1, me > 1) return true;
            } else if (de(_e)) {
              for (let He of _e.arguments) if (b(He)) return true;
            }
            return false;
          }
          function Ne(O) {
            let me = O.getValue(), _e = O.getParentNode();
            return de(me) && de(_e) && _e.callee === me && me.arguments.length > _e.arguments.length && _e.arguments.length > 0;
          }
          function Pe(O, me) {
            if (me >= 2) return false;
            let _e = (Qe) => Pe(Qe, me + 1), He = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
            if (He && l(He) > 5) return false;
            if (O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import") return true;
            if (O.type === "TemplateLiteral") return O.quasis.every((Qe) => !Qe.value.raw.includes(`
`)) && O.expressions.every(_e);
            if (O.type === "ObjectExpression") return O.properties.every((Qe) => !Qe.computed && (Qe.shorthand || Qe.value && _e(Qe.value)));
            if (O.type === "ArrayExpression") return O.elements.every((Qe) => Qe === null || _e(Qe));
            if (tt(O)) return (O.type === "ImportExpression" || Pe(O.callee, me)) && Ye(O).every(_e);
            if (ue(O)) return Pe(O.object, me) && Pe(O.property, me);
            let Ge = { "!": true, "-": true, "+": true, "~": true };
            if (O.type === "UnaryExpression" && Ge[O.operator]) return Pe(O.argument, me);
            let it = { "++": true, "--": true };
            return O.type === "UpdateExpression" && it[O.operator] ? Pe(O.argument, me) : O.type === "TSNonNullExpression" ? Pe(O.expression, me) : false;
          }
          function oe(O) {
            var me, _e;
            return (me = (_e = O.extra) === null || _e === void 0 ? void 0 : _e.raw) !== null && me !== void 0 ? me : O.raw;
          }
          function H(O) {
            return O;
          }
          function pe(O) {
            return O.filepath && /\.tsx$/i.test(O.filepath);
          }
          function X(O) {
            let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return O.trailingComma === "es5" && me === "es5" || O.trailingComma === "all" && (me === "all" || me === "es5");
          }
          function le(O, me) {
            switch (O.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "AssignmentExpression":
              case "NGPipeExpression":
                return le(O.left, me);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return le(O.object, me);
              case "TaggedTemplateExpression":
                return O.tag.type === "FunctionExpression" ? false : le(O.tag, me);
              case "CallExpression":
              case "OptionalCallExpression":
                return O.callee.type === "FunctionExpression" ? false : le(O.callee, me);
              case "ConditionalExpression":
                return le(O.test, me);
              case "UpdateExpression":
                return !O.prefix && le(O.argument, me);
              case "BindExpression":
                return O.object && le(O.object, me);
              case "SequenceExpression":
                return le(O.expressions[0], me);
              case "TSSatisfiesExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
                return le(O.expression, me);
              default:
                return me(O);
            }
          }
          var Ae = { "==": true, "!=": true, "===": true, "!==": true }, Ee = { "*": true, "/": true, "%": true }, De = { ">>": true, ">>>": true, "<<": true };
          function A(O, me) {
            return !(re(me) !== re(O) || O === "**" || Ae[O] && Ae[me] || me === "%" && Ee[O] || O === "%" && Ee[me] || me !== O && Ee[me] && Ee[O] || De[O] && De[me]);
          }
          var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, me) => O.map((_e) => [_e, me])));
          function re(O) {
            return G.get(O);
          }
          function ye(O) {
            return Boolean(De[O]) || O === "|" || O === "^" || O === "&";
          }
          function Ce(O) {
            var me;
            if (O.rest) return true;
            let _e = ve(O);
            return ((me = s(_e)) === null || me === void 0 ? void 0 : me.type) === "RestElement";
          }
          var Be = /* @__PURE__ */ new WeakMap();
          function ve(O) {
            if (Be.has(O)) return Be.get(O);
            let me = [];
            return O.this && me.push(O.this), Array.isArray(O.parameters) ? me.push(...O.parameters) : Array.isArray(O.params) && me.push(...O.params), O.rest && me.push(O.rest), Be.set(O, me), me;
          }
          function ze(O, me) {
            let _e = O.getValue(), He = 0, Ge = (it) => me(it, He++);
            _e.this && O.call(Ge, "this"), Array.isArray(_e.parameters) ? O.each(Ge, "parameters") : Array.isArray(_e.params) && O.each(Ge, "params"), _e.rest && O.call(Ge, "rest");
          }
          var be = /* @__PURE__ */ new WeakMap();
          function Ye(O) {
            if (be.has(O)) return be.get(O);
            let me = O.arguments;
            return O.type === "ImportExpression" && (me = [O.source], O.attributes && me.push(O.attributes)), be.set(O, me), me;
          }
          function Se(O, me) {
            let _e = O.getValue();
            _e.type === "ImportExpression" ? (O.call((He) => me(He, 0), "source"), _e.attributes && O.call((He) => me(He, 1), "attributes")) : O.each(me, "arguments");
          }
          function Ie(O) {
            return O.value.trim() === "prettier-ignore" && !O.unignore;
          }
          function Oe(O) {
            return O && (O.prettierIgnore || Me(O, Te.PrettierIgnore));
          }
          function Je(O) {
            let me = O.getValue();
            return Oe(me);
          }
          var Te = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je = (O, me) => {
            if (typeof O == "function" && (me = O, O = 0), O || me) return (_e, He, Ge) => !(O & Te.Leading && !_e.leading || O & Te.Trailing && !_e.trailing || O & Te.Dangling && (_e.leading || _e.trailing) || O & Te.Block && !g(_e) || O & Te.Line && !D(_e) || O & Te.First && He !== 0 || O & Te.Last && He !== Ge.length - 1 || O & Te.PrettierIgnore && !Ie(_e) || me && !me(_e));
          };
          function Me(O, me, _e) {
            if (!u(O == null ? void 0 : O.comments)) return false;
            let He = je(me, _e);
            return He ? O.comments.some(He) : true;
          }
          function ae(O, me, _e) {
            if (!Array.isArray(O == null ? void 0 : O.comments)) return [];
            let He = je(me, _e);
            return He ? O.comments.filter(He) : O.comments;
          }
          var nt = (O, me) => {
            let { originalText: _e } = me;
            return i(_e, y(O));
          };
          function tt(O) {
            return de(O) || O.type === "NewExpression" || O.type === "ImportExpression";
          }
          function Ve(O) {
            return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
          }
          function We(O) {
            return Boolean(O.__isUsingHackPipeline);
          }
          var Xe = Symbol("ifWithoutBlockAndSameLineComment");
          function st(O) {
            return O.type === "TSAsExpression" || O.type === "TSSatisfiesExpression";
          }
          r2.exports = { getFunctionParameters: ve, iterateFunctionParametersPath: ze, getCallArguments: Ye, iterateCallArgumentsPath: Se, hasRestParameter: Ce, getLeftSide: I, getLeftSidePathName: P, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: E, hasFlowShorthandAnnotationComment: w, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x, hasNode: N, hasIgnoreComment: Je, hasNodeIgnoreComment: Oe, identity: H, isBinaryish: V, isCallLikeExpression: tt, isEnabledHackPipeline: We, isLineComment: D, isPrettierIgnoreComment: Ie, isCallExpression: de, isMemberExpression: ue, isExportDeclaration: T, isFlowAnnotationComment: U, isFunctionCompositionArgs: Re, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q, isJestEachTemplateLiteral: ge, isJsxNode: M, isLiteral: C, isLongCurriedCallExpression: Ne, isSimpleCallArgument: Pe, isMemberish: j, isNumericLiteral: o, isSignedNumericLiteral: d, isObjectProperty: Ve, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie, isSimpleNumber: fe, isSimpleTemplateLiteral: Fe, isStringLiteral: v, isStringPropSafeToUnquote: se, isTemplateOnItsOwnLine: we, isTestCall: K, isTheOnlyJsxElementInMarkdown: R, isTSXFile: pe, isTypeAnnotationAFunction: Q, isNextLineEmpty: nt, needsHardlineAfterDanglingComment: ke, rawText: oe, shouldPrintComma: X, isBitwiseOperator: ye, shouldFlatten: A, startsWithNoLookaheadToken: le, getPrecedence: re, hasComment: Me, getComments: ae, CommentCheckFlags: Te, markerForIfWithoutBlockAndSameLineComment: Xe, isTSTypeExpression: st };
        } }), jt = te({ "src/language-js/print/template-literal.js"(e, r2) {
          ne();
          var t = lt(), { getStringWidth: s, getIndentSize: a } = Ue(), { builders: { join: n, hardline: u, softline: i, group: l, indent: p, align: y, lineSuffixBoundary: h, addAlignmentToDoc: g }, printer: { printDocToString: c2 }, utils: { mapDoc: f } } = qe(), { isBinaryish: F, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w, hasComment: E, isMemberExpression: N, isTSTypeExpression: x } = Ke();
          function I(C, o, d) {
            let v = C.getValue();
            if (v.type === "TemplateLiteral" && _(v, C.getParentNode())) {
              let R = P(C, d, o);
              if (R) return R;
            }
            let b = "expressions";
            v.type === "TSTemplateLiteralType" && (b = "types");
            let B = [], k = C.map(o, b), M = w(v);
            return M && (k = k.map((R) => c2(R, Object.assign(Object.assign({}, d), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(h, "`"), C.each((R) => {
              let q = R.getName();
              if (B.push(o()), q < k.length) {
                let { tabWidth: J } = d, L = R.getValue(), Q = a(L.value.raw, J), V = k[q];
                if (!M) {
                  let Y = v[b][q];
                  (E(Y) || N(Y) || Y.type === "ConditionalExpression" || Y.type === "SequenceExpression" || x(Y) || F(Y)) && (V = [p([i, V]), i]);
                }
                let j = Q === 0 && L.value.raw.endsWith(`
`) ? y(Number.NEGATIVE_INFINITY, V) : g(V, Q, J);
                B.push(l(["${", j, h, "}"]));
              }
            }, "quasis"), B.push("`"), B;
          }
          function P(C, o, d) {
            let v = C.getNode(), S = v.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (S.length > 1 || S.some((b) => b.length > 0)) {
              o.__inJestEach = true;
              let b = C.map(d, "expressions");
              o.__inJestEach = false;
              let B = [], k = b.map((L) => "${" + c2(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M = [{ hasLineBreak: false, cells: [] }];
              for (let L = 1; L < v.quasis.length; L++) {
                let Q = t(M), V = k[L - 1];
                Q.cells.push(V), V.includes(`
`) && (Q.hasLineBreak = true), v.quasis[L].value.raw.includes(`
`) && M.push({ hasLineBreak: false, cells: [] });
              }
              let R = Math.max(S.length, ...M.map((L) => L.cells.length)), q = Array.from({ length: R }).fill(0), J = [{ cells: S }, ...M.filter((L) => L.cells.length > 0)];
              for (let { cells: L } of J.filter((Q) => !Q.hasLineBreak)) for (let [Q, V] of L.entries()) q[Q] = Math.max(q[Q], s(V));
              return B.push(h, "`", p([u, n(u, J.map((L) => n(" | ", L.cells.map((Q, V) => L.hasLineBreak ? Q : Q + " ".repeat(q[V] - s(Q))))))]), u, "`"), B;
            }
          }
          function $(C, o) {
            let d = C.getValue(), v = o();
            return E(d) && (v = l([p([i, v]), i])), ["${", v, h, "}"];
          }
          function D(C, o) {
            return C.map((d) => $(d, o), "expressions");
          }
          function T(C, o) {
            return f(C, (d) => typeof d == "string" ? o ? d.replace(/(\\*)`/g, "$1$1\\`") : m(d) : d);
          }
          function m(C) {
            return C.replace(/([\\`]|\${)/g, "\\$1");
          }
          r2.exports = { printTemplateLiteral: I, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m };
        } }), Ym = te({ "src/language-js/embed/markdown.js"(e, r2) {
          ne();
          var { builders: { indent: t, softline: s, literalline: a, dedentToRoot: n } } = qe(), { escapeTemplateCharacters: u } = jt();
          function i(p, y, h) {
            let c2 = p.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w, E) => "\\".repeat(E.length / 2) + "`"), f = l(c2), F = f !== "";
            F && (c2 = c2.replace(new RegExp(`^${f}`, "gm"), ""));
            let _ = u(h(c2, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
            return ["`", F ? t([s, _]) : [a, n(_)], s, "`"];
          }
          function l(p) {
            let y = p.match(/^([^\S\n]*)\S/m);
            return y === null ? "" : y[1];
          }
          r2.exports = i;
        } }), Qm = te({ "src/language-js/embed/css.js"(e, r2) {
          ne();
          var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, hardline: a, softline: n }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe(), { printTemplateExpressions: p } = jt();
          function y(c2, f, F) {
            let _ = c2.getValue(), w = _.quasis.map((P) => P.value.raw), E = 0, N = w.reduce((P, $, D) => D === 0 ? $ : P + "@prettier-placeholder-" + E++ + "-id" + $, ""), x = F(N, { parser: "scss" }, { stripTrailingHardline: true }), I = p(c2, f);
            return h(x, _, I);
          }
          function h(c2, f, F) {
            if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim()) return "``";
            let w = g(c2, F);
            if (!w) throw new Error("Couldn't insert all the expressions");
            return ["`", s([a, w]), n, "`"];
          }
          function g(c2, f) {
            if (!t(f)) return c2;
            let F = 0, _ = u(l(c2), (w) => typeof w != "string" || !w.includes("@prettier-placeholder") ? w : w.split(/@prettier-placeholder-(\d+)-id/).map((E, N) => N % 2 === 0 ? i(E) : (F++, f[E])));
            return f.length === F ? _ : null;
          }
          r2.exports = y;
        } }), Zm = te({ "src/language-js/embed/graphql.js"(e, r2) {
          ne();
          var { builders: { indent: t, join: s, hardline: a } } = qe(), { escapeTemplateCharacters: n, printTemplateExpressions: u } = jt();
          function i(p, y, h) {
            let g = p.getValue(), c2 = g.quasis.length;
            if (c2 === 1 && g.quasis[0].value.raw.trim() === "") return "``";
            let f = u(p, y), F = [];
            for (let _ = 0; _ < c2; _++) {
              let w = g.quasis[_], E = _ === 0, N = _ === c2 - 1, x = w.value.cooked, I = x.split(`
`), P = I.length, $ = f[_], D = P > 2 && I[0].trim() === "" && I[1].trim() === "", T = P > 2 && I[P - 1].trim() === "" && I[P - 2].trim() === "", m = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
              if (!N && /#[^\n\r]*$/.test(I[P - 1])) return null;
              let C = null;
              m ? C = l(I) : C = h(x, { parser: "graphql" }, { stripTrailingHardline: true }), C ? (C = n(C, false), !E && D && F.push(""), F.push(C), !N && T && F.push("")) : !E && !N && D && F.push(""), $ && F.push($);
            }
            return ["`", t([a, s(a, F)]), a, "`"];
          }
          function l(p) {
            let y = [], h = false, g = p.map((c2) => c2.trim());
            for (let [c2, f] of g.entries()) f !== "" && (g[c2 - 1] === "" && h ? y.push([a, f]) : y.push(f), h = true);
            return y.length === 0 ? null : s(a, y);
          }
          r2.exports = i;
        } }), ed = te({ "src/language-js/embed/html.js"(e, r2) {
          ne();
          var { builders: { indent: t, line: s, hardline: a, group: n }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = jt(), p = 0;
          function y(h, g, c2, f, F) {
            let { parser: _ } = F, w = h.getValue(), E = p;
            p = p + 1 >>> 0;
            let N = (d) => `PRETTIER_HTML_PLACEHOLDER_${d}_${E}_IN_JS`, x = w.quasis.map((d, v, S) => v === S.length - 1 ? d.value.cooked : d.value.cooked + N(v)).join(""), I = i(h, g);
            if (I.length === 0 && x.trim().length === 0) return "``";
            let P = new RegExp(N("(\\d+)"), "g"), $ = 0, D = c2(x, { parser: _, __onHtmlRoot(d) {
              $ = d.children.length;
            } }, { stripTrailingHardline: true }), T = u(D, (d) => {
              if (typeof d != "string") return d;
              let v = [], S = d.split(P);
              for (let b = 0; b < S.length; b++) {
                let B = S[b];
                if (b % 2 === 0) {
                  B && (B = l(B), f.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v.push(B));
                  continue;
                }
                let k = Number(B);
                v.push(I[k]);
              }
              return v;
            }), m = /^\s/.test(x) ? " " : "", C = /\s$/.test(x) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? a : m && C ? s : null;
            return n(o ? ["`", t([o, n(T)]), o, "`"] : ["`", m, $ > 1 ? t(n(T)) : n(T), C, "`"]);
          }
          r2.exports = y;
        } }), td = te({ "src/language-js/embed.js"(e, r2) {
          ne();
          var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a } = Ke(), n = Ym(), u = Qm(), i = Zm(), l = ed();
          function p(D) {
            if (g(D) || _(D) || w(D) || c2(D)) return "css";
            if (x(D)) return "graphql";
            if (P(D)) return "html";
            if (f(D)) return "angular";
            if (h(D)) return "markdown";
          }
          function y(D, T, m, C) {
            let o = D.getValue();
            if (o.type !== "TemplateLiteral" || $(o)) return;
            let d = p(D);
            if (d) {
              if (d === "markdown") return n(D, T, m);
              if (d === "css") return u(D, T, m);
              if (d === "graphql") return i(D, T, m);
              if (d === "html" || d === "angular") return l(D, T, m, C, { parser: d });
            }
          }
          function h(D) {
            let T = D.getValue(), m = D.getParentNode();
            return m && m.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
          }
          function g(D) {
            let T = D.getValue(), m = D.getParentNode(), C = D.getParentNode(1);
            return C && T.quasis && m.type === "JSXExpressionContainer" && C.type === "JSXElement" && C.openingElement.name.name === "style" && C.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
          }
          function c2(D) {
            return D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "ArrayExpression" && m === "elements", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "styles" && m === "value", ...F);
          }
          function f(D) {
            return D.match((T) => T.type === "TemplateLiteral", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "template" && m === "value", ...F);
          }
          var F = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
          function _(D) {
            let T = D.getParentNode();
            if (!T || T.type !== "TaggedTemplateExpression") return false;
            let m = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
            switch (m.type) {
              case "MemberExpression":
                return E(m.object) || N(m);
              case "CallExpression":
                return E(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (E(m.callee.object.object) || N(m.callee.object)) || m.callee.object.type === "CallExpression" && E(m.callee.object.callee));
              case "Identifier":
                return m.name === "css";
              default:
                return false;
            }
          }
          function w(D) {
            let T = D.getParentNode(), m = D.getParentNode(1);
            return m && T.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
          }
          function E(D) {
            return D.type === "Identifier" && D.name === "styled";
          }
          function N(D) {
            return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
          }
          function x(D) {
            let T = D.getValue(), m = D.getParentNode();
            return I(T, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
          }
          function I(D, T) {
            return t(D, s.Block | s.Leading, (m) => {
              let { value: C } = m;
              return C === ` ${T} `;
            });
          }
          function P(D) {
            return I(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m === "quasi");
          }
          function $(D) {
            let { quasis: T } = D;
            return T.some((m) => {
              let { value: { cooked: C } } = m;
              return C === null;
            });
          }
          r2.exports = y;
        } }), rd = te({ "src/language-js/clean.js"(e, r2) {
          ne();
          var t = Pt(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
            for (let i of u.quasis) delete i.value;
          };
          function n(u, i, l) {
            if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ") return null;
            if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((h) => h.name.name === "jsx")) for (let { type: h, expression: g } of i.children) h === "JSXExpressionContainer" && g.type === "TemplateLiteral" && a(g);
            u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            let p = u.expression || u.callee;
            if (u.type === "Decorator" && p.type === "CallExpression" && p.callee.name === "Component" && p.arguments.length === 1) {
              let h = u.expression.arguments[0].properties;
              for (let [g, c2] of i.expression.arguments[0].properties.entries()) switch (h[g].key.name) {
                case "styles":
                  c2.value.type === "ArrayExpression" && a(c2.value.elements[0]);
                  break;
                case "template":
                  c2.value.type === "TemplateLiteral" && a(c2.value);
                  break;
              }
            }
            if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
              var y;
              (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some((g) => t(g) && ["GraphQL", "HTML"].some((c2) => g.value === ` ${c2} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a(i);
            }
            if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1) return i.types[0];
          }
          n.ignoredProperties = s, r2.exports = n;
        } }), io = {};
        Kt(io, { EOL: () => Wn, arch: () => nd, cpus: () => Do, default: () => vo, endianness: () => ao, freemem: () => po, getNetworkInterfaces: () => ho, hostname: () => oo, loadavg: () => lo, networkInterfaces: () => yo, platform: () => ud, release: () => go2, tmpDir: () => $n, tmpdir: () => Vn, totalmem: () => fo, type: () => mo, uptime: () => co });
        function ao() {
          if (typeof Tr > "u") {
            var e = new ArrayBuffer(2), r2 = new Uint8Array(e), t = new Uint16Array(e);
            if (r2[0] = 1, r2[1] = 2, t[0] === 258) Tr = "BE";
            else if (t[0] === 513) Tr = "LE";
            else throw new Error("unable to figure out endianess");
          }
          return Tr;
        }
        function oo() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function lo() {
          return [];
        }
        function co() {
          return 0;
        }
        function po() {
          return Number.MAX_VALUE;
        }
        function fo() {
          return Number.MAX_VALUE;
        }
        function Do() {
          return [];
        }
        function mo() {
          return "Browser";
        }
        function go2() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function yo() {
        }
        function ho() {
        }
        function nd() {
          return "javascript";
        }
        function ud() {
          return "browser";
        }
        function $n() {
          return "/tmp";
        }
        var Tr, Vn, Wn, vo, sd = ht({ "node-modules-polyfills:os"() {
          ne(), Vn = $n, Wn = `
`, vo = { EOL: Wn, tmpdir: Vn, tmpDir: $n, networkInterfaces: yo, getNetworkInterfaces: ho, release: go2, type: mo, cpus: Do, totalmem: fo, freemem: po, uptime: co, loadavg: lo, hostname: oo, endianness: ao };
        } }), id = te({ "node-modules-polyfills-commonjs:os"(e, r2) {
          ne();
          var t = (sd(), ft(io));
          if (t && t.default) {
            r2.exports = t.default;
            for (let s in t) r2.exports[s] = t[s];
          } else t && (r2.exports = t);
        } }), ad = te({ "node_modules/detect-newline/index.js"(e, r2) {
          ne();
          var t = (s) => {
            if (typeof s != "string") throw new TypeError("Expected a string");
            let a = s.match(/(?:\r?\n)/g) || [];
            if (a.length === 0) return;
            let n = a.filter((i) => i === `\r
`).length, u = a.length - n;
            return n > u ? `\r
` : `
`;
          };
          r2.exports = t, r2.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
        } }), od = te({ "node_modules/jest-docblock/build/index.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = c2, e.parse = F, e.parseWithComments = _, e.print = w, e.strip = f;
          function r2() {
            let N = id();
            return r2 = function() {
              return N;
            }, N;
          }
          function t() {
            let N = s(ad());
            return t = function() {
              return N;
            }, N;
          }
          function s(N) {
            return N && N.__esModule ? N : { default: N };
          }
          var a = /\*\/$/, n = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h = /(\r?\n|^) *\* ?/g, g = [];
          function c2(N) {
            let x = N.match(u);
            return x ? x[0].trimLeft() : "";
          }
          function f(N) {
            let x = N.match(u);
            return x && x[0] ? N.substring(x[0].length) : N;
          }
          function F(N) {
            return _(N).pragmas;
          }
          function _(N) {
            let x = (0, t().default)(N) || r2().EOL;
            N = N.replace(n, "").replace(a, "").replace(h, "$1");
            let I = "";
            for (; I !== N; ) I = N, N = N.replace(p, `${x}$1 $2${x}`);
            N = N.replace(l, "").trimRight();
            let P = /* @__PURE__ */ Object.create(null), $ = N.replace(y, "").replace(l, "").trimRight(), D;
            for (; D = y.exec(N); ) {
              let T = D[2].replace(i, "");
              typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g.concat(P[D[1]], T) : P[D[1]] = T;
            }
            return { comments: $, pragmas: P };
          }
          function w(N) {
            let { comments: x = "", pragmas: I = {} } = N, P = (0, t().default)(x) || r2().EOL, $ = "/**", D = " *", T = " */", m = Object.keys(I), C = m.map((d) => E(d, I[d])).reduce((d, v) => d.concat(v), []).map((d) => `${D} ${d}${P}`).join("");
            if (!x) {
              if (m.length === 0) return "";
              if (m.length === 1 && !Array.isArray(I[m[0]])) {
                let d = I[m[0]];
                return `${$} ${E(m[0], d)[0]}${T}`;
              }
            }
            let o = x.split(P).map((d) => `${D} ${d}`).join(P) + P;
            return $ + P + (x ? o : "") + (x && m.length ? D + P : "") + C + T;
          }
          function E(N, x) {
            return g.concat(x).map((I) => `@${N} ${I}`.trim());
          }
        } }), ld = te({ "src/language-js/utils/get-shebang.js"(e, r2) {
          ne();
          function t(s) {
            if (!s.startsWith("#!")) return "";
            let a = s.indexOf(`
`);
            return a === -1 ? s : s.slice(0, a);
          }
          r2.exports = t;
        } }), Co = te({ "src/language-js/pragma.js"(e, r2) {
          ne();
          var { parseWithComments: t, strip: s, extract: a, print: n } = od(), { normalizeEndOfLine: u } = Jn(), i = ld();
          function l(h) {
            let g = i(h);
            g && (h = h.slice(g.length + 1));
            let c2 = a(h), { pragmas: f, comments: F } = t(c2);
            return { shebang: g, text: h, pragmas: f, comments: F };
          }
          function p(h) {
            let g = Object.keys(l(h).pragmas);
            return g.includes("prettier") || g.includes("format");
          }
          function y(h) {
            let { shebang: g, text: c2, pragmas: f, comments: F } = l(h), _ = s(c2), w = n({ pragmas: Object.assign({ format: "" }, f), comments: F.trimStart() });
            return (g ? `${g}
` : "") + u(w) + (_.startsWith(`
`) ? `
` : `

`) + _;
          }
          r2.exports = { hasPragma: p, insertPragma: y };
        } }), cd = te({ "src/language-js/utils/is-type-cast-comment.js"(e, r2) {
          ne();
          var t = Pt();
          function s(a) {
            return t(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/.test(a.value);
          }
          r2.exports = s;
        } }), Eo = te({ "src/language-js/comments.js"(e, r2) {
          ne();
          var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: n, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: p, getNextNonSpaceNonCommentCharacterIndex: y, isNonEmptyArray: h } = Ue(), { getFunctionParameters: g, isPrettierIgnoreComment: c2, isJsxNode: f, hasFlowShorthandAnnotationComment: F, hasFlowAnnotationComment: _, hasIgnoreComment: w, isCallLikeExpression: E, getCallArguments: N, isCallExpression: x, isMemberExpression: I, isObjectProperty: P, isLineComment: $, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m } = Ke(), { locStart: C, locEnd: o } = ut(), d = Pt(), v = cd();
          function S(De) {
            return [H, Fe, Q, q, J, L, ie, he, se, ge, we, ke, ce, z, U].some((A) => A(De));
          }
          function b(De) {
            return [R, Fe, V, we, q, J, L, ie, z, Z, fe, ge, Pe, U, X].some((A) => A(De));
          }
          function B(De) {
            return [H, q, J, j, ue, ce, ge, de, K, pe, U, oe].some((A) => A(De));
          }
          function k(De, A) {
            let G = (De.body || De.properties).find((re) => {
              let { type: ye } = re;
              return ye !== "EmptyStatement";
            });
            G ? i(G, A) : p(De, A);
          }
          function M(De, A) {
            De.type === "BlockStatement" ? k(De, A) : i(De, A);
          }
          function R(De) {
            let { comment: A, followingNode: G } = De;
            return G && v(A) ? (i(G, A), true) : false;
          }
          function q(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
            if ((re == null ? void 0 : re.type) !== "IfStatement" || !ye) return false;
            if (n(Ce, A, o) === ")") return l(G, A), true;
            if (G === re.consequent && ye === re.alternate) {
              if (G.type === "BlockStatement") l(G, A);
              else {
                let ve = A.type === "SingleLine" || A.loc.start.line === A.loc.end.line, ze = A.loc.start.line === G.loc.start.line;
                ve && ze ? p(G, A, m) : p(re, A);
              }
              return true;
            }
            return ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "IfStatement" ? (M(ye.consequent, A), true) : re.consequent === ye ? (i(ye, A), true) : false;
          }
          function J(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
            return (re == null ? void 0 : re.type) !== "WhileStatement" || !ye ? false : n(Ce, A, o) === ")" ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : re.body === ye ? (i(ye, A), true) : false;
          }
          function L(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
            return (re == null ? void 0 : re.type) !== "TryStatement" && (re == null ? void 0 : re.type) !== "CatchClause" || !ye ? false : re.type === "CatchClause" && G ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "TryStatement" ? (M(ye.finalizer, A), true) : ye.type === "CatchClause" ? (M(ye.body, A), true) : false;
          }
          function Q(De) {
            let { comment: A, enclosingNode: G, followingNode: re } = De;
            return I(G) && (re == null ? void 0 : re.type) === "Identifier" ? (i(G, A), true) : false;
          }
          function V(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De, Be = G && !u(Ce, o(G), C(A));
            return (!G || !Be) && ((re == null ? void 0 : re.type) === "ConditionalExpression" || (re == null ? void 0 : re.type) === "TSConditionalType") && ye ? (i(ye, A), true) : false;
          }
          function j(De) {
            let { comment: A, precedingNode: G, enclosingNode: re } = De;
            return P(re) && re.shorthand && re.key === G && re.value.type === "AssignmentPattern" ? (l(re.value.left, A), true) : false;
          }
          var Y = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
          function ie(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
            if (Y.has(re == null ? void 0 : re.type)) {
              if (h(re.decorators) && !(ye && ye.type === "Decorator")) return l(t(re.decorators), A), true;
              if (re.body && ye === re.body) return k(re.body, A), true;
              if (ye) {
                if (re.superClass && ye === re.superClass && G && (G === re.id || G === re.typeParameters)) return l(G, A), true;
                for (let Ce of ["implements", "extends", "mixins"]) if (re[Ce] && ye === re[Ce][0]) return G && (G === re.id || G === re.typeParameters || G === re.superClass) ? l(G, A) : p(re, A, Ce), true;
              }
            }
            return false;
          }
          var ee = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
          function ce(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
            return re && G && n(ye, A, o) === "(" && (re.type === "Property" || re.type === "TSDeclareMethod" || re.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && re.key === G && n(ye, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && ee.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
          }
          var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
          function K(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
            return n(ye, A, o) !== "(" ? false : G && W.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
          }
          function de(De) {
            let { comment: A, enclosingNode: G, text: re } = De;
            if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression") return false;
            let ye = y(re, A, o);
            return ye !== false && re.slice(ye, ye + 2) === "=>" ? (p(G, A), true) : false;
          }
          function ue(De) {
            let { comment: A, enclosingNode: G, text: re } = De;
            return n(re, A, o) !== ")" ? false : G && (le(G) && g(G).length === 0 || E(G) && N(G).length === 0) ? (p(G, A), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g(G.value).length === 0 ? (p(G.value, A), true) : false;
          }
          function Fe(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
            if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (re == null ? void 0 : re.type) === "FunctionTypeAnnotation" && (ye == null ? void 0 : ye.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && re && le(re) && n(Ce, A, o) === ")") return l(G, A), true;
            if ((re == null ? void 0 : re.type) === "FunctionDeclaration" && (ye == null ? void 0 : ye.type) === "BlockStatement") {
              let Be = (() => {
                let ve = g(re);
                if (ve.length > 0) return a(Ce, o(t(ve)));
                let ze = a(Ce, o(re.id));
                return ze !== false && a(Ce, ze + 1);
              })();
              if (C(A) > Be) return k(ye, A), true;
            }
            return false;
          }
          function z(De) {
            let { comment: A, enclosingNode: G } = De;
            return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, A), true) : false;
          }
          function U(De) {
            let { comment: A, enclosingNode: G } = De;
            return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, A), true) : false;
          }
          function Z(De) {
            let { comment: A, precedingNode: G, enclosingNode: re } = De;
            return x(re) && G && re.callee === G && re.arguments.length > 0 ? (i(re.arguments[0], A), true) : false;
          }
          function se(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
            return (re == null ? void 0 : re.type) === "UnionTypeAnnotation" || (re == null ? void 0 : re.type) === "TSUnionType" ? (c2(A) && (ye.prettierIgnore = true, A.unignore = true), G ? (l(G, A), true) : false) : (((ye == null ? void 0 : ye.type) === "UnionTypeAnnotation" || (ye == null ? void 0 : ye.type) === "TSUnionType") && c2(A) && (ye.types[0].prettierIgnore = true, A.unignore = true), false);
          }
          function fe(De) {
            let { comment: A, enclosingNode: G } = De;
            return P(G) ? (i(G, A), true) : false;
          }
          function ge(De) {
            let { comment: A, enclosingNode: G, followingNode: re, ast: ye, isLastComment: Ce } = De;
            return ye && ye.body && ye.body.length === 0 ? (Ce ? p(ye, A) : i(ye, A), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !h(G.directives) ? (Ce ? p(G, A) : i(G, A), true) : (re == null ? void 0 : re.type) === "Program" && (re == null ? void 0 : re.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (p(re, A), true) : false;
          }
          function he(De) {
            let { comment: A, enclosingNode: G } = De;
            return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, A), true) : false;
          }
          function we(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
            if ((re == null ? void 0 : re.type) === "ImportSpecifier" || (re == null ? void 0 : re.type) === "ExportSpecifier") return i(re, A), true;
            let Ce = (G == null ? void 0 : G.type) === "ImportSpecifier" && (re == null ? void 0 : re.type) === "ImportDeclaration", Be = (G == null ? void 0 : G.type) === "ExportSpecifier" && (re == null ? void 0 : re.type) === "ExportNamedDeclaration";
            return (Ce || Be) && s(ye, o(A)) ? (l(G, A), true) : false;
          }
          function ke(De) {
            let { comment: A, enclosingNode: G } = De;
            return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, A), true) : false;
          }
          var Re = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
          function Pe(De) {
            let { comment: A, enclosingNode: G, followingNode: re } = De;
            return Re.has(G == null ? void 0 : G.type) && re && (Ne.has(re.type) || d(A)) ? (i(re, A), true) : false;
          }
          function oe(De) {
            let { comment: A, enclosingNode: G, followingNode: re, text: ye } = De;
            return !re && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && n(ye, A, o) === ";" ? (l(G, A), true) : false;
          }
          function H(De) {
            let { comment: A, enclosingNode: G, followingNode: re } = De;
            if (c2(A) && (G == null ? void 0 : G.type) === "TSMappedType" && (re == null ? void 0 : re.type) === "TSTypeParameter" && re.constraint) return G.prettierIgnore = true, A.unignore = true, true;
          }
          function pe(De) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
            return (re == null ? void 0 : re.type) !== "TSMappedType" ? false : (ye == null ? void 0 : ye.type) === "TSTypeParameter" && ye.name ? (i(ye.name, A), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, A), true) : false;
          }
          function X(De) {
            let { comment: A, enclosingNode: G, followingNode: re } = De;
            return !G || G.type !== "SwitchCase" || G.test || !re || re !== G.consequent[0] ? false : (re.type === "BlockStatement" && $(A) ? k(re, A) : p(G, A), true);
          }
          function le(De) {
            return De.type === "ArrowFunctionExpression" || De.type === "FunctionExpression" || De.type === "FunctionDeclaration" || De.type === "ObjectMethod" || De.type === "ClassMethod" || De.type === "TSDeclareFunction" || De.type === "TSCallSignatureDeclaration" || De.type === "TSConstructSignatureDeclaration" || De.type === "TSMethodSignature" || De.type === "TSConstructorType" || De.type === "TSFunctionType" || De.type === "TSDeclareMethod";
          }
          function Ae(De, A) {
            if ((A.parser === "typescript" || A.parser === "flow" || A.parser === "acorn" || A.parser === "espree" || A.parser === "meriyah" || A.parser === "__babel_estree") && De.type === "MethodDefinition" && De.value && De.value.type === "FunctionExpression" && g(De.value).length === 0 && !De.value.returnType && !h(De.value.typeParameters) && De.value.body) return [...De.decorators || [], De.key, De.value.body];
          }
          function Ee(De) {
            let A = De.getValue(), G = De.getParentNode(), re = (ye) => _(D(ye, T.Leading)) || _(D(ye, T.Trailing));
            return (A && (f(A) || F(A) || x(G) && re(A)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === A)) && (!w(De) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
          }
          r2.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae, willPrintOwnComments: Ee };
        } }), qt = te({ "src/language-js/needs-parens.js"(e, r2) {
          ne();
          var t = lt(), s = Kn(), { getFunctionParameters: a, getLeftSidePathName: n, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: p, startsWithNoLookaheadToken: y, shouldFlatten: h, getPrecedence: g, isCallExpression: c2, isMemberExpression: f, isObjectProperty: F, isTSTypeExpression: _ } = Ke();
          function w(D, T) {
            let m = D.getParentNode();
            if (!m) return false;
            let C = D.getName(), o = D.getNode();
            if (T.__isInHtmlInterpolation && !T.bracketSpacing && I(o) && P(D)) return true;
            if (E(o)) return false;
            if (T.parser !== "flow" && u(D.getValue())) return true;
            if (o.type === "Identifier") {
              if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C === "left" && (o.name === "async" && !m.await || o.name === "let") && m.type === "ForOfStatement") return true;
              if (o.name === "let") {
                var d;
                let S = (d = D.findAncestor((b) => b.type === "ForOfStatement")) === null || d === void 0 ? void 0 : d.left;
                if (S && y(S, (b) => b === o)) return true;
              }
              if (C === "object" && o.name === "let" && m.type === "MemberExpression" && m.computed && !m.optional) {
                let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
                if (b && y(b, (B) => B === o)) return true;
              }
              return false;
            }
            if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
              var v;
              let S = (v = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v === void 0 ? void 0 : v.expression;
              if (S && y(S, (b) => b === o)) return true;
            }
            switch (m.type) {
              case "ParenthesizedExpression":
                return false;
              case "ClassDeclaration":
              case "ClassExpression": {
                if (C === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression")) return true;
                break;
              }
              case "ExportDefaultDeclaration":
                return $(D, T) || o.type === "SequenceExpression";
              case "Decorator": {
                if (C === "expression") {
                  if (f(o) && o.computed) return true;
                  let S = false, b = false, B = o;
                  for (; B; ) switch (B.type) {
                    case "MemberExpression":
                      b = true, B = B.object;
                      break;
                    case "CallExpression":
                      if (b || S) return T.parser !== "typescript";
                      S = true, B = B.callee;
                      break;
                    case "Identifier":
                      return false;
                    case "TaggedTemplateExpression":
                      return T.parser !== "typescript";
                    default:
                      return true;
                  }
                  return true;
                }
                break;
              }
              case "ArrowFunctionExpression": {
                if (C === "body" && o.type !== "SequenceExpression" && y(o, (S) => S.type === "ObjectExpression")) return true;
                break;
              }
            }
            switch (o.type) {
              case "UpdateExpression":
                if (m.type === "UnaryExpression") return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
              case "UnaryExpression":
                switch (m.type) {
                  case "UnaryExpression":
                    return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "TaggedTemplateExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "BinaryExpression":
                    return C === "left" && m.operator === "**";
                  case "TSNonNullExpression":
                    return true;
                  default:
                    return false;
                }
              case "BinaryExpression": {
                if (m.type === "UpdateExpression" || o.operator === "in" && N(D)) return true;
                if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
                  let S = D.getParentNode(1);
                  if (S.type === "BinaryExpression" && S.operator === "|>") return true;
                }
              }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "LogicalExpression":
                switch (m.type) {
                  case "TSSatisfiesExpression":
                  case "TSAsExpression":
                    return !_(o);
                  case "ConditionalExpression":
                    return _(o);
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return C === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return C === "left" && (o.type === "TSTypeAssertion" || _(o));
                  case "LogicalExpression":
                    if (o.type === "LogicalExpression") return m.operator !== o.operator;
                  case "BinaryExpression": {
                    let { operator: S, type: b } = o;
                    if (!S && b !== "TSTypeAssertion") return true;
                    let B = g(S), k = m.operator, M = g(k);
                    return M > B || C === "right" && M === B || M === B && !h(k, S) ? true : M < B && S === "%" ? k === "+" || k === "-" : !!p(k);
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (m.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return C !== "expression";
                  case "ArrowFunctionExpression":
                    return C !== "body";
                  default:
                    return true;
                }
              case "YieldExpression":
                if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || _(m) || m.type === "TSNonNullExpression") return true;
              case "AwaitExpression":
                switch (m.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ConditionalExpression":
                    return C === "test";
                  case "BinaryExpression":
                    return !(!o.argument && m.operator === "|>");
                  default:
                    return false;
                }
              case "TSConditionalType":
              case "TSFunctionType":
              case "TSConstructorType":
                if (C === "extendsType" && m.type === "TSConditionalType") {
                  if (o.type === "TSConditionalType") return true;
                  let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
                  if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint) return true;
                }
                if (C === "checkType" && m.type === "TSConditionalType") return true;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1)) return true;
              case "TSInferType":
                if (o.type === "TSInferType" && m.type === "TSRestType") return false;
              case "TSTypeOperator":
                return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || C === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
              case "TSTypeQuery":
                return C === "objectType" && m.type === "TSIndexedAccessType" || C === "elementType" && m.type === "TSArrayType";
              case "TypeofTypeAnnotation":
                return C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || C === "elementType" && m.type === "ArrayTypeAnnotation";
              case "ArrayTypeAnnotation":
                return m.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return m.type === "ArrayTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation": {
                let S = m.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m;
                return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
              }
              case "OptionalIndexedAccessType":
                return C === "objectType" && m.type === "IndexedAccessType";
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
                  let S = D.getParentNode(1);
                  return S.type === "Program" || S.type === "BlockStatement";
                }
                return C === "object" && m.type === "MemberExpression" && typeof o.value == "number";
              case "AssignmentExpression": {
                let S = D.getParentNode(1);
                return C === "body" && m.type === "ArrowFunctionExpression" ? true : C === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (C === "init" || C === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m || S.update === m) || C === "value" && m.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m) || m.type === "NGChainedExpression");
              }
              case "ConditionalExpression":
                switch (m.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ConditionalExpression":
                    return C === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  default:
                    return false;
                }
              case "FunctionExpression":
                switch (m.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "TaggedTemplateExpression":
                    return true;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                switch (m.type) {
                  case "BinaryExpression":
                    return m.operator !== "|>" || o.extra && o.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return true;
                  case "ConditionalExpression":
                    return C === "test";
                  default:
                    return false;
                }
              case "ClassExpression":
                if (s(o.decorators)) return true;
                switch (m.type) {
                  case "NewExpression":
                    return C === "callee";
                  default:
                    return false;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression": {
                let S = D.getParentNode(1);
                if (C === "object" && m.type === "MemberExpression" || C === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m) return true;
              }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
                  let S = o;
                  for (; S; ) switch (S.type) {
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                    case "BindExpression":
                      S = S.object;
                      break;
                    case "TaggedTemplateExpression":
                      S = S.tag;
                      break;
                    case "TSNonNullExpression":
                      S = S.expression;
                      break;
                    default:
                      return false;
                  }
                }
                return false;
              case "BindExpression":
                return C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || C === "object" && f(m);
              case "NGPipeExpression":
                return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || c2(m) && m.arguments[C] === o || C === "right" && m.type === "NGPipeExpression" || C === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return C === "callee" || C === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !c2(m) && !F(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
              case "TypeAnnotation":
                return C === "returnType" && m.type === "ArrowFunctionExpression" && x(o);
            }
            return false;
          }
          function E(D) {
            return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
          }
          function N(D) {
            let T = 0, m = D.getValue();
            for (; m; ) {
              let C = D.getParentNode(T++);
              if (C && C.type === "ForStatement" && C.init === m) return true;
              m = C;
            }
            return false;
          }
          function x(D) {
            return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }
          function I(D) {
            switch (D.type) {
              case "ObjectExpression":
                return true;
              default:
                return false;
            }
          }
          function P(D) {
            let T = D.getValue(), m = D.getParentNode(), C = D.getName();
            switch (m.type) {
              case "NGPipeExpression":
                if (typeof C == "number" && m.arguments[C] === T && m.arguments.length - 1 === C) return D.callParent(P);
                break;
              case "ObjectProperty":
                if (C === "value") {
                  let o = D.getParentNode(1);
                  return t(o.properties) === m;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (C === "right") return D.callParent(P);
                break;
              case "ConditionalExpression":
                if (C === "alternate") return D.callParent(P);
                break;
              case "UnaryExpression":
                if (m.prefix) return D.callParent(P);
                break;
            }
            return false;
          }
          function $(D, T) {
            let m = D.getValue(), C = D.getParentNode();
            return m.type === "FunctionExpression" || m.type === "ClassExpression" ? C.type === "ExportDefaultDeclaration" || !w(D, T) : !i(m) || C.type !== "ExportDefaultDeclaration" && w(D, T) ? false : D.call((o) => $(o, T), ...n(D, m));
          }
          r2.exports = w;
        } }), Fo = te({ "src/language-js/print-preprocess.js"(e, r2) {
          ne();
          function t(s, a) {
            switch (a.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
              case "__vue_ts_expression":
                return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
              default:
                return s;
            }
          }
          r2.exports = t;
        } }), pd = te({ "src/language-js/print/html-binding.js"(e, r2) {
          ne();
          var { builders: { join: t, line: s, group: a, softline: n, indent: u } } = qe();
          function i(p, y, h) {
            let g = p.getValue();
            if (y.__onHtmlBindingRoot && p.getName() === null && y.__onHtmlBindingRoot(g, y), g.type === "File") {
              if (y.__isVueForBindingLeft) return p.call((c2) => {
                let f = t([",", s], c2.map(h, "params")), { params: F } = c2.getValue();
                return F.length === 1 ? f : ["(", u([n, a(f)]), n, ")"];
              }, "program", "body", 0);
              if (y.__isVueBindings) return p.call((c2) => t([",", s], c2.map(h, "params")), "program", "body", 0);
            }
          }
          function l(p) {
            switch (p.type) {
              case "MemberExpression":
                switch (p.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return l(p.object);
                }
                return false;
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          r2.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
        } }), ru = te({ "src/language-js/print/binaryish.js"(e, r2) {
          ne();
          var { printComments: t } = et(), { getLast: s } = Ue(), { builders: { join: a, line: n, softline: u, group: i, indent: l, align: p, indentIfBreak: y }, utils: { cleanDoc: h, getDocParts: g, isConcat: c2 } } = qe(), { hasLeadingOwnLineComment: f, isBinaryish: F, isJsxNode: _, shouldFlatten: w, hasComment: E, CommentCheckFlags: N, isCallExpression: x, isMemberExpression: I, isObjectProperty: P, isEnabledHackPipeline: $ } = Ke(), D = 0;
          function T(o, d, v) {
            let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M = $(d) && S.operator === "|>", R = m(o, v, d, false, k);
            if (k) return R;
            if (M) return i(R);
            if (x(b) && b.callee === S || b.type === "UnaryExpression" || I(b) && !b.computed) return i([l([u, ...R]), u]);
            let q = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && d.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x(B) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = F(S.left) && w(S.operator, S.left.operator);
            if (q || C(S) && !L || !C(S) && J) return i(R);
            if (R.length === 0) return "";
            let Q = _(S.right), V = R.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j = R.slice(0, V === -1 ? 1 : V + 1), Y = R.slice(j.length, Q ? -1 : void 0), ie = Symbol("logicalChain-" + ++D), ee = i([...j, l(Y)], { id: ie });
            if (!Q) return ee;
            let ce = s(R);
            return i([ee, y(ce, { groupId: ie })]);
          }
          function m(o, d, v, S, b) {
            let B = o.getValue();
            if (!F(B)) return [i(d())];
            let k = [];
            w(B.operator, B.left.operator) ? k = o.call((Y) => m(Y, d, v, true, b), "left") : k.push(i(d("left")));
            let M = C(B), R = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v.parser === "__vue_expression") && !f(v.originalText, B.right), q = B.type === "NGPipeExpression" ? "|" : B.operator, J = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i(l([n, ": ", a([n, ": "], o.map(d, "arguments").map((Y) => p(2, i(Y))))])) : "", L;
            if (M) L = [q, " ", d("right"), J];
            else {
              let ie = $(v) && q === "|>" ? o.call((ee) => m(ee, d, v, true, b), "right") : d("right");
              L = [R ? n : "", q, R ? " " : n, ie, J];
            }
            let Q = o.getParentNode(), V = E(B.left, N.Trailing | N.Line), j = V || !(b && B.type === "LogicalExpression") && Q.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
            if (k.push(R ? "" : " ", j ? i(L, { shouldBreak: V }) : L), S && E(B)) {
              let Y = h(t(o, k, v));
              return c2(Y) || Y.type === "fill" ? g(Y) : [Y];
            }
            return k;
          }
          function C(o) {
            return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
          }
          r2.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C };
        } }), fd = te({ "src/language-js/print/angular.js"(e, r2) {
          ne();
          var { builders: { join: t, line: s, group: a } } = qe(), { hasNode: n, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: l } = ru();
          function p(g, c2, f) {
            let F = g.getValue();
            if (F.type.startsWith("NG")) switch (F.type) {
              case "NGRoot":
                return [f("node"), u(F.node) ? " //" + i(F.node)[0].value.trimEnd() : ""];
              case "NGPipeExpression":
                return l(g, c2, f);
              case "NGChainedExpression":
                return a(t([";", s], g.map((_) => h(_) ? f() : ["(", f(), ")"], "expressions")));
              case "NGEmptyExpression":
                return "";
              case "NGQuotedExpression":
                return [F.prefix, ": ", F.value.trim()];
              case "NGMicrosyntax":
                return g.map((_, w) => [w === 0 ? "" : y(_.getValue(), w, F) ? " " : [";", s], f()], "body");
              case "NGMicrosyntaxKey":
                return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(F.name) ? F.name : JSON.stringify(F.name);
              case "NGMicrosyntaxExpression":
                return [f("expression"), F.alias === null ? "" : [" as ", f("alias")]];
              case "NGMicrosyntaxKeyedExpression": {
                let _ = g.getName(), w = g.getParentNode(), E = y(F, _, w) || (_ === 1 && (F.key.name === "then" || F.key.name === "else") || _ === 2 && F.key.name === "else" && w.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w.body[_ - 1].key.name === "then") && w.body[0].type === "NGMicrosyntaxExpression";
                return [f("key"), E ? " " : ": ", f("expression")];
              }
              case "NGMicrosyntaxLet":
                return ["let ", f("key"), F.value === null ? "" : [" = ", f("value")]];
              case "NGMicrosyntaxAs":
                return [f("key"), " as ", f("alias")];
              default:
                throw new Error(`Unknown Angular node type: ${JSON.stringify(F.type)}.`);
            }
          }
          function y(g, c2, f) {
            return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && c2 === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
          }
          function h(g) {
            return n(g.getValue(), (c2) => {
              switch (c2.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }
          r2.exports = { printAngular: p };
        } }), Dd = te({ "src/language-js/print/jsx.js"(e, r2) {
          ne();
          var { printComments: t, printDanglingComments: s, printCommentsSeparately: a } = et(), { builders: { line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y, fill: h, ifBreak: g, lineSuffixBoundary: c2, join: f }, utils: { willBreak: F } } = qe(), { getLast: _, getPreferredQuote: w } = Ue(), { isJsxNode: E, rawText: N, isCallExpression: x, isStringLiteral: I, isBinaryish: P, hasComment: $, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke(), m = qt(), { willPrintOwnComments: C } = Eo(), o = (U) => U === "" || U === n || U === u || U === i;
          function d(U, Z, se) {
            let fe = U.getValue();
            if (fe.type === "JSXElement" && de(fe)) return [se("openingElement"), se("closingElement")];
            let ge = fe.type === "JSXElement" ? se("openingElement") : se("openingFragment"), he = fe.type === "JSXElement" ? se("closingElement") : se("closingFragment");
            if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression")) return [ge, ...U.map(se, "children"), he];
            fe.children = fe.children.map((A) => Fe(A) ? { type: "JSXText", value: " ", raw: " " } : A);
            let we = fe.children.some(E), ke = fe.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, Re = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, Ne = F(ge) || we || Re || ke, Pe = U.getParentNode().rootMarker === "mdx", oe = Z.singleQuote ? "{' '}" : '{" "}', H = Pe ? " " : g([oe, i], " "), pe = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", X = v(U, Z, se, H, pe), le = fe.children.some((A) => ue(A));
            for (let A = X.length - 2; A >= 0; A--) {
              let G = X[A] === "" && X[A + 1] === "", re = X[A] === u && X[A + 1] === "" && X[A + 2] === u, ye = (X[A] === i || X[A] === u) && X[A + 1] === "" && X[A + 2] === H, Ce = X[A] === H && X[A + 1] === "" && (X[A + 2] === i || X[A + 2] === u), Be = X[A] === H && X[A + 1] === "" && X[A + 2] === H, ve = X[A] === i && X[A + 1] === "" && X[A + 2] === u || X[A] === u && X[A + 1] === "" && X[A + 2] === i;
              re && le || G || ye || Be || ve ? X.splice(A, 2) : Ce && X.splice(A + 1, 2);
            }
            for (; X.length > 0 && o(_(X)); ) X.pop();
            for (; X.length > 1 && o(X[0]) && o(X[1]); ) X.shift(), X.shift();
            let Ae = [];
            for (let [A, G] of X.entries()) {
              if (G === H) {
                if (A === 1 && X[A - 1] === "") {
                  if (X.length === 2) {
                    Ae.push(oe);
                    continue;
                  }
                  Ae.push([oe, u]);
                  continue;
                } else if (A === X.length - 1) {
                  Ae.push(oe);
                  continue;
                } else if (X[A - 1] === "" && X[A - 2] === u) {
                  Ae.push(oe);
                  continue;
                }
              }
              Ae.push(G), F(G) && (Ne = true);
            }
            let Ee = le ? h(Ae) : l(Ae, { shouldBreak: true });
            if (Pe) return Ee;
            let De = l([ge, p([u, Ee]), u, he]);
            return Ne ? De : y([l([ge, ...X, he]), De]);
          }
          function v(U, Z, se, fe, ge) {
            let he = [];
            return U.each((we, ke, Re) => {
              let Ne = we.getValue();
              if (Ne.type === "JSXText") {
                let Pe = N(Ne);
                if (ue(Ne)) {
                  let oe = Pe.split(ce);
                  if (oe[0] === "") {
                    if (he.push(""), oe.shift(), /\n/.test(oe[0])) {
                      let pe = Re[ke + 1];
                      he.push(b(ge, oe[1], Ne, pe));
                    } else he.push(fe);
                    oe.shift();
                  }
                  let H;
                  if (_(oe) === "" && (oe.pop(), H = oe.pop()), oe.length === 0) return;
                  for (let [pe, X] of oe.entries()) pe % 2 === 1 ? he.push(n) : he.push(X);
                  if (H !== void 0) if (/\n/.test(H)) {
                    let pe = Re[ke + 1];
                    he.push(b(ge, _(he), Ne, pe));
                  } else he.push(fe);
                  else {
                    let pe = Re[ke + 1];
                    he.push(S(ge, _(he), Ne, pe));
                  }
                } else /\n/.test(Pe) ? Pe.match(/\n/g).length > 1 && he.push("", u) : he.push("", fe);
              } else {
                let Pe = se();
                he.push(Pe);
                let oe = Re[ke + 1];
                if (oe && ue(oe)) {
                  let pe = K(N(oe)).split(ce)[0];
                  he.push(S(ge, pe, Ne, oe));
                } else he.push(u);
              }
            }, "children"), he;
          }
          function S(U, Z, se, fe) {
            return U ? "" : se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? i : u : i;
          }
          function b(U, Z, se, fe) {
            return U ? u : Z.length === 1 ? se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? u : i : u;
          }
          function B(U, Z, se) {
            let fe = U.getParentNode();
            if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type]) return Z;
            let he = U.match(void 0, (ke) => ke.type === "ArrowFunctionExpression", x, (ke) => ke.type === "JSXExpressionContainer"), we = m(U, se);
            return l([we ? "" : g("("), p([i, Z]), i, we ? "" : g(")")], { shouldBreak: he });
          }
          function k(U, Z, se) {
            let fe = U.getValue(), ge = [];
            if (ge.push(se("name")), fe.value) {
              let he;
              if (I(fe.value)) {
                let ke = N(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re, quote: Ne, regex: Pe } = w(ke, Z.jsxSingleQuote ? "'" : '"');
                ke = ke.replace(Pe, Re);
                let { leading: oe, trailing: H } = U.call(() => a(U, Z), "value");
                he = [oe, Ne, ke, Ne, H];
              } else he = se("value");
              ge.push("=", he);
            }
            return ge;
          }
          function M(U, Z, se) {
            let fe = U.getValue(), ge = (he, we) => he.type === "JSXEmptyExpression" || !$(he) && (he.type === "ArrayExpression" || he.type === "ObjectExpression" || he.type === "ArrowFunctionExpression" || he.type === "AwaitExpression" && (ge(he.argument, he) || he.argument.type === "JSXElement") || x(he) || he.type === "FunctionExpression" || he.type === "TemplateLiteral" || he.type === "TaggedTemplateExpression" || he.type === "DoExpression" || E(we) && (he.type === "ConditionalExpression" || P(he)));
            return ge(fe.expression, U.getParentNode(0)) ? l(["{", se("expression"), c2, "}"]) : l(["{", p([i, se("expression")]), i, c2, "}"]);
          }
          function R(U, Z, se) {
            let fe = U.getValue(), ge = fe.name && $(fe.name) || fe.typeParameters && $(fe.typeParameters);
            if (fe.selfClosing && fe.attributes.length === 0 && !ge) return ["<", se("name"), se("typeParameters"), " />"];
            if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !$(fe.attributes[0])) return l(["<", se("name"), se("typeParameters"), " ", ...U.map(se, "attributes"), fe.selfClosing ? " />" : ">"]);
            let he = fe.attributes && fe.attributes.some((ke) => ke.value && I(ke.value) && ke.value.value.includes(`
`)), we = Z.singleAttributePerLine && fe.attributes.length > 1 ? u : n;
            return l(["<", se("name"), se("typeParameters"), p(U.map(() => [we, se()], "attributes")), ...q(fe, Z, ge)], { shouldBreak: he });
          }
          function q(U, Z, se) {
            return U.selfClosing ? [n, "/>"] : J(U, Z, se) ? [">"] : [i, ">"];
          }
          function J(U, Z, se) {
            let fe = U.attributes.length > 0 && $(_(U.attributes), D.Trailing);
            return U.attributes.length === 0 && !se || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se || U.attributes.length > 0) && !fe;
          }
          function L(U, Z, se) {
            let fe = U.getValue(), ge = [];
            ge.push("</");
            let he = se("name");
            return $(fe.name, D.Leading | D.Line) ? ge.push(p([u, he]), u) : $(fe.name, D.Leading | D.Block) ? ge.push(" ", he) : ge.push(he), ge.push(">"), ge;
          }
          function Q(U, Z) {
            let se = U.getValue(), fe = $(se), ge = $(se, D.Line), he = se.type === "JSXOpeningFragment";
            return [he ? "<" : "</", p([ge ? u : fe && !he ? " " : "", s(U, Z, true)]), ge ? u : "", ">"];
          }
          function V(U, Z, se) {
            let fe = t(U, d(U, Z, se), Z);
            return B(U, fe, Z);
          }
          function j(U, Z) {
            let se = U.getValue(), fe = $(se, D.Line);
            return [s(U, Z, !fe), fe ? u : ""];
          }
          function Y(U, Z, se) {
            let fe = U.getValue();
            return ["{", U.call((ge) => {
              let he = ["...", se()], we = ge.getValue();
              return !$(we) || !C(ge) ? he : [p([i, t(ge, he, Z)]), i];
            }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          function ie(U, Z, se) {
            let fe = U.getValue();
            if (fe.type.startsWith("JSX")) switch (fe.type) {
              case "JSXAttribute":
                return k(U, Z, se);
              case "JSXIdentifier":
                return String(fe.name);
              case "JSXNamespacedName":
                return f(":", [se("namespace"), se("name")]);
              case "JSXMemberExpression":
                return f(".", [se("object"), se("property")]);
              case "JSXSpreadAttribute":
                return Y(U, Z, se);
              case "JSXSpreadChild":
                return Y(U, Z, se);
              case "JSXExpressionContainer":
                return M(U, Z, se);
              case "JSXFragment":
              case "JSXElement":
                return V(U, Z, se);
              case "JSXOpeningElement":
                return R(U, Z, se);
              case "JSXClosingElement":
                return L(U, Z, se);
              case "JSXOpeningFragment":
              case "JSXClosingFragment":
                return Q(U, Z);
              case "JSXEmptyExpression":
                return j(U, Z);
              case "JSXText":
                throw new Error("JSXText should be handled by JSXElement");
              default:
                throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
            }
          }
          var ee = ` 
\r	`, ce = new RegExp("([" + ee + "]+)"), W = new RegExp("[^" + ee + "]"), K = (U) => U.replace(new RegExp("(?:^" + ce.source + "|" + ce.source + "$)"), "");
          function de(U) {
            if (U.children.length === 0) return true;
            if (U.children.length > 1) return false;
            let Z = U.children[0];
            return Z.type === "JSXText" && !ue(Z);
          }
          function ue(U) {
            return U.type === "JSXText" && (W.test(N(U)) || !/\n/.test(N(U)));
          }
          function Fe(U) {
            return U.type === "JSXExpressionContainer" && I(U.expression) && U.expression.value === " " && !$(U.expression);
          }
          function z(U) {
            let Z = U.getValue(), se = U.getParentNode();
            if (!se || !Z || !E(Z) || !E(se)) return false;
            let fe = se.children.indexOf(Z), ge = null;
            for (let he = fe; he > 0; he--) {
              let we = se.children[he - 1];
              if (!(we.type === "JSXText" && !ue(we))) {
                ge = we;
                break;
              }
            }
            return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && T(ge.expression);
          }
          r2.exports = { hasJsxIgnoreComment: z, printJsx: ie };
        } }), ct = te({ "src/language-js/print/misc.js"(e, r2) {
          ne();
          var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, join: a, line: n } } = qe(), { isFlowAnnotationComment: u } = Ke();
          function i(_) {
            let w = _.getValue();
            return !w.optional || w.type === "Identifier" && w === _.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
          }
          function l(_) {
            return _.getValue().definite || _.match(void 0, (w, E) => E === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
          }
          function p(_, w, E) {
            let N = _.getValue();
            return N.typeArguments ? E("typeArguments") : N.typeParameters ? E("typeParameters") : "";
          }
          function y(_, w, E) {
            let N = _.getValue();
            if (!N.typeAnnotation) return "";
            let x = _.getParentNode(), I = x.type === "DeclareFunction" && x.id === N;
            return u(w.originalText, N.typeAnnotation) ? [" /*: ", E("typeAnnotation"), " */"] : [I ? "" : ": ", E("typeAnnotation")];
          }
          function h(_, w, E) {
            return ["::", E("callee")];
          }
          function g(_, w, E) {
            let N = _.getValue();
            return t(N.modifiers) ? [a(" ", _.map(E, "modifiers")), " "] : "";
          }
          function c2(_, w, E) {
            return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || E ? [" ", w] : s([n, w]);
          }
          function f(_, w, E) {
            return ["...", E("argument"), y(_, w, E)];
          }
          function F(_, w) {
            let E = _.slice(1, -1);
            if (E.includes('"') || E.includes("'")) return _;
            let N = w.singleQuote ? "'" : '"';
            return N + E + N;
          }
          r2.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: p, printBindExpressionCallee: h, printTypeScriptModifiers: g, printTypeAnnotation: y, printRestSpread: f, adjustClause: c2, printDirective: F };
        } }), er = te({ "src/language-js/print/array.js"(e, r2) {
          ne();
          var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, hardline: n, group: u, indent: i, ifBreak: l, fill: p } } = qe(), { getLast: y, hasNewline: h } = Ue(), { shouldPrintComma: g, hasComment: c2, CommentCheckFlags: f, isNextLineEmpty: F, isNumericLiteral: _, isSignedNumericLiteral: w } = Ke(), { locStart: E } = ut(), { printOptionalToken: N, printTypeAnnotation: x } = ct();
          function I(T, m, C) {
            let o = T.getValue(), d = [], v = o.type === "TupleExpression" ? "#[" : "[", S = "]";
            if (o.elements.length === 0) c2(o, f.Dangling) ? d.push(u([v, t(T, m), a, S])) : d.push(v, S);
            else {
              let b = y(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M = Symbol("array"), R = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q, V) => {
                let j = L && L.type;
                if (j !== "ArrayExpression" && j !== "ObjectExpression") return false;
                let Y = V[Q + 1];
                if (Y && j !== Y.type) return false;
                let ie = j === "ArrayExpression" ? "elements" : "properties";
                return L[ie] && L[ie].length > 1;
              }), q = P(o, m), J = B ? k ? "," : g(m) ? q ? l(",", "", { groupId: M }) : l(",") : "" : "";
              d.push(u([v, i([a, q ? D(T, m, C, J) : [$(T, m, "elements", C), J], t(T, m, true)]), a, S], { shouldBreak: R, id: M }));
            }
            return d.push(N(T), x(T, m, C)), d;
          }
          function P(T, m) {
            return T.elements.length > 1 && T.elements.every((C) => C && (_(C) || w(C) && !c2(C.argument)) && !c2(C, f.Trailing | f.Line, (o) => !h(m.originalText, E(o), { backwards: true })));
          }
          function $(T, m, C, o) {
            let d = [], v = [];
            return T.each((S) => {
              d.push(v, u(o())), v = [",", s], S.getValue() && F(S.getValue(), m) && v.push(a);
            }, C), d;
          }
          function D(T, m, C, o) {
            let d = [];
            return T.each((v, S, b) => {
              let B = S === b.length - 1;
              d.push([C(), B ? o : ","]), B || d.push(F(v.getValue(), m) ? [n, n] : c2(b[S + 1], f.Leading | f.Line) ? n : s);
            }, "elements"), p(d);
          }
          r2.exports = { printArray: I, printArrayItems: $, isConciselyPrintedArray: P };
        } }), Ao = te({ "src/language-js/print/call-arguments.js"(e, r2) {
          ne();
          var { printDanglingComments: t } = et(), { getLast: s, getPenultimate: a } = Ue(), { getFunctionParameters: n, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: p, isLongCurriedCallExpression: y, shouldPrintComma: h, getCallArguments: g, iterateCallArgumentsPath: c2, isNextLineEmpty: f, isCallExpression: F, isStringLiteral: _, isObjectProperty: w, isTSTypeExpression: E } = Ke(), { builders: { line: N, hardline: x, softline: I, group: P, indent: $, conditionalGroup: D, ifBreak: T, breakParent: m }, utils: { willBreak: C } } = qe(), { ArgExpansionBailout: o } = Qt(), { isConciselyPrintedArray: d } = er();
          function v(q, J, L) {
            let Q = q.getValue(), V = Q.type === "ImportExpression", j = g(Q);
            if (j.length === 0) return ["(", t(q, J, true), ")"];
            if (k(j)) return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
            let Y = false, ie = false, ee = j.length - 1, ce = [];
            c2(q, (z, U) => {
              let Z = z.getNode(), se = [L()];
              U === ee || (f(Z, J) ? (U === 0 && (ie = true), Y = true, se.push(",", x, x)) : se.push(",", N)), ce.push(se);
            });
            let W = !(V || Q.callee && Q.callee.type === "Import") && h(J, "all") ? "," : "";
            function K() {
              return P(["(", $([N, ...ce]), W, N, ")"], { shouldBreak: true });
            }
            if (Y || q.getParentNode().type !== "Decorator" && l(j)) return K();
            let de = B(j), ue = b(j, J);
            if (de || ue) {
              if (de ? ce.slice(1).some(C) : ce.slice(0, -1).some(C)) return K();
              let z = [];
              try {
                q.try(() => {
                  c2(q, (U, Z) => {
                    de && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce.length > 1 ? "," : "", ie ? x : N, ie ? x : ""], ...ce.slice(1)]), ue && Z === ee && (z = [...ce.slice(0, -1), L([], { expandLastArg: true })]);
                  });
                });
              } catch (U) {
                if (U instanceof o) return K();
                throw U;
              }
              return [ce.some(C) ? m : "", D([["(", ...z, ")"], de ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce.slice(0, -1), P(s(z), { shouldBreak: true }), ")"], K()])];
            }
            let Fe = ["(", $([I, ...ce]), T(W), I, ")"];
            return y(q) ? Fe : P(Fe, { shouldBreak: ce.some(C) || Y });
          }
          function S(q) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return q.type === "ObjectExpression" && (q.properties.length > 0 || u(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u(q)) || q.type === "TSTypeAssertion" && S(q.expression) || E(q) && S(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || M(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && S(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J && (F(q.body) || q.body.type === "ConditionalExpression") || p(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
          }
          function b(q, J) {
            let L = s(q), Q = a(q);
            return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q || Q.type !== L.type) && (q.length !== 2 || Q.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q.length > 1 && L.type === "ArrayExpression" && d(L, J));
          }
          function B(q) {
            if (q.length !== 2) return false;
            let [J, L] = q;
            return J.type === "ModuleExpression" && R(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
          }
          function k(q) {
            return q.length === 2 && q[0].type === "ArrowFunctionExpression" && n(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J) => u(J));
          }
          function M(q) {
            return q.type === "BlockStatement" && (q.body.some((J) => J.type !== "EmptyStatement") || u(q, i.Dangling));
          }
          function R(q) {
            return q.type === "ObjectExpression" && q.properties.length === 1 && w(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && _(q.properties[0].value) && q.properties[0].value.value === "module";
          }
          r2.exports = v;
        } }), So = te({ "src/language-js/print/member.js"(e, r2) {
          ne();
          var { builders: { softline: t, group: s, indent: a, label: n } } = qe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke(), { printOptionalToken: p } = ct();
          function y(g, c2, f) {
            let F = g.getValue(), _ = g.getParentNode(), w, E = 0;
            do
              w = g.getParentNode(E), E++;
            while (w && (i(w) || w.type === "TSNonNullExpression"));
            let N = f("object"), x = h(g, c2, f), I = w && (w.type === "NewExpression" || w.type === "BindExpression" || w.type === "AssignmentExpression" && w.left.type !== "Identifier") || F.computed || F.object.type === "Identifier" && F.property.type === "Identifier" && !i(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(F.object) && F.object.arguments.length > 0 || F.object.type === "TSNonNullExpression" && l(F.object.expression) && F.object.expression.arguments.length > 0 || N.label === "member-chain");
            return n(N.label === "member-chain" ? "member-chain" : "member", [N, I ? x : s(a([t, x]))]);
          }
          function h(g, c2, f) {
            let F = f("property"), _ = g.getValue(), w = p(g);
            return _.computed ? !_.property || u(_.property) ? [w, "[", F, "]"] : s([w, "[", a([t, F]), t, "]"]) : [w, ".", F];
          }
          r2.exports = { printMemberExpression: y, printMemberLookup: h };
        } }), md = te({ "src/language-js/print/member-chain.js"(e, r2) {
          ne();
          var { printComments: t } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: n } = Ue(), u = qt(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: p, isLongCurriedCallExpression: y, isMemberish: h, isNumericLiteral: g, isSimpleCallArgument: c2, hasComment: f, CommentCheckFlags: F, isNextLineEmpty: _ } = Ke(), { locEnd: w } = ut(), { builders: { join: E, hardline: N, group: x, indent: I, conditionalGroup: P, breakParent: $, label: D }, utils: { willBreak: T } } = qe(), m = Ao(), { printMemberLookup: C } = So(), { printOptionalToken: o, printFunctionTypeParameters: d, printBindExpressionCallee: v } = ct();
          function S(b, B, k) {
            let M = b.getParentNode(), R = !M || M.type === "ExpressionStatement", q = [];
            function J(Ne) {
              let { originalText: Pe } = B, oe = n(Pe, Ne, w);
              return Pe.charAt(oe) === ")" ? oe !== false && a(Pe, oe + 1) : _(Ne, B);
            }
            function L(Ne) {
              let Pe = Ne.getValue();
              i(Pe) && (h(Pe.callee) || i(Pe.callee)) ? (q.unshift({ node: Pe, printed: [t(Ne, [o(Ne), d(Ne, B, k), m(Ne, B, k)], B), J(Pe) ? N : ""] }), Ne.call((oe) => L(oe), "callee")) : h(Pe) ? (q.unshift({ node: Pe, needsParens: u(Ne, B), printed: t(Ne, l(Pe) ? C(Ne, B, k) : v(Ne, B, k), B) }), Ne.call((oe) => L(oe), "object")) : Pe.type === "TSNonNullExpression" ? (q.unshift({ node: Pe, printed: t(Ne, "!", B) }), Ne.call((oe) => L(oe), "expression")) : q.unshift({ node: Pe, printed: k() });
            }
            let Q = b.getValue();
            q.unshift({ node: Q, printed: [o(b), d(b, B, k), m(b, B, k)] }), Q.callee && b.call((Ne) => L(Ne), "callee");
            let V = [], j = [q[0]], Y = 1;
            for (; Y < q.length && (q[Y].node.type === "TSNonNullExpression" || i(q[Y].node) || l(q[Y].node) && q[Y].node.computed && g(q[Y].node.property)); ++Y) j.push(q[Y]);
            if (!i(q[0].node)) for (; Y + 1 < q.length && (h(q[Y].node) && h(q[Y + 1].node)); ++Y) j.push(q[Y]);
            V.push(j), j = [];
            let ie = false;
            for (; Y < q.length; ++Y) {
              if (ie && h(q[Y].node)) {
                if (q[Y].node.computed && g(q[Y].node.property)) {
                  j.push(q[Y]);
                  continue;
                }
                V.push(j), j = [], ie = false;
              }
              (i(q[Y].node) || q[Y].node.type === "ImportExpression") && (ie = true), j.push(q[Y]), f(q[Y].node, F.Trailing) && (V.push(j), j = [], ie = false);
            }
            j.length > 0 && V.push(j);
            function ee(Ne) {
              return /^[A-Z]|^[$_]+$/.test(Ne);
            }
            function ce(Ne) {
              return Ne.length <= B.tabWidth;
            }
            function W(Ne) {
              let Pe = Ne[1].length > 0 && Ne[1][0].node.computed;
              if (Ne[0].length === 1) {
                let H = Ne[0][0].node;
                return H.type === "ThisExpression" || H.type === "Identifier" && (ee(H.name) || R && ce(H.name) || Pe);
              }
              let oe = s(Ne[0]).node;
              return l(oe) && oe.property.type === "Identifier" && (ee(oe.property.name) || Pe);
            }
            let K = V.length >= 2 && !f(V[1][0].node) && W(V);
            function de(Ne) {
              let Pe = Ne.map((oe) => oe.printed);
              return Ne.length > 0 && s(Ne).needsParens ? ["(", ...Pe, ")"] : Pe;
            }
            function ue(Ne) {
              return Ne.length === 0 ? "" : I(x([N, E(N, Ne.map(de))]));
            }
            let Fe = V.map(de), z = Fe, U = K ? 3 : 2, Z = V.flat(), se = Z.slice(1, -1).some((Ne) => f(Ne.node, F.Leading)) || Z.slice(0, -1).some((Ne) => f(Ne.node, F.Trailing)) || V[U] && f(V[U][0].node, F.Leading);
            if (V.length <= U && !se) return y(b) ? z : x(z);
            let fe = s(V[K ? 1 : 0]).node, ge = !i(fe) && J(fe), he = [de(V[0]), K ? V.slice(1, 2).map(de) : "", ge ? N : "", ue(V.slice(K ? 2 : 1))], we = q.map((Ne) => {
              let { node: Pe } = Ne;
              return Pe;
            }).filter(i);
            function ke() {
              let Ne = s(s(V)).node, Pe = s(Fe);
              return i(Ne) && T(Pe) && we.slice(0, -1).some((oe) => oe.arguments.some(p));
            }
            let Re;
            return se || we.length > 2 && we.some((Ne) => !Ne.arguments.every((Pe) => c2(Pe, 0))) || Fe.slice(0, -1).some(T) || ke() ? Re = x(he) : Re = [T(z) || ge ? $ : "", P([z, he])], D("member-chain", Re);
          }
          r2.exports = S;
        } }), xo = te({ "src/language-js/print/call-expression.js"(e, r2) {
          ne();
          var { builders: { join: t, group: s } } = qe(), a = qt(), { getCallArguments: n, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: p, isTemplateOnItsOwnLine: y, isTestCall: h, iterateCallArgumentsPath: g } = Ke(), c2 = md(), f = Ao(), { printOptionalToken: F, printFunctionTypeParameters: _ } = ct();
          function w(N, x, I) {
            let P = N.getValue(), $ = N.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m = F(N), C = n(P);
            if (C.length > 0 && (!T && !D && E(P, $) || C.length === 1 && y(C[0], x.originalText) || !D && h(P, $))) {
              let v = [];
              return g(N, () => {
                v.push(I());
              }), [D ? "new " : "", I("callee"), m, _(N, x, I), "(", t(", ", v), ")"];
            }
            let o = (x.parser === "babel" || x.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
            if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N.call((v) => a(v, x), "callee")) return c2(N, x, I);
            let d = [D ? "new " : "", T ? "import" : I("callee"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N, x, I), f(N, x, I)];
            return T || i(P.callee) ? s(d) : d;
          }
          function E(N, x) {
            if (N.callee.type !== "Identifier") return false;
            if (N.callee.name === "require") return true;
            if (N.callee.name === "define") {
              let I = n(N);
              return x.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && p(I[0]) && I[1].type === "ArrayExpression");
            }
            return false;
          }
          r2.exports = { printCallExpression: w };
        } }), tr = te({ "src/language-js/print/assignment.js"(e, r2) {
          ne();
          var { isNonEmptyArray: t, getStringWidth: s } = Ue(), { builders: { line: a, group: n, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: p, willBreak: y, canBreak: h } } = qe(), { hasLeadingOwnLineComment: g, isBinaryish: c2, isStringLiteral: f, isLiteral: F, isNumericLiteral: _, isCallExpression: w, isMemberExpression: E, getCallArguments: N, rawText: x, hasComment: I, isSignedNumericLiteral: P, isObjectProperty: $ } = Ke(), { shouldInlineLogicalExpression: D } = ru(), { printCallExpression: T } = xo();
          function m(W, K, de, ue, Fe, z) {
            let U = d(W, K, de, ue, z), Z = de(z, { assignmentLayout: U });
            switch (U) {
              case "break-after-operator":
                return n([n(ue), Fe, n(u([a, Z]))]);
              case "never-break-after-operator":
                return n([n(ue), Fe, " ", Z]);
              case "fluid": {
                let se = Symbol("assignment");
                return n([n(ue), Fe, n(u(a), { id: se }), l, i(Z, { groupId: se })]);
              }
              case "break-lhs":
                return n([ue, Fe, " ", n(Z)]);
              case "chain":
                return [n(ue), Fe, a, Z];
              case "chain-tail":
                return [n(ue), Fe, u([a, Z])];
              case "chain-tail-arrow-chain":
                return [n(ue), Fe, Z];
              case "only-left":
                return ue;
            }
          }
          function C(W, K, de) {
            let ue = W.getValue();
            return m(W, K, de, de("left"), [" ", ue.operator], "right");
          }
          function o(W, K, de) {
            return m(W, K, de, de("id"), " =", "init");
          }
          function d(W, K, de, ue, Fe) {
            let z = W.getValue(), U = z[Fe];
            if (!U) return "only-left";
            let Z = !b(U);
            if (W.match(b, B, (he) => !Z || he.type !== "ExpressionStatement" && he.type !== "VariableDeclaration")) return Z ? U.type === "ArrowFunctionExpression" && U.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!Z && b(U.right) || g(K.originalText, U)) return "break-after-operator";
            if (U.type === "CallExpression" && U.callee.name === "require" || K.parser === "json5" || K.parser === "json") return "never-break-after-operator";
            if (S(z) || k(z) || q(z) || J(z) && h(ue)) return "break-lhs";
            let ge = ie(z, ue, K);
            return W.call(() => v(W, K, de, ge), Fe) ? "break-after-operator" : ge || U.type === "TemplateLiteral" || U.type === "TaggedTemplateExpression" || U.type === "BooleanLiteral" || _(U) || U.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          function v(W, K, de, ue) {
            let Fe = W.getValue();
            if (c2(Fe) && !D(Fe)) return true;
            switch (Fe.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                let { test: Z } = Fe;
                return c2(Z) && !D(Z);
              }
              case "ClassExpression":
                return t(Fe.decorators);
            }
            if (ue) return false;
            let z = Fe, U = [];
            for (; ; ) if (z.type === "UnaryExpression") z = z.argument, U.push("argument");
            else if (z.type === "TSNonNullExpression") z = z.expression, U.push("expression");
            else break;
            return !!(f(z) || W.call(() => V(W, K, de), ...U));
          }
          function S(W) {
            if (B(W)) {
              let K = W.left || W.id;
              return K.type === "ObjectPattern" && K.properties.length > 2 && K.properties.some((de) => $(de) && (!de.shorthand || de.value && de.value.type === "AssignmentPattern"));
            }
            return false;
          }
          function b(W) {
            return W.type === "AssignmentExpression";
          }
          function B(W) {
            return b(W) || W.type === "VariableDeclarator";
          }
          function k(W) {
            let K = M(W);
            if (t(K)) {
              let de = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (K.length > 1 && K.some((ue) => ue[de] || ue.default)) return true;
            }
            return false;
          }
          function M(W) {
            return R(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function R(W) {
            return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
          }
          function q(W) {
            if (W.type !== "VariableDeclarator") return false;
            let { typeAnnotation: K } = W.id;
            if (!K || !K.typeAnnotation) return false;
            let de = L(K.typeAnnotation);
            return t(de) && de.length > 1 && de.some((ue) => t(L(ue)) || ue.type === "TSConditionalType");
          }
          function J(W) {
            return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
          }
          function L(W) {
            return Q(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function Q(W) {
            return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
          }
          function V(W, K, de) {
            let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe = W.getValue(), z = () => V(W, K, de, true);
            if (Fe.type === "TSNonNullExpression") return W.call(z, "expression");
            if (w(Fe)) {
              if (T(W, K, de).label === "member-chain") return false;
              let Z = N(Fe);
              return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K)) || ee(Fe, de) ? false : W.call(z, "callee");
            }
            return E(Fe) ? W.call(z, "object") : ue && (Fe.type === "Identifier" || Fe.type === "ThisExpression");
          }
          var j = 0.25;
          function Y(W, K) {
            let { printWidth: de } = K;
            if (I(W)) return false;
            let ue = de * j;
            if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue || P(W) && !I(W.argument)) return true;
            let Fe = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
            return Fe ? Fe.length <= ue : f(W) ? x(W).length <= ue : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue && !W.quasis[0].value.raw.includes(`
`) : F(W);
          }
          function ie(W, K, de) {
            if (!$(W)) return false;
            K = p(K);
            let ue = 3;
            return typeof K == "string" && s(K) < de.tabWidth + ue;
          }
          function ee(W, K) {
            let de = ce(W);
            if (t(de)) {
              if (de.length > 1) return true;
              if (de.length === 1) {
                let Fe = de[0];
                if (Fe.type === "TSUnionType" || Fe.type === "UnionTypeAnnotation" || Fe.type === "TSIntersectionType" || Fe.type === "IntersectionTypeAnnotation" || Fe.type === "TSTypeLiteral" || Fe.type === "ObjectTypeAnnotation") return true;
              }
              let ue = W.typeParameters ? "typeParameters" : "typeArguments";
              if (y(K(ue))) return true;
            }
            return false;
          }
          function ce(W) {
            return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
          }
          r2.exports = { printVariableDeclarator: o, printAssignmentExpression: C, printAssignment: m, isArrowFunctionVariableDeclarator: J };
        } }), Lr = te({ "src/language-js/print/function-parameters.js"(e, r2) {
          ne();
          var { getNextNonSpaceNonCommentCharacter: t } = Ue(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p }, utils: { removeLines: y, willBreak: h } } = qe(), { getFunctionParameters: g, iterateFunctionParametersPath: c2, isSimpleType: f, isTestCall: F, isTypeAnnotationAFunction: _, isObjectType: w, isObjectTypePropertyAFunction: E, hasRestParameter: N, shouldPrintComma: x, hasComment: I, isNextLineEmpty: P } = Ke(), { locEnd: $ } = ut(), { ArgExpansionBailout: D } = Qt(), { printFunctionTypeParameters: T } = ct();
          function m(v, S, b, B, k) {
            let M = v.getValue(), R = g(M), q = k ? T(v, b, S) : "";
            if (R.length === 0) return [q, "(", s(v, b, true, (ie) => t(b.originalText, ie, $) === ")"), ")"];
            let J = v.getParentNode(), L = F(J), Q = C(M), V = [];
            if (c2(v, (ie, ee) => {
              let ce = ee === R.length - 1;
              ce && M.rest && V.push("..."), V.push(S()), !ce && (V.push(","), L || Q ? V.push(" ") : P(R[ee], b) ? V.push(n, n) : V.push(a));
            }), B) {
              if (h(q) || h(V)) throw new D();
              return i([y(q), "(", y(V), ")"]);
            }
            let j = R.every((ie) => !ie.decorators);
            return Q && j ? [q, "(", ...V, ")"] : L ? [q, "(", ...V, ")"] : (E(J) || _(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === M) && R.length === 1 && R[0].name === null && M.this !== R[0] && R[0].typeAnnotation && M.typeParameters === null && f(R[0].typeAnnotation) && !M.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l([u, ...V]), p(!N(M) && x(b, "all") ? "," : ""), u, ")"];
          }
          function C(v) {
            if (!v) return false;
            let S = g(v);
            if (S.length !== 1) return false;
            let [b] = S;
            return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
          }
          function o(v) {
            let S;
            return v.returnType ? (S = v.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v.typeAnnotation && (S = v.typeAnnotation), S;
          }
          function d(v, S) {
            let b = o(v);
            if (!b) return false;
            let B = v.typeParameters && v.typeParameters.params;
            if (B) {
              if (B.length > 1) return false;
              if (B.length === 1) {
                let k = B[0];
                if (k.constraint || k.default) return false;
              }
            }
            return g(v).length === 1 && (w(b) || h(S));
          }
          r2.exports = { printFunctionParameters: m, shouldHugFunctionParameters: C, shouldGroupFunctionParameters: d };
        } }), Or = te({ "src/language-js/print/type-annotation.js"(e, r2) {
          ne();
          var { printComments: t, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ue(), { builders: { group: n, join: u, line: i, softline: l, indent: p, align: y, ifBreak: h } } = qe(), g = qt(), { locStart: c2 } = ut(), { isSimpleType: f, isObjectType: F, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w, shouldPrintComma: E } = Ke(), { printAssignment: N } = tr(), { printFunctionParameters: x, shouldGroupFunctionParameters: I } = Lr(), { printArrayItems: P } = er();
          function $(b) {
            if (f(b) || F(b)) return true;
            if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
              let B = b.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, k = b.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
              if (b.types.length - 1 === B && k) return true;
            }
            return false;
          }
          function D(b, B, k) {
            let M = B.semi ? ";" : "", R = b.getValue(), q = [];
            return q.push("opaque type ", k("id"), k("typeParameters")), R.supertype && q.push(": ", k("supertype")), R.impltype && q.push(" = ", k("impltype")), q.push(M), q;
          }
          function T(b, B, k) {
            let M = B.semi ? ";" : "", R = b.getValue(), q = [];
            R.declare && q.push("declare "), q.push("type ", k("id"), k("typeParameters"));
            let J = R.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [N(b, B, k, q, " =", J), M];
          }
          function m(b, B, k) {
            let M = b.getValue(), R = b.map(k, "types"), q = [], J = false;
            for (let L = 0; L < R.length; ++L) L === 0 ? q.push(R[L]) : F(M.types[L - 1]) && F(M.types[L]) ? q.push([" & ", J ? p(R[L]) : R[L]]) : !F(M.types[L - 1]) && !F(M.types[L]) ? q.push(p([" &", i, R[L]])) : (L > 1 && (J = true), q.push(" & ", L > 1 ? p(R[L]) : R[L]));
            return n(q);
          }
          function C(b, B, k) {
            let M = b.getValue(), R = b.getParentNode(), q = R.type !== "TypeParameterInstantiation" && R.type !== "TSTypeParameterInstantiation" && R.type !== "GenericTypeAnnotation" && R.type !== "TSTypeReference" && R.type !== "TSTypeAssertion" && R.type !== "TupleTypeAnnotation" && R.type !== "TSTupleType" && !(R.type === "FunctionTypeParam" && !R.name && b.getParentNode(1).this !== R) && !((R.type === "TypeAlias" || R.type === "VariableDeclarator" || R.type === "TSTypeAliasDeclaration") && _(B.originalText, M)), J = $(M), L = b.map((j) => {
              let Y = k();
              return J || (Y = y(2, Y)), t(j, Y, B);
            }, "types");
            if (J) return u(" | ", L);
            let Q = q && !_(B.originalText, M), V = [h([Q ? i : "", "| "]), u([i, "| "], L)];
            return g(b, B) ? n([p(V), l]) : R.type === "TupleTypeAnnotation" && R.types.length > 1 || R.type === "TSTupleType" && R.elementTypes.length > 1 ? n([p([h(["(", l]), V]), l, h(")")]) : n(q ? p(V) : V);
          }
          function o(b, B, k) {
            let M = b.getValue(), R = [], q = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Q = M.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && c2(q) === c2(M) || q.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), j = V && Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
            w(q) && (Q = true, V = true), j && R.push("(");
            let Y = x(b, k, B, false, true), ie = M.returnType || M.predicate || M.typeAnnotation ? [Q ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee = I(M, ie);
            return R.push(ee ? n(Y) : Y), ie && R.push(ie), j && R.push(")"), n(R);
          }
          function d(b, B, k) {
            let M = b.getValue(), R = M.type === "TSTupleType" ? "elementTypes" : "types", q = M[R], J = a(q), L = J ? l : "";
            return n(["[", p([L, P(b, B, R, k)]), h(J && E(B, "all") ? "," : ""), s(b, B, true), L, "]"]);
          }
          function v(b, B, k) {
            let M = b.getValue(), R = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
            return [k("objectType"), R, k("indexType"), "]"];
          }
          function S(b, B, k) {
            let M = b.getValue();
            return [M.postfix ? "" : k, B("typeAnnotation"), M.postfix ? k : ""];
          }
          r2.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m, printUnionType: C, printFunctionType: o, printTupleType: d, printIndexedAccessType: v, shouldHugType: $, printJSDocType: S };
        } }), jr = te({ "src/language-js/print/type-parameters.js"(e, r2) {
          ne();
          var { printDanglingComments: t } = et(), { builders: { join: s, line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p } } = qe(), { isTestCall: y, hasComment: h, CommentCheckFlags: g, isTSXFile: c2, shouldPrintComma: f, getFunctionParameters: F, isObjectType: _, getTypeScriptMappedTypeModifier: w } = Ke(), { createGroupIdMapper: E } = Ue(), { shouldHugType: N } = Or(), { isArrowFunctionVariableDeclarator: x } = tr(), I = E("typeParameters");
          function P(T, m, C, o) {
            let d = T.getValue();
            if (!d[o]) return "";
            if (!Array.isArray(d[o])) return C(o);
            let v = T.getNode(2), S = v && y(v), b = T.match((M) => !(M[o].length === 1 && _(M[o][0])), void 0, (M, R) => R === "typeAnnotation", (M) => M.type === "Identifier", x);
            if (d[o].length === 0 || !b && (S || d[o].length === 1 && (d[o][0].type === "NullableTypeAnnotation" || N(d[o][0])))) return ["<", s(", ", T.map(C, o)), $(T, m), ">"];
            let k = d.type === "TSTypeParameterInstantiation" ? "" : F(d).length === 1 && c2(m) && !d[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f(m, "all") ? p(",") : "";
            return i(["<", l([u, s([",", a], T.map(C, o))]), k, u, ">"], { id: I(d) });
          }
          function $(T, m) {
            let C = T.getValue();
            if (!h(C, g.Dangling)) return "";
            let o = !h(C, g.Line), d = t(T, m, o);
            return o ? d : [d, n];
          }
          function D(T, m, C) {
            let o = T.getValue(), d = [o.type === "TSTypeParameter" && o.const ? "const " : ""], v = T.getParentNode();
            return v.type === "TSMappedType" ? (v.readonly && d.push(w(v.readonly, "readonly"), " "), d.push("[", C("name")), o.constraint && d.push(" in ", C("constraint")), v.nameType && d.push(" as ", T.callParent(() => C("nameType"))), d.push("]"), d) : (o.variance && d.push(C("variance")), o.in && d.push("in "), o.out && d.push("out "), d.push(C("name")), o.bound && d.push(": ", C("bound")), o.constraint && d.push(" extends ", C("constraint")), o.default && d.push(" = ", C("default")), d);
          }
          r2.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I };
        } }), rr = te({ "src/language-js/print/property.js"(e, r2) {
          ne();
          var { printComments: t } = et(), { printString: s, printNumber: a } = Ue(), { isNumericLiteral: n, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: p } = Ke(), { printAssignment: y } = tr(), h = /* @__PURE__ */ new WeakMap();
          function g(f, F, _) {
            let w = f.getNode();
            if (w.computed) return ["[", _("key"), "]"];
            let E = f.getParentNode(), { key: N } = w;
            if (F.quoteProps === "consistent" && !h.has(E)) {
              let x = (E.properties || E.body || E.members).some((I) => !I.computed && I.key && i(I.key) && !l(I, F));
              h.set(E, x);
            }
            if ((N.type === "Identifier" || n(N) && u(a(p(N))) && String(N.value) === a(p(N)) && !(F.parser === "typescript" || F.parser === "babel-ts")) && (F.parser === "json" || F.quoteProps === "consistent" && h.get(E))) {
              let x = s(JSON.stringify(N.type === "Identifier" ? N.name : N.value.toString()), F);
              return f.call((I) => t(I, x, F), "key");
            }
            return l(w, F) && (F.quoteProps === "as-needed" || F.quoteProps === "consistent" && !h.get(E)) ? f.call((x) => t(x, /^\d/.test(N.value) ? a(N.value) : N.value, F), "key") : _("key");
          }
          function c2(f, F, _) {
            return f.getValue().shorthand ? _("value") : y(f, F, _, g(f, F, _), ":", "value");
          }
          r2.exports = { printProperty: c2, printPropertyKey: g };
        } }), qr = te({ "src/language-js/print/function.js"(e, r2) {
          ne();
          var t = Zt(), { printDanglingComments: s, printCommentsSeparately: a } = et(), n = lt(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue(), { builders: { line: i, softline: l, group: p, indent: y, ifBreak: h, hardline: g, join: c2, indentIfBreak: f }, utils: { removeLines: F, willBreak: _ } } = qe(), { ArgExpansionBailout: w } = Qt(), { getFunctionParameters: E, hasLeadingOwnLineComment: N, isFlowAnnotationComment: x, isJsxNode: I, isTemplateOnItsOwnLine: P, shouldPrintComma: $, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m, hasComment: C, getComments: o, CommentCheckFlags: d, isCallLikeExpression: v, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke(), { locEnd: M } = ut(), { printFunctionParameters: R, shouldGroupFunctionParameters: q } = Lr(), { printPropertyKey: J } = rr(), { printFunctionTypeParameters: L } = ct();
          function Q(U, Z, se, fe) {
            let ge = U.getValue(), he = false;
            if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
              let Pe = U.getParentNode();
              S(Pe) && b(Pe).length > 1 && (he = true);
            }
            let we = [];
            ge.type === "TSDeclareFunction" && ge.declare && we.push("declare "), ge.async && we.push("async "), ge.generator ? we.push("function* ") : we.push("function "), ge.id && we.push(Z("id"));
            let ke = R(U, Z, se, he), Re = K(U, Z, se), Ne = q(ge, Re);
            return we.push(L(U, se, Z), p([Ne ? p(ke) : ke, Re]), ge.body ? " " : "", Z("body")), se.semi && (ge.declare || !ge.body) && we.push(";"), we;
          }
          function V(U, Z, se) {
            let fe = U.getNode(), { kind: ge } = fe, he = fe.value || fe, we = [];
            return !ge || ge === "init" || ge === "method" || ge === "constructor" ? he.async && we.push("async ") : (t.ok(ge === "get" || ge === "set"), we.push(ge, " ")), he.generator && we.push("*"), we.push(J(U, Z, se), fe.optional || fe.key.optional ? "?" : ""), fe === he ? we.push(j(U, Z, se)) : he.type === "FunctionExpression" ? we.push(U.call((ke) => j(ke, Z, se), "value")) : we.push(se("value")), we;
          }
          function j(U, Z, se) {
            let fe = U.getNode(), ge = R(U, se, Z), he = K(U, se, Z), we = q(fe, he), ke = [L(U, Z, se), p([we ? p(ge) : ge, he])];
            return fe.body ? ke.push(" ", se("body")) : ke.push(Z.semi ? ";" : ""), ke;
          }
          function Y(U, Z, se, fe) {
            let ge = U.getValue(), he = [];
            if (ge.async && he.push("async "), W(U, Z)) he.push(se(["params", 0]));
            else {
              let ke = fe && (fe.expandLastArg || fe.expandFirstArg), Re = K(U, se, Z);
              if (ke) {
                if (_(Re)) throw new w();
                Re = p(F(Re));
              }
              he.push(p([R(U, se, Z, ke, true), Re]));
            }
            let we = s(U, Z, true, (ke) => {
              let Re = u(Z.originalText, ke, M);
              return Re !== false && Z.originalText.slice(Re, Re + 2) === "=>";
            });
            return we && he.push(" ", we), he;
          }
          function ie(U, Z, se, fe, ge, he) {
            let we = U.getName(), ke = U.getParentNode(), Re = v(ke) && we === "callee", Ne = Boolean(Z && Z.assignmentLayout), Pe = he.body.type !== "BlockStatement" && he.body.type !== "ObjectExpression" && he.body.type !== "SequenceExpression", oe = Re && Pe || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
            return he.body.type === "SequenceExpression" && (ge = p(["(", y([l, ge]), l, ")"])), p([p(y([Re || Ne ? l : "", p(c2([" =>", i], se), { shouldBreak: fe })]), { id: H, shouldBreak: oe }), " =>", f(Pe ? y([i, ge]) : [" ", ge], { groupId: H }), Re ? h(l, "", { groupId: H }) : ""]);
          }
          function ee(U, Z, se, fe) {
            let ge = U.getValue(), he = [], we = [], ke = false;
            if ((function H() {
              let pe = Y(U, Z, se, fe);
              if (he.length === 0) he.push(pe);
              else {
                let { leading: X, trailing: le } = a(U, Z);
                he.push([X, pe]), we.unshift(le);
              }
              ke = ke || ge.returnType && E(ge).length > 0 || ge.typeParameters || E(ge).some((X) => X.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? we.unshift(se("body", fe)) : (ge = ge.body, U.call(H, "body"));
            })(), he.length > 1) return ie(U, fe, he, ke, we, ge);
            let Re = he;
            if (Re.push(" =>"), !N(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression")) return p([...Re, " ", we]);
            if (ge.body.type === "SequenceExpression") return p([...Re, p([" (", y([l, we]), l, ")"])]);
            let Ne = (fe && fe.expandLastArg || U.getParentNode().type === "JSXExpressionContainer") && !C(ge), Pe = fe && fe.expandLastArg && $(Z, "all"), oe = ge.body.type === "ConditionalExpression" && !D(ge.body, (H) => H.type === "ObjectExpression");
            return p([...Re, p([y([i, oe ? h("", "(") : "", we, oe ? h("", ")") : ""]), Ne ? [h(Pe ? "," : ""), l] : ""])]);
          }
          function ce(U) {
            let Z = E(U);
            return Z.length === 1 && !U.typeParameters && !C(U, d.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U.predicate && !U.returnType;
          }
          function W(U, Z) {
            if (Z.arrowParens === "always") return false;
            if (Z.arrowParens === "avoid") {
              let se = U.getValue();
              return ce(se);
            }
            return false;
          }
          function K(U, Z, se) {
            let fe = U.getValue(), ge = Z("returnType");
            if (fe.returnType && x(se.originalText, fe.returnType)) return [" /*: ", ge, " */"];
            let he = [ge];
            return fe.returnType && fe.returnType.typeAnnotation && he.unshift(": "), fe.predicate && he.push(fe.returnType ? " " : ": ", Z("predicate")), he;
          }
          function de(U, Z, se) {
            let fe = U.getValue(), ge = Z.semi ? ";" : "", he = [];
            fe.argument && (z(Z, fe.argument) ? he.push([" (", y([g, se("argument")]), g, ")"]) : T(fe.argument) || fe.argument.type === "SequenceExpression" ? he.push(p([h(" (", " "), y([l, se("argument")]), l, h(")")])) : he.push(" ", se("argument")));
            let we = o(fe), ke = n(we), Re = ke && m(ke);
            return Re && he.push(ge), C(fe, d.Dangling) && he.push(" ", s(U, Z, true)), Re || he.push(ge), he;
          }
          function ue(U, Z, se) {
            return ["return", de(U, Z, se)];
          }
          function Fe(U, Z, se) {
            return ["throw", de(U, Z, se)];
          }
          function z(U, Z) {
            if (N(U.originalText, Z)) return true;
            if (B(Z)) {
              let se = Z, fe;
              for (; fe = k(se); ) if (se = fe, N(U.originalText, se)) return true;
            }
            return false;
          }
          r2.exports = { printFunction: Q, printArrowFunction: ee, printMethod: V, printReturnStatement: ue, printThrowStatement: Fe, printMethodInternal: j, shouldPrintParamsWithoutParens: W };
        } }), nu = te({ "src/language-js/print/decorators.js"(e, r2) {
          ne();
          var { isNonEmptyArray: t, hasNewline: s } = Ue(), { builders: { line: a, hardline: n, join: u, breakParent: i, group: l } } = qe(), { locStart: p, locEnd: y } = ut(), { getParentExportDeclaration: h } = Ke();
          function g(w, E, N) {
            let x = w.getValue();
            return l([u(a, w.map(N, "decorators")), F(x, E) ? n : a]);
          }
          function c2(w, E, N) {
            return [u(n, w.map(N, "declaration", "decorators")), n];
          }
          function f(w, E, N) {
            let x = w.getValue(), { decorators: I } = x;
            if (!t(I) || _(w.getParentNode())) return;
            let P = x.type === "ClassExpression" || x.type === "ClassDeclaration" || F(x, E);
            return [h(w) ? n : P ? i : "", u(a, w.map(N, "decorators")), a];
          }
          function F(w, E) {
            return w.decorators.some((N) => s(E.originalText, y(N)));
          }
          function _(w) {
            if (w.type !== "ExportDefaultDeclaration" && w.type !== "ExportNamedDeclaration" && w.type !== "DeclareExportDeclaration") return false;
            let E = w.declaration && w.declaration.decorators;
            return t(E) && p(w) === p(E[0]);
          }
          r2.exports = { printDecorators: f, printClassMemberDecorators: g, printDecoratorsBeforeExport: c2, hasDecoratorsBeforeExport: _ };
        } }), nr = te({ "src/language-js/print/class.js"(e, r2) {
          ne();
          var { isNonEmptyArray: t, createGroupIdMapper: s } = Ue(), { printComments: a, printDanglingComments: n } = et(), { builders: { join: u, line: i, hardline: l, softline: p, group: y, indent: h, ifBreak: g } } = qe(), { hasComment: c2, CommentCheckFlags: f } = Ke(), { getTypeParametersGroupId: F } = jr(), { printMethod: _ } = qr(), { printOptionalToken: w, printTypeAnnotation: E, printDefiniteToken: N } = ct(), { printPropertyKey: x } = rr(), { printAssignment: I } = tr(), { printClassMemberDecorators: P } = nu();
          function $(b, B, k) {
            let M = b.getValue(), R = [];
            M.declare && R.push("declare "), M.abstract && R.push("abstract "), R.push("class");
            let q = M.id && c2(M.id, f.Trailing) || M.typeParameters && c2(M.typeParameters, f.Trailing) || M.superClass && c2(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements), J = [], L = [];
            if (M.id && J.push(" ", k("id")), J.push(k("typeParameters")), M.superClass) {
              let Q = [d(b, B, k), k("superTypeParameters")], V = b.call((j) => ["extends ", a(j, Q, B)], "superClass");
              q ? L.push(i, y(V)) : L.push(" ", V);
            } else L.push(o(b, B, k, "extends"));
            if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q) {
              let Q;
              C(M) ? Q = [...J, h(L)] : Q = h([...J, L]), R.push(y(Q, { id: D(M) }));
            } else R.push(...J, ...L);
            return R.push(" ", k("body")), R;
          }
          var D = s("heritageGroup");
          function T(b) {
            return g(l, "", { groupId: D(b) });
          }
          function m(b) {
            return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
          }
          function C(b) {
            return b.typeParameters && !c2(b.typeParameters, f.Trailing | f.Line) && !m(b);
          }
          function o(b, B, k, M) {
            let R = b.getValue();
            if (!t(R[M])) return "";
            let q = n(b, B, true, (J) => {
              let { marker: L } = J;
              return L === M;
            });
            return [C(R) ? g(" ", i, { groupId: F(R.typeParameters) }) : i, q, q && l, M, y(h([i, u([",", i], b.map(k, M))]))];
          }
          function d(b, B, k) {
            let M = k("superClass");
            return b.getParentNode().type === "AssignmentExpression" ? y(g(["(", h([p, M]), p, ")"], M)) : M;
          }
          function v(b, B, k) {
            let M = b.getValue(), R = [];
            return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.readonly && R.push("readonly "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && R.push("abstract "), M.override && R.push("override "), R.push(_(b, B, k)), R;
          }
          function S(b, B, k) {
            let M = b.getValue(), R = [], q = B.semi ? ";" : "";
            return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.type === "TSAbstractAccessorProperty" || M.abstract) && R.push("abstract "), M.override && R.push("override "), M.readonly && R.push("readonly "), M.variance && R.push(k("variance")), (M.type === "ClassAccessorProperty" || M.type === "AccessorProperty" || M.type === "TSAbstractAccessorProperty") && R.push("accessor "), R.push(x(b, B, k), w(b), N(b), E(b, B, k)), [I(b, B, k, R, " =", "value"), q];
          }
          r2.exports = { printClass: $, printClassMethod: v, printClassProperty: S, printHardlineAfterHeritage: T };
        } }), bo = te({ "src/language-js/print/interface.js"(e, r2) {
          ne();
          var { isNonEmptyArray: t } = Ue(), { builders: { join: s, line: a, group: n, indent: u, ifBreak: i } } = qe(), { hasComment: l, identity: p, CommentCheckFlags: y } = Ke(), { getTypeParametersGroupId: h } = jr(), { printTypeScriptModifiers: g } = ct();
          function c2(f, F, _) {
            let w = f.getValue(), E = [];
            w.declare && E.push("declare "), w.type === "TSInterfaceDeclaration" && E.push(w.abstract ? "abstract " : "", g(f, F, _)), E.push("interface");
            let N = [], x = [];
            w.type !== "InterfaceTypeAnnotation" && N.push(" ", _("id"), _("typeParameters"));
            let I = w.typeParameters && !l(w.typeParameters, y.Trailing | y.Line);
            return t(w.extends) && x.push(I ? i(" ", a, { groupId: h(w.typeParameters) }) : a, "extends ", (w.extends.length === 1 ? p : u)(s([",", a], f.map(_, "extends")))), w.id && l(w.id, y.Trailing) || t(w.extends) ? I ? E.push(n([...N, u(x)])) : E.push(n(u([...N, ...x]))) : E.push(...N, ...x), E.push(" ", _("body")), n(E);
          }
          r2.exports = { printInterface: c2 };
        } }), To = te({ "src/language-js/print/module.js"(e, r2) {
          ne();
          var { isNonEmptyArray: t } = Ue(), { builders: { softline: s, group: a, indent: n, join: u, line: i, ifBreak: l, hardline: p } } = qe(), { printDanglingComments: y } = et(), { hasComment: h, CommentCheckFlags: g, shouldPrintComma: c2, needsHardlineAfterDanglingComment: f, isStringLiteral: F, rawText: _ } = Ke(), { locStart: w, hasSameLoc: E } = ut(), { hasDecoratorsBeforeExport: N, printDecoratorsBeforeExport: x } = nu();
          function I(S, b, B) {
            let k = S.getValue(), M = b.semi ? ";" : "", R = [], { importKind: q } = k;
            return R.push("import"), q && q !== "value" && R.push(" ", q), R.push(m(S, b, B), T(S, b, B), o(S, b, B), M), R;
          }
          function P(S, b, B) {
            let k = S.getValue(), M = [];
            N(k) && M.push(x(S, b, B));
            let { type: R, exportKind: q, declaration: J } = k;
            return M.push("export"), (k.default || R === "ExportDefaultDeclaration") && M.push(" default"), h(k, g.Dangling) && (M.push(" ", y(S, b, true)), f(k) && M.push(p)), J ? M.push(" ", B("declaration")) : M.push(q === "type" ? " type" : "", m(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M.push(";"), M;
          }
          function $(S, b, B) {
            let k = S.getValue(), M = b.semi ? ";" : "", R = [], { exportKind: q, exported: J } = k;
            return R.push("export"), q === "type" && R.push(" type"), R.push(" *"), J && R.push(" as ", B("exported")), R.push(T(S, b, B), o(S, b, B), M), R;
          }
          function D(S, b) {
            if (!b.semi) return false;
            let { type: B, declaration: k } = S, M = S.default || B === "ExportDefaultDeclaration";
            if (!k) return true;
            let { type: R } = k;
            return !!(M && R !== "ClassDeclaration" && R !== "FunctionDeclaration" && R !== "TSInterfaceDeclaration" && R !== "DeclareClass" && R !== "DeclareFunction" && R !== "TSDeclareFunction" && R !== "EnumDeclaration");
          }
          function T(S, b, B) {
            let k = S.getValue();
            if (!k.source) return "";
            let M = [];
            return C(k, b) || M.push(" from"), M.push(" ", B("source")), M;
          }
          function m(S, b, B) {
            let k = S.getValue();
            if (C(k, b)) return "";
            let M = [" "];
            if (t(k.specifiers)) {
              let R = [], q = [];
              S.each(() => {
                let J = S.getValue().type;
                if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier") R.push(B());
                else if (J === "ExportSpecifier" || J === "ImportSpecifier") q.push(B());
                else throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
              }, "specifiers"), M.push(u(", ", R)), q.length > 0 && (R.length > 0 && M.push(", "), q.length > 1 || R.length > 0 || k.specifiers.some((L) => h(L)) ? M.push(a(["{", n([b.bracketSpacing ? i : s, u([",", i], q)]), l(c2(b) ? "," : ""), b.bracketSpacing ? i : s, "}"])) : M.push(["{", b.bracketSpacing ? " " : "", ...q, b.bracketSpacing ? " " : "", "}"]));
            } else M.push("{}");
            return M;
          }
          function C(S, b) {
            let { type: B, importKind: k, source: M, specifiers: R } = S;
            return B !== "ImportDeclaration" || t(R) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w(S), w(M)));
          }
          function o(S, b, B) {
            let k = S.getNode();
            return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
          }
          function d(S, b, B) {
            let k = S.getNode(), { type: M } = k, R = [], q = M === "ImportSpecifier" ? k.importKind : k.exportKind;
            q && q !== "value" && R.push(q, " ");
            let J = M.startsWith("Import"), L = J ? "imported" : "local", Q = J ? "local" : "exported", V = k[L], j = k[Q], Y = "", ie = "";
            return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Y = "*" : V && (Y = B(L)), j && !v(k) && (ie = B(Q)), R.push(Y, Y && ie ? " as " : "", ie), R;
          }
          function v(S) {
            if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier") return false;
            let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
            if (b.type !== B.type || !E(b, B)) return false;
            if (F(b)) return b.value === B.value && _(b) === _(B);
            switch (b.type) {
              case "Identifier":
                return b.name === B.name;
              default:
                return false;
            }
          }
          r2.exports = { printImportDeclaration: I, printExportDeclaration: P, printExportAllDeclaration: $, printModuleSpecifier: d };
        } }), uu = te({ "src/language-js/print/object.js"(e, r2) {
          ne();
          var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, group: n, indent: u, ifBreak: i, hardline: l } } = qe(), { getLast: p, hasNewlineInRange: y, hasNewline: h, isNonEmptyArray: g } = Ue(), { shouldPrintComma: c2, hasComment: f, getComments: F, CommentCheckFlags: _, isNextLineEmpty: w } = Ke(), { locStart: E, locEnd: N } = ut(), { printOptionalToken: x, printTypeAnnotation: I } = ct(), { shouldHugFunctionParameters: P } = Lr(), { shouldHugType: $ } = Or(), { printHardlineAfterHeritage: D } = nr();
          function T(m, C, o) {
            let d = C.semi ? ";" : "", v = m.getValue(), S;
            v.type === "TSTypeLiteral" ? S = "members" : v.type === "TSInterfaceBody" ? S = "body" : S = "properties";
            let b = v.type === "ObjectTypeAnnotation", B = [S];
            b && B.push("indexers", "callProperties", "internalSlots");
            let k = B.map((W) => v[W][0]).sort((W, K) => E(W) - E(K))[0], M = m.getParentNode(0), R = b && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && m.getName() === "body", q = v.type === "TSInterfaceBody" || R || v.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && v.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v.type !== "ObjectPattern" && k && y(C.originalText, E(v), E(k)), J = R ? ";" : v.type === "TSInterfaceBody" || v.type === "TSTypeLiteral" ? i(d, ";") : ",", L = v.type === "RecordExpression" ? "#{" : v.exact ? "{|" : "{", Q = v.exact ? "|}" : "}", V = [];
            for (let W of B) m.each((K) => {
              let de = K.getValue();
              V.push({ node: de, printed: o(), loc: E(de) });
            }, W);
            B.length > 1 && V.sort((W, K) => W.loc - K.loc);
            let j = [], Y = V.map((W) => {
              let K = [...j, n(W.printed)];
              return j = [J, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K;
            });
            if (v.inexact) {
              let W;
              if (f(v, _.Dangling)) {
                let K = f(v, _.Line);
                W = [t(m, C, true), K || h(C.originalText, N(p(F(v)))) ? l : s, "..."];
              } else W = ["..."];
              Y.push([...j, ...W]);
            }
            let ie = p(v[S]), ee = !(v.inexact || ie && ie.type === "RestElement" || ie && (ie.type === "TSPropertySignature" || ie.type === "TSCallSignatureDeclaration" || ie.type === "TSMethodSignature" || ie.type === "TSConstructSignatureDeclaration") && f(ie, _.PrettierIgnore)), ce;
            if (Y.length === 0) {
              if (!f(v, _.Dangling)) return [L, Q, I(m, C, o)];
              ce = n([L, t(m, C), a, Q, x(m), I(m, C, o)]);
            } else ce = [R && g(v.properties) ? D(M) : "", L, u([C.bracketSpacing ? s : a, ...Y]), i(ee && (J !== "," || c2(C)) ? J : ""), C.bracketSpacing ? s : a, Q, x(m), I(m, C, o)];
            return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || m.match($, (W, K) => K === "typeAnnotation", (W, K) => K === "typeAnnotation", (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || !q && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce : n(ce, { shouldBreak: q });
          }
          r2.exports = { printObject: T };
        } }), dd = te({ "src/language-js/print/flow.js"(e, r2) {
          ne();
          var t = Zt(), { printDanglingComments: s } = et(), { printString: a, printNumber: n } = Ue(), { builders: { hardline: u, softline: i, group: l, indent: p } } = qe(), { getParentExportDeclaration: y, isFunctionNotation: h, isGetterOrSetter: g, rawText: c2, shouldPrintComma: f } = Ke(), { locStart: F, locEnd: _ } = ut(), { replaceTextEndOfLine: w } = Yt(), { printClass: E } = nr(), { printOpaqueType: N, printTypeAlias: x, printIntersectionType: I, printUnionType: P, printFunctionType: $, printTupleType: D, printIndexedAccessType: T } = Or(), { printInterface: m } = bo(), { printTypeParameter: C, printTypeParameters: o } = jr(), { printExportDeclaration: d, printExportAllDeclaration: v } = To(), { printArrayItems: S } = er(), { printObject: b } = uu(), { printPropertyKey: B } = rr(), { printOptionalToken: k, printTypeAnnotation: M, printRestSpread: R } = ct();
          function q(L, Q, V) {
            let j = L.getValue(), Y = Q.semi ? ";" : "", ie = [];
            switch (j.type) {
              case "DeclareClass":
                return J(L, E(L, Q, V));
              case "DeclareFunction":
                return J(L, ["function ", V("id"), j.predicate ? " " : "", V("predicate"), Y]);
              case "DeclareModule":
                return J(L, ["module ", V("id"), " ", V("body")]);
              case "DeclareModuleExports":
                return J(L, ["module.exports", ": ", V("typeAnnotation"), Y]);
              case "DeclareVariable":
                return J(L, ["var ", V("id"), Y]);
              case "DeclareOpaqueType":
                return J(L, N(L, Q, V));
              case "DeclareInterface":
                return J(L, m(L, Q, V));
              case "DeclareTypeAlias":
                return J(L, x(L, Q, V));
              case "DeclareExportDeclaration":
                return J(L, d(L, Q, V));
              case "DeclareExportAllDeclaration":
                return J(L, v(L, Q, V));
              case "OpaqueType":
                return N(L, Q, V);
              case "TypeAlias":
                return x(L, Q, V);
              case "IntersectionTypeAnnotation":
                return I(L, Q, V);
              case "UnionTypeAnnotation":
                return P(L, Q, V);
              case "FunctionTypeAnnotation":
                return $(L, Q, V);
              case "TupleTypeAnnotation":
                return D(L, Q, V);
              case "GenericTypeAnnotation":
                return [V("id"), o(L, Q, V, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return T(L, Q, V);
              case "TypeAnnotation":
                return V("typeAnnotation");
              case "TypeParameter":
                return C(L, Q, V);
              case "TypeofTypeAnnotation":
                return ["typeof ", V("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [V("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(j.value);
              case "EnumDeclaration":
                return ["enum ", V("id"), " ", V("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (j.type === "EnumSymbolBody" || j.explicitType) {
                  let ee = null;
                  switch (j.type) {
                    case "EnumBooleanBody":
                      ee = "boolean";
                      break;
                    case "EnumNumberBody":
                      ee = "number";
                      break;
                    case "EnumStringBody":
                      ee = "string";
                      break;
                    case "EnumSymbolBody":
                      ee = "symbol";
                      break;
                  }
                  ie.push("of ", ee, " ");
                }
                if (j.members.length === 0 && !j.hasUnknownMembers) ie.push(l(["{", s(L, Q), i, "}"]));
                else {
                  let ee = j.members.length > 0 ? [u, S(L, Q, "members", V), j.hasUnknownMembers || f(Q) ? "," : ""] : [];
                  ie.push(l(["{", p([...ee, ...j.hasUnknownMembers ? [u, "..."] : []]), s(L, Q, true), u, "}"]));
                }
                return ie;
              }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [V("id"), " = ", typeof j.init == "object" ? V("init") : String(j.init)];
              case "EnumDefaultedMember":
                return V("id");
              case "FunctionTypeParam": {
                let ee = j.name ? V("name") : L.getParentNode().this === j ? "this" : "";
                return [ee, k(L), ee ? ": " : "", V("typeAnnotation")];
              }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return m(L, Q, V);
              case "ClassImplements":
              case "InterfaceExtends":
                return [V("id"), V("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", V("typeAnnotation")];
              case "Variance": {
                let { kind: ee } = j;
                return t.ok(ee === "plus" || ee === "minus"), ee === "plus" ? "+" : "-";
              }
              case "ObjectTypeCallProperty":
                return j.static && ie.push("static "), ie.push(V("value")), ie;
              case "ObjectTypeIndexer":
                return [j.static ? "static " : "", j.variance ? V("variance") : "", "[", V("id"), j.id ? ": " : "", V("key"), "]: ", V("value")];
              case "ObjectTypeProperty": {
                let ee = "";
                return j.proto ? ee = "proto " : j.static && (ee = "static "), [ee, g(j) ? j.kind + " " : "", j.variance ? V("variance") : "", B(L, Q, V), k(L), h(j) ? "" : ": ", V("value")];
              }
              case "ObjectTypeAnnotation":
                return b(L, Q, V);
              case "ObjectTypeInternalSlot":
                return [j.static ? "static " : "", "[[", V("id"), "]]", k(L), j.method ? "" : ": ", V("value")];
              case "ObjectTypeSpreadProperty":
                return R(L, Q, V);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [V("qualification"), ".", V("id")];
              case "StringLiteralTypeAnnotation":
                return w(a(c2(j), Q));
              case "NumberLiteralTypeAnnotation":
                t.strictEqual(typeof j.value, "number");
              case "BigIntLiteralTypeAnnotation":
                return j.extra ? n(j.extra.raw) : n(j.raw);
              case "TypeCastExpression":
                return ["(", V("expression"), M(L, Q, V), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation": {
                let ee = o(L, Q, V, "params");
                if (Q.parser === "flow") {
                  let ce = F(j), W = _(j), K = Q.originalText.lastIndexOf("/*", ce), de = Q.originalText.indexOf("*/", W);
                  if (K !== -1 && de !== -1) {
                    let ue = Q.originalText.slice(K + 2, de).trim();
                    if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/")) return ["/*:: ", ee, " */"];
                  }
                }
                return ee;
              }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", V("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(j.type));
            }
          }
          function J(L, Q) {
            let V = y(L);
            return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Q) : ["declare ", Q];
          }
          r2.exports = { printFlow: q };
        } }), gd = te({ "src/language-js/utils/is-ts-keyword-type.js"(e, r2) {
          ne();
          function t(s) {
            let { type: a } = s;
            return a.startsWith("TS") && a.endsWith("Keyword");
          }
          r2.exports = t;
        } }), Bo = te({ "src/language-js/print/ternary.js"(e, r2) {
          ne();
          var { hasNewlineInRange: t } = Ue(), { isJsxNode: s, getComments: a, isCallExpression: n, isMemberExpression: u, isTSTypeExpression: i } = Ke(), { locStart: l, locEnd: p } = ut(), y = Pt(), { builders: { line: h, softline: g, group: c2, indent: f, align: F, ifBreak: _, dedent: w, breakParent: E } } = qe();
          function N(D) {
            let T = [D];
            for (let m = 0; m < T.length; m++) {
              let C = T[m];
              for (let o of ["test", "consequent", "alternate"]) {
                let d = C[o];
                if (s(d)) return true;
                d.type === "ConditionalExpression" && T.push(d);
              }
            }
            return false;
          }
          function x(D, T, m) {
            let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "alternate" : "falseType", v = D.getParentNode(), S = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
            return v.type === C.type && v[d] === C ? F(2, S) : S;
          }
          var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function P(D) {
            let T = D.getValue();
            if (T.type !== "ConditionalExpression") return false;
            let m, C = T;
            for (let o = 0; !m; o++) {
              let d = D.getParentNode(o);
              if (n(d) && d.callee === C || u(d) && d.object === C || d.type === "TSNonNullExpression" && d.expression === C) {
                C = d;
                continue;
              }
              d.type === "NewExpression" && d.callee === C || i(d) && d.expression === C ? (m = D.getParentNode(o + 1), C = d) : m = d;
            }
            return C === T ? false : m[I.get(m.type)] === C;
          }
          function $(D, T, m) {
            let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "consequent" : "trueType", v = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C[d], B = C[v], k = [], M = false, R = D.getParentNode(), q = R.type === C.type && S.some((ue) => R[ue] === C), J = R.type === C.type && !q, L, Q, V = 0;
            do
              Q = L || C, L = D.getParentNode(V), V++;
            while (L && L.type === C.type && S.every((ue) => L[ue] !== Q));
            let j = L || R, Y = Q;
            if (o && (s(C[S[0]]) || s(b) || s(B) || N(Y))) {
              M = true, J = true;
              let ue = (z) => [_("("), f([g, z]), g, _(")")], Fe = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
              k.push(" ? ", Fe(b) ? m(d) : ue(m(d)), " : ", B.type === C.type || Fe(B) ? m(v) : ue(m(v)));
            } else {
              let ue = [h, "? ", b.type === C.type ? _("", "(") : "", F(2, m(d)), b.type === C.type ? _("", ")") : "", h, ": ", B.type === C.type ? m(v) : F(2, m(v))];
              k.push(R.type !== C.type || R[v] === C || q ? ue : T.useTabs ? w(f(ue)) : F(Math.max(0, T.tabWidth - 2), ue));
            }
            let ee = [...S.map((ue) => a(C[ue])), a(b), a(B)].flat().some((ue) => y(ue) && t(T.originalText, l(ue), p(ue))), ce = (ue) => R === j ? c2(ue, { shouldBreak: ee }) : ee ? [ue, E] : ue, W = !M && (u(R) || R.type === "NGPipeExpression" && R.left === C) && !R.computed, K = P(D), de = ce([x(D, T, m), J ? k : f(k), o && W && !K ? g : ""]);
            return q || K ? c2([f([g, de]), g]) : de;
          }
          r2.exports = { printTernary: $ };
        } }), No = te({ "src/language-js/print/statement.js"(e, r2) {
          ne();
          var { builders: { hardline: t } } = qe(), s = qt(), { getLeftSidePathName: a, hasNakedLeftSide: n, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: p, isNextLineEmpty: y } = Ke(), { shouldPrintParamsWithoutParens: h } = qr();
          function g(x, I, P, $) {
            let D = x.getValue(), T = [], m = D.type === "ClassBody", C = c2(D[$]);
            return x.each((o, d, v) => {
              let S = o.getValue();
              if (S.type === "EmptyStatement") return;
              let b = P();
              !I.semi && !m && !i(I, o) && f(o, I) ? l(S, p.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I.semi && m && E(S) && N(S, v[d + 1]) && T.push(";"), S !== C && (T.push(t), y(S, I) && T.push(t));
            }, $), T;
          }
          function c2(x) {
            for (let I = x.length - 1; I >= 0; I--) {
              let P = x[I];
              if (P.type !== "EmptyStatement") return P;
            }
          }
          function f(x, I) {
            return x.getNode().type !== "ExpressionStatement" ? false : x.call(($) => F($, I), "expression");
          }
          function F(x, I) {
            let P = x.getValue();
            switch (P.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return true;
              case "ArrowFunctionExpression": {
                if (!h(x, I)) return true;
                break;
              }
              case "UnaryExpression": {
                let { prefix: $, operator: D } = P;
                if ($ && (D === "+" || D === "-")) return true;
                break;
              }
              case "BindExpression": {
                if (!P.object) return true;
                break;
              }
              case "Literal": {
                if (P.regex) return true;
                break;
              }
              default:
                if (u(P)) return true;
            }
            return s(x, I) ? true : n(P) ? x.call(($) => F($, I), ...a(x, P)) : false;
          }
          function _(x, I, P) {
            return g(x, I, P, "body");
          }
          function w(x, I, P) {
            return g(x, I, P, "consequent");
          }
          var E = (x) => {
            let { type: I } = x;
            return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty" || I === "AccessorProperty" || I === "TSAbstractPropertyDefinition" || I === "TSAbstractAccessorProperty";
          };
          function N(x, I) {
            let { type: P, name: $ } = x.key;
            if (!x.computed && P === "Identifier" && ($ === "static" || $ === "get" || $ === "set" || $ === "accessor") && !x.value && !x.typeAnnotation) return true;
            if (!I || I.static || I.accessibility) return false;
            if (!I.computed) {
              let D = I.key && I.key.name;
              if (D === "in" || D === "instanceof") return true;
            }
            if (E(I) && I.variance && !I.static && !I.declare) return true;
            switch (I.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return I.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set") return false;
                let T = I.value ? I.value.generator : I.generator;
                return !!(I.computed || T);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }
          r2.exports = { printBody: _, printSwitchCaseConsequent: w };
        } }), wo = te({ "src/language-js/print/block.js"(e, r2) {
          ne();
          var { printDanglingComments: t } = et(), { isNonEmptyArray: s } = Ue(), { builders: { hardline: a, indent: n } } = qe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke(), { printHardlineAfterHeritage: p } = nr(), { printBody: y } = No();
          function h(c2, f, F) {
            let _ = c2.getValue(), w = [];
            if (_.type === "StaticBlock" && w.push("static "), _.type === "ClassBody" && s(_.body)) {
              let N = c2.getParentNode();
              w.push(p(N));
            }
            w.push("{");
            let E = g(c2, f, F);
            if (E) w.push(n([a, E]), a);
            else {
              let N = c2.getParentNode(), x = c2.getParentNode(1);
              N.type === "ArrowFunctionExpression" || N.type === "FunctionExpression" || N.type === "FunctionDeclaration" || N.type === "ObjectMethod" || N.type === "ClassMethod" || N.type === "ClassPrivateMethod" || N.type === "ForStatement" || N.type === "WhileStatement" || N.type === "DoWhileStatement" || N.type === "DoExpression" || N.type === "CatchClause" && !x.finalizer || N.type === "TSModuleDeclaration" || N.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w.push(a);
            }
            return w.push("}"), w;
          }
          function g(c2, f, F) {
            let _ = c2.getValue(), w = s(_.directives), E = _.body.some((I) => I.type !== "EmptyStatement"), N = u(_, i.Dangling);
            if (!w && !E && !N) return "";
            let x = [];
            if (w && c2.each((I, P, $) => {
              x.push(F()), (P < $.length - 1 || E || N) && (x.push(a), l(I.getValue(), f) && x.push(a));
            }, "directives"), E && x.push(y(c2, f, F)), N && x.push(t(c2, f, true)), _.type === "Program") {
              let I = c2.getParentNode();
              (!I || I.type !== "ModuleExpression") && x.push(a);
            }
            return x;
          }
          r2.exports = { printBlock: h, printBlockBody: g };
        } }), yd = te({ "src/language-js/print/typescript.js"(e, r2) {
          ne();
          var { printDanglingComments: t } = et(), { hasNewlineInRange: s } = Ue(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y, ifBreak: h } } = qe(), { isStringLiteral: g, getTypeScriptMappedTypeModifier: c2, shouldPrintComma: f, isCallExpression: F, isMemberExpression: _ } = Ke(), w = gd(), { locStart: E, locEnd: N } = ut(), { printOptionalToken: x, printTypeScriptModifiers: I } = ct(), { printTernary: P } = Bo(), { printFunctionParameters: $, shouldGroupFunctionParameters: D } = Lr(), { printTemplateLiteral: T } = jt(), { printArrayItems: m } = er(), { printObject: C } = uu(), { printClassProperty: o, printClassMethod: d } = nr(), { printTypeParameter: v, printTypeParameters: S } = jr(), { printPropertyKey: b } = rr(), { printFunction: B, printMethodInternal: k } = qr(), { printInterface: M } = bo(), { printBlock: R } = wo(), { printTypeAlias: q, printIntersectionType: J, printUnionType: L, printFunctionType: Q, printTupleType: V, printIndexedAccessType: j, printJSDocType: Y } = Or();
          function ie(ee, ce, W) {
            let K = ee.getValue();
            if (!K.type.startsWith("TS")) return;
            if (w(K)) return K.type.slice(2, -7).toLowerCase();
            let de = ce.semi ? ";" : "", ue = [];
            switch (K.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion": {
                let Fe = !(K.expression.type === "ArrayExpression" || K.expression.type === "ObjectExpression"), z = l(["<", p([i, W("typeAnnotation")]), i, ">"]), U = [h("("), p([i, W("expression")]), i, h(")")];
                return Fe ? y([[z, W("expression")], [z, l(U, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
              }
              case "TSDeclareFunction":
                return B(ee, W, ce);
              case "TSExportAssignment":
                return ["export = ", W("expression"), de];
              case "TSModuleBlock":
                return R(ee, ce, W);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return C(ee, ce, W);
              case "TSTypeAliasDeclaration":
                return q(ee, ce, W);
              case "TSQualifiedName":
                return a(".", [W("left"), W("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return d(ee, ce, W);
              case "TSAbstractAccessorProperty":
              case "TSAbstractPropertyDefinition":
                return o(ee, ce, W);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return ue.push(W("expression")), K.typeParameters && ue.push(W("typeParameters")), ue;
              case "TSTemplateLiteralType":
                return T(ee, W, ce);
              case "TSNamedTupleMember":
                return [W("label"), K.optional ? "?" : "", ": ", W("elementType")];
              case "TSRestType":
                return ["...", W("typeAnnotation")];
              case "TSOptionalType":
                return [W("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return M(ee, ce, W);
              case "TSClassImplements":
                return [W("expression"), W("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return S(ee, ce, W, "params");
              case "TSTypeParameter":
                return v(ee, ce, W);
              case "TSSatisfiesExpression":
              case "TSAsExpression": {
                let Fe = K.type === "TSAsExpression" ? "as" : "satisfies";
                ue.push(W("expression"), ` ${Fe} `, W("typeAnnotation"));
                let z = ee.getParentNode();
                return F(z) && z.callee === K || _(z) && z.object === K ? l([p([i, ...ue]), i]) : ue;
              }
              case "TSArrayType":
                return [W("elementType"), "[]"];
              case "TSPropertySignature":
                return K.readonly && ue.push("readonly "), ue.push(b(ee, ce, W), x(ee)), K.typeAnnotation && ue.push(": ", W("typeAnnotation")), K.initializer && ue.push(" = ", W("initializer")), ue;
              case "TSParameterProperty":
                return K.accessibility && ue.push(K.accessibility + " "), K.export && ue.push("export "), K.static && ue.push("static "), K.override && ue.push("override "), K.readonly && ue.push("readonly "), ue.push(W("parameter")), ue;
              case "TSTypeQuery":
                return ["typeof ", W("exprName"), W("typeParameters")];
              case "TSIndexSignature": {
                let Fe = ee.getParentNode(), z = K.parameters.length > 1 ? h(f(ce) ? "," : "") : "", U = l([p([i, a([", ", i], ee.map(W, "parameters"))]), z, i]);
                return [K.export ? "export " : "", K.accessibility ? [K.accessibility, " "] : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.declare ? "declare " : "", "[", K.parameters ? U : "", K.typeAnnotation ? "]: " : "]", K.typeAnnotation ? W("typeAnnotation") : "", Fe.type === "ClassBody" ? de : ""];
              }
              case "TSTypePredicate":
                return [K.asserts ? "asserts " : "", W("parameterName"), K.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [W("expression"), "!"];
              case "TSImportType":
                return [K.isTypeOf ? "typeof " : "", "import(", W(K.parameter ? "parameter" : "argument"), ")", K.qualifier ? [".", W("qualifier")] : "", S(ee, ce, W, "typeParameters")];
              case "TSLiteralType":
                return W("literal");
              case "TSIndexedAccessType":
                return j(ee, ce, W);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType": {
                if (K.type === "TSConstructorType" && K.abstract && ue.push("abstract "), K.type !== "TSCallSignatureDeclaration" && ue.push("new "), ue.push(l($(ee, W, ce, false, true))), K.returnType || K.typeAnnotation) {
                  let Fe = K.type === "TSConstructorType";
                  ue.push(Fe ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                }
                return ue;
              }
              case "TSTypeOperator":
                return [K.operator, " ", W("typeAnnotation")];
              case "TSMappedType": {
                let Fe = s(ce.originalText, E(K), N(K));
                return l(["{", p([ce.bracketSpacing ? n : i, W("typeParameter"), K.optional ? c2(K.optional, "?") : "", K.typeAnnotation ? ": " : "", W("typeAnnotation"), h(de)]), t(ee, ce, true), ce.bracketSpacing ? n : i, "}"], { shouldBreak: Fe });
              }
              case "TSMethodSignature": {
                let Fe = K.kind && K.kind !== "method" ? `${K.kind} ` : "";
                ue.push(K.accessibility ? [K.accessibility, " "] : "", Fe, K.export ? "export " : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.abstract ? "abstract " : "", K.declare ? "declare " : "", K.computed ? "[" : "", W("key"), K.computed ? "]" : "", x(ee));
                let z = $(ee, W, ce, false, true), U = K.returnType ? "returnType" : "typeAnnotation", Z = K[U], se = Z ? W(U) : "", fe = D(K, se);
                return ue.push(fe ? l(z) : z), Z && ue.push(": ", l(se)), l(ue);
              }
              case "TSNamespaceExportDeclaration":
                return ue.push("export as namespace ", W("id")), ce.semi && ue.push(";"), l(ue);
              case "TSEnumDeclaration":
                return K.declare && ue.push("declare "), K.modifiers && ue.push(I(ee, ce, W)), K.const && ue.push("const "), ue.push("enum ", W("id"), " "), K.members.length === 0 ? ue.push(l(["{", t(ee, ce), i, "}"])) : ue.push(l(["{", p([u, m(ee, ce, "members", W), f(ce, "es5") ? "," : ""]), t(ee, ce, true), u, "}"])), ue;
              case "TSEnumMember":
                return K.computed ? ue.push("[", W("id"), "]") : ue.push(W("id")), K.initializer && ue.push(" = ", W("initializer")), ue;
              case "TSImportEqualsDeclaration":
                return K.isExport && ue.push("export "), ue.push("import "), K.importKind && K.importKind !== "value" && ue.push(K.importKind, " "), ue.push(W("id"), " = ", W("moduleReference")), ce.semi && ue.push(";"), l(ue);
              case "TSExternalModuleReference":
                return ["require(", W("expression"), ")"];
              case "TSModuleDeclaration": {
                let Fe = ee.getParentNode(), z = g(K.id), U = Fe.type === "TSModuleDeclaration", Z = K.body && K.body.type === "TSModuleDeclaration";
                if (U) ue.push(".");
                else {
                  K.declare && ue.push("declare "), ue.push(I(ee, ce, W));
                  let se = ce.originalText.slice(E(K), E(K.id));
                  K.id.type === "Identifier" && K.id.name === "global" && !/namespace|module/.test(se) || ue.push(z || /(?:^|\s)module(?:\s|$)/.test(se) ? "module " : "namespace ");
                }
                return ue.push(W("id")), Z ? ue.push(W("body")) : K.body ? ue.push(" ", l(W("body"))) : ue.push(de), ue;
              }
              case "TSConditionalType":
                return P(ee, ce, W);
              case "TSInferType":
                return ["infer", " ", W("typeParameter")];
              case "TSIntersectionType":
                return J(ee, ce, W);
              case "TSUnionType":
                return L(ee, ce, W);
              case "TSFunctionType":
                return Q(ee, ce, W);
              case "TSTupleType":
                return V(ee, ce, W);
              case "TSTypeReference":
                return [W("typeName"), S(ee, ce, W, "typeParameters")];
              case "TSTypeAnnotation":
                return W("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return k(ee, ce, W);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return Y(ee, W, "?");
              case "TSJSDocNonNullableType":
                return Y(ee, W, "!");
              case "TSInstantiationExpression":
                return [W("expression"), W("typeParameters")];
              default:
                throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`);
            }
          }
          r2.exports = { printTypescript: ie };
        } }), hd = te({ "src/language-js/print/comment.js"(e, r2) {
          ne();
          var { hasNewline: t } = Ue(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: n } } = qe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: l } = ut(), p = Pt();
          function y(c2, f) {
            let F = c2.getValue();
            if (u(F)) return f.originalText.slice(i(F), l(F)).trimEnd();
            if (p(F)) {
              if (h(F)) {
                let E = g(F);
                return F.trailing && !t(f.originalText, i(F), { backwards: true }) ? [a, E] : E;
              }
              let _ = l(F), w = f.originalText.slice(_ - 3, _) === "*-/";
              return ["/*", n(F.value), w ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(F));
          }
          function h(c2) {
            let f = `*${c2.value}*`.split(`
`);
            return f.length > 1 && f.every((F) => F.trim()[0] === "*");
          }
          function g(c2) {
            let f = c2.value.split(`
`);
            return ["/*", s(a, f.map((F, _) => _ === 0 ? F.trimEnd() : " " + (_ < f.length - 1 ? F.trim() : F.trimStart()))), "*/"];
          }
          r2.exports = { printComment: y };
        } }), vd = te({ "src/language-js/print/literal.js"(e, r2) {
          ne();
          var { printString: t, printNumber: s } = Ue(), { replaceTextEndOfLine: a } = Yt(), { printDirective: n } = ct();
          function u(y, h) {
            let g = y.getNode();
            switch (g.type) {
              case "RegExpLiteral":
                return p(g);
              case "BigIntLiteral":
                return l(g.bigint || g.extra.raw);
              case "NumericLiteral":
                return s(g.extra.raw);
              case "StringLiteral":
                return a(t(g.extra.raw, h));
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(g.value);
              case "DecimalLiteral":
                return s(g.value) + "m";
              case "Literal": {
                if (g.regex) return p(g.regex);
                if (g.bigint) return l(g.raw);
                if (g.decimal) return s(g.decimal) + "m";
                let { value: c2 } = g;
                return typeof c2 == "number" ? s(g.raw) : typeof c2 == "string" ? i(y) ? n(g.raw, h) : a(t(g.raw, h)) : String(c2);
              }
            }
          }
          function i(y) {
            if (y.getName() !== "expression") return;
            let h = y.getParentNode();
            return h.type === "ExpressionStatement" && h.directive;
          }
          function l(y) {
            return y.toLowerCase();
          }
          function p(y) {
            let { pattern: h, flags: g } = y;
            return g = [...g].sort().join(""), `/${h}/${g}`;
          }
          r2.exports = { printLiteral: u };
        } }), Cd = te({ "src/language-js/printer-estree.js"(e, r2) {
          ne();
          var { printDanglingComments: t } = et(), { hasNewline: s } = Ue(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p }, utils: { replaceTextEndOfLine: y } } = qe(), h = td(), g = rd(), { insertPragma: c2 } = Co(), f = Eo(), F = qt(), _ = Fo(), { hasFlowShorthandAnnotationComment: w, hasComment: E, CommentCheckFlags: N, isTheOnlyJsxElementInMarkdown: x, isLineComment: I, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m, markerForIfWithoutBlockAndSameLineComment: C } = Ke(), { locStart: o, locEnd: d } = ut(), v = Pt(), { printHtmlBinding: S, isVueEventBindingExpression: b } = pd(), { printAngular: B } = fd(), { printJsx: k, hasJsxIgnoreComment: M } = Dd(), { printFlow: R } = dd(), { printTypescript: q } = yd(), { printOptionalToken: J, printBindExpressionCallee: L, printTypeAnnotation: Q, adjustClause: V, printRestSpread: j, printDefiniteToken: Y, printDirective: ie } = ct(), { printImportDeclaration: ee, printExportDeclaration: ce, printExportAllDeclaration: W, printModuleSpecifier: K } = To(), { printTernary: de } = Bo(), { printTemplateLiteral: ue } = jt(), { printArray: Fe } = er(), { printObject: z } = uu(), { printClass: U, printClassMethod: Z, printClassProperty: se } = nr(), { printProperty: fe } = rr(), { printFunction: ge, printArrowFunction: he, printMethod: we, printReturnStatement: ke, printThrowStatement: Re } = qr(), { printCallExpression: Ne } = xo(), { printVariableDeclarator: Pe, printAssignmentExpression: oe } = tr(), { printBinaryishExpression: H } = ru(), { printSwitchCaseConsequent: pe } = No(), { printMemberExpression: X } = So(), { printBlock: le, printBlockBody: Ae } = wo(), { printComment: Ee } = hd(), { printLiteral: De } = vd(), { printDecorators: A } = nu();
          function G(Ce, Be, ve, ze) {
            let be = re(Ce, Be, ve, ze);
            if (!be) return "";
            let Ye = Ce.getValue(), { type: Se } = Ye;
            if (Se === "ClassMethod" || Se === "ClassPrivateMethod" || Se === "ClassProperty" || Se === "ClassAccessorProperty" || Se === "AccessorProperty" || Se === "TSAbstractAccessorProperty" || Se === "PropertyDefinition" || Se === "TSAbstractPropertyDefinition" || Se === "ClassPrivateProperty" || Se === "MethodDefinition" || Se === "TSAbstractMethodDefinition" || Se === "TSDeclareMethod") return be;
            let Ie = [be], Oe = A(Ce, Be, ve), Je = Ye.type === "ClassExpression" && Oe;
            if (Oe && (Ie = [...Oe, be], !Je)) return l(Ie);
            if (!F(Ce, Be)) return ze && ze.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === be ? be : Ie;
            if (Je && (Ie = [p([n, ...Ie])]), Ie.unshift("("), ze && ze.needsSemi && Ie.unshift(";"), w(Ye)) {
              let [je] = Ye.trailingComments;
              Ie.push(" /*", je.value.trimStart(), "*/"), je.printed = true;
            }
            return Je && Ie.push(n), Ie.push(")"), Ie;
          }
          function re(Ce, Be, ve, ze) {
            let be = Ce.getValue(), Ye = Be.semi ? ";" : "";
            if (!be) return "";
            if (typeof be == "string") return be;
            for (let Ie of [De, S, B, k, R, q]) {
              let Oe = Ie(Ce, Be, ve);
              if (typeof Oe < "u") return Oe;
            }
            let Se = [];
            switch (be.type) {
              case "JsExpressionRoot":
                return ve("node");
              case "JsonRoot":
                return [ve("node"), u];
              case "File":
                return be.program && be.program.interpreter && Se.push(ve(["program", "interpreter"])), Se.push(ve("program")), Se;
              case "Program":
                return Ae(Ce, Be, ve);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement": {
                if (Be.parser === "__vue_event_binding" || Be.parser === "__vue_ts_event_binding") {
                  let Oe = Ce.getParentNode();
                  if (Oe.type === "Program" && Oe.body.length === 1 && Oe.body[0] === be) return [ve("expression"), b(be.expression) ? ";" : ""];
                }
                let Ie = t(Ce, Be, true, (Oe) => {
                  let { marker: Je } = Oe;
                  return Je === C;
                });
                return [ve("expression"), x(Be, Ce) ? "" : Ye, Ie ? [" ", Ie] : ""];
              }
              case "ParenthesizedExpression":
                return !E(be.expression) && (be.expression.type === "ObjectExpression" || be.expression.type === "ArrayExpression") ? ["(", ve("expression"), ")"] : l(["(", p([i, ve("expression")]), i, ")"]);
              case "AssignmentExpression":
                return oe(Ce, Be, ve);
              case "VariableDeclarator":
                return Pe(Ce, Be, ve);
              case "BinaryExpression":
              case "LogicalExpression":
                return H(Ce, Be, ve);
              case "AssignmentPattern":
                return [ve("left"), " = ", ve("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return X(Ce, Be, ve);
              case "MetaProperty":
                return [ve("meta"), ".", ve("property")];
              case "BindExpression":
                return be.object && Se.push(ve("object")), Se.push(l(p([i, L(Ce, Be, ve)]))), Se;
              case "Identifier":
                return [be.name, J(Ce), Y(Ce), Q(Ce, Be, ve)];
              case "V8IntrinsicIdentifier":
                return ["%", be.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return j(Ce, Be, ve);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return ge(Ce, ve, Be, ze);
              case "ArrowFunctionExpression":
                return he(Ce, Be, ve, ze);
              case "YieldExpression":
                return Se.push("yield"), be.delegate && Se.push("*"), be.argument && Se.push(" ", ve("argument")), Se;
              case "AwaitExpression": {
                if (Se.push("await"), be.argument) {
                  Se.push(" ", ve("argument"));
                  let Ie = Ce.getParentNode();
                  if (T(Ie) && Ie.callee === be || m(Ie) && Ie.object === be) {
                    Se = [p([i, ...Se]), i];
                    let Oe = Ce.findAncestor((Je) => Je.type === "AwaitExpression" || Je.type === "BlockStatement");
                    if (!Oe || Oe.type !== "AwaitExpression") return l(Se);
                  }
                }
                return Se;
              }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return ce(Ce, Be, ve);
              case "ExportAllDeclaration":
                return W(Ce, Be, ve);
              case "ImportDeclaration":
                return ee(Ce, Be, ve);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return K(Ce, Be, ve);
              case "ImportAttribute":
                return [ve("key"), ": ", ve("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return le(Ce, Be, ve);
              case "ThrowStatement":
                return Re(Ce, Be, ve);
              case "ReturnStatement":
                return ke(Ce, Be, ve);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return Ne(Ce, Be, ve);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return z(Ce, Be, ve);
              case "ObjectProperty":
              case "Property":
                return be.method || be.kind === "get" || be.kind === "set" ? we(Ce, Be, ve) : fe(Ce, Be, ve);
              case "ObjectMethod":
                return we(Ce, Be, ve);
              case "Decorator":
                return ["@", ve("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return Fe(Ce, Be, ve);
              case "SequenceExpression": {
                let Ie = Ce.getParentNode(0);
                if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
                  let Oe = [];
                  return Ce.each((Je, Te) => {
                    Te === 0 ? Oe.push(ve()) : Oe.push(",", p([n, ve()]));
                  }, "expressions"), l(Oe);
                }
                return l(a([",", n], Ce.map(ve, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [ve("value"), Ye];
              case "DirectiveLiteral":
                return ie(be.extra.raw, Be);
              case "UnaryExpression":
                return Se.push(be.operator), /[a-z]$/.test(be.operator) && Se.push(" "), E(be.argument) ? Se.push(l(["(", p([i, ve("argument")]), i, ")"])) : Se.push(ve("argument")), Se;
              case "UpdateExpression":
                return Se.push(ve("argument"), be.operator), be.prefix && Se.reverse(), Se;
              case "ConditionalExpression":
                return de(Ce, Be, ve);
              case "VariableDeclaration": {
                let Ie = Ce.map(ve, "declarations"), Oe = Ce.getParentNode(), Je = Oe.type === "ForStatement" || Oe.type === "ForInStatement" || Oe.type === "ForOfStatement", Te = be.declarations.some((Me) => Me.init), je;
                return Ie.length === 1 && !E(be.declarations[0]) ? je = Ie[0] : Ie.length > 0 && (je = p(Ie[0])), Se = [be.declare ? "declare " : "", be.kind, je ? [" ", je] : "", p(Ie.slice(1).map((Me) => [",", Te && !Je ? u : n, Me]))], Je && Oe.body !== be || Se.push(Ye), l(Se);
              }
              case "WithStatement":
                return l(["with (", ve("object"), ")", V(be.body, ve("body"))]);
              case "IfStatement": {
                let Ie = V(be.consequent, ve("consequent")), Oe = l(["if (", l([p([i, ve("test")]), i]), ")", Ie]);
                if (Se.push(Oe), be.alternate) {
                  let Je = E(be.consequent, N.Trailing | N.Line) || $(be), Te = be.consequent.type === "BlockStatement" && !Je;
                  Se.push(Te ? " " : u), E(be, N.Dangling) && Se.push(t(Ce, Be, true), Je ? u : " "), Se.push("else", l(V(be.alternate, ve("alternate"), be.alternate.type === "IfStatement")));
                }
                return Se;
              }
              case "ForStatement": {
                let Ie = V(be.body, ve("body")), Oe = t(Ce, Be, true), Je = Oe ? [Oe, i] : "";
                return !be.init && !be.test && !be.update ? [Je, l(["for (;;)", Ie])] : [Je, l(["for (", l([p([i, ve("init"), ";", n, ve("test"), ";", n, ve("update")]), i]), ")", Ie])];
              }
              case "WhileStatement":
                return l(["while (", l([p([i, ve("test")]), i]), ")", V(be.body, ve("body"))]);
              case "ForInStatement":
                return l(["for (", ve("left"), " in ", ve("right"), ")", V(be.body, ve("body"))]);
              case "ForOfStatement":
                return l(["for", be.await ? " await" : "", " (", ve("left"), " of ", ve("right"), ")", V(be.body, ve("body"))]);
              case "DoWhileStatement": {
                let Ie = V(be.body, ve("body"));
                return Se = [l(["do", Ie])], be.body.type === "BlockStatement" ? Se.push(" ") : Se.push(u), Se.push("while (", l([p([i, ve("test")]), i]), ")", Ye), Se;
              }
              case "DoExpression":
                return [be.async ? "async " : "", "do ", ve("body")];
              case "BreakStatement":
                return Se.push("break"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
              case "ContinueStatement":
                return Se.push("continue"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
              case "LabeledStatement":
                return be.body.type === "EmptyStatement" ? [ve("label"), ":;"] : [ve("label"), ": ", ve("body")];
              case "TryStatement":
                return ["try ", ve("block"), be.handler ? [" ", ve("handler")] : "", be.finalizer ? [" finally ", ve("finalizer")] : ""];
              case "CatchClause":
                if (be.param) {
                  let Ie = E(be.param, (Je) => !v(Je) || Je.leading && s(Be.originalText, d(Je)) || Je.trailing && s(Be.originalText, o(Je), { backwards: true })), Oe = ve("param");
                  return ["catch ", Ie ? ["(", p([i, Oe]), i, ") "] : ["(", Oe, ") "], ve("body")];
                }
                return ["catch ", ve("body")];
              case "SwitchStatement":
                return [l(["switch (", p([i, ve("discriminant")]), i, ")"]), " {", be.cases.length > 0 ? p([u, a(u, Ce.map((Ie, Oe, Je) => {
                  let Te = Ie.getValue();
                  return [ve(), Oe !== Je.length - 1 && P(Te, Be) ? u : ""];
                }, "cases"))]) : "", u, "}"];
              case "SwitchCase": {
                be.test ? Se.push("case ", ve("test"), ":") : Se.push("default:"), E(be, N.Dangling) && Se.push(" ", t(Ce, Be, true));
                let Ie = be.consequent.filter((Oe) => Oe.type !== "EmptyStatement");
                if (Ie.length > 0) {
                  let Oe = pe(Ce, Be, ve);
                  Se.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [" ", Oe] : p([u, Oe]));
                }
                return Se;
              }
              case "DebuggerStatement":
                return ["debugger", Ye];
              case "ClassDeclaration":
              case "ClassExpression":
                return U(Ce, Be, ve);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return Z(Ce, Be, ve);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
              case "AccessorProperty":
                return se(Ce, Be, ve);
              case "TemplateElement":
                return y(be.value.raw);
              case "TemplateLiteral":
                return ue(Ce, ve, Be);
              case "TaggedTemplateExpression":
                return [ve("tag"), ve("typeParameters"), ve("quasi")];
              case "PrivateIdentifier":
                return ["#", ve("name")];
              case "PrivateName":
                return ["#", ve("id")];
              case "InterpreterDirective":
                return Se.push("#!", be.value, u), P(be, Be) && Se.push(u), Se;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                Se.push("module {");
                let Ie = ve("body");
                return Ie && Se.push(p([u, Ie]), u), Se.push("}"), Se;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(be.type));
            }
          }
          function ye(Ce) {
            return Ce.type && !v(Ce) && !I(Ce) && Ce.type !== "EmptyStatement" && Ce.type !== "TemplateElement" && Ce.type !== "Import" && Ce.type !== "TSEmptyBodyFunctionExpression";
          }
          r2.exports = { preprocess: _, print: G, embed: h, insertPragma: c2, massageAstNode: g, hasPrettierIgnore(Ce) {
            return D(Ce) || M(Ce);
          }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: ye, printComment: Ee, isBlockComment: v, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
        } }), Ed = te({ "src/language-js/printer-estree-json.js"(e, r2) {
          ne();
          var { builders: { hardline: t, indent: s, join: a } } = qe(), n = Fo();
          function u(y, h, g) {
            let c2 = y.getValue();
            switch (c2.type) {
              case "JsonRoot":
                return [g("node"), t];
              case "ArrayExpression": {
                if (c2.elements.length === 0) return "[]";
                let f = y.map(() => y.getValue() === null ? "null" : g(), "elements");
                return ["[", s([t, a([",", t], f)]), t, "]"];
              }
              case "ObjectExpression":
                return c2.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], y.map(g, "properties"))]), t, "}"];
              case "ObjectProperty":
                return [g("key"), ": ", g("value")];
              case "UnaryExpression":
                return [c2.operator === "+" ? "" : c2.operator, g("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return c2.value ? "true" : "false";
              case "StringLiteral":
                return JSON.stringify(c2.value);
              case "NumericLiteral":
                return i(y) ? JSON.stringify(String(c2.value)) : JSON.stringify(c2.value);
              case "Identifier":
                return i(y) ? JSON.stringify(c2.name) : c2.name;
              case "TemplateLiteral":
                return g(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(c2.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(c2.type));
            }
          }
          function i(y) {
            return y.getName() === "key" && y.getParentNode().type === "ObjectProperty";
          }
          var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function p(y, h) {
            let { type: g } = y;
            if (g === "ObjectProperty") {
              let { key: c2 } = y;
              c2.type === "Identifier" ? h.key = { type: "StringLiteral", value: c2.name } : c2.type === "NumericLiteral" && (h.key = { type: "StringLiteral", value: String(c2.value) });
              return;
            }
            if (g === "UnaryExpression" && y.operator === "+") return h.argument;
            if (g === "ArrayExpression") {
              for (let [c2, f] of y.elements.entries()) f === null && h.elements.splice(c2, 0, { type: "NullLiteral" });
              return;
            }
            if (g === "TemplateLiteral") return { type: "StringLiteral", value: y.quasis[0].value.cooked };
          }
          p.ignoredProperties = l, r2.exports = { preprocess: n, print: u, massageAstNode: p };
        } }), Mt = te({ "src/common/common-options.js"(e, r2) {
          ne();
          var t = "Common";
          r2.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        } }), Fd = te({ "src/language-js/options.js"(e, r2) {
          ne();
          var t = Mt(), s = "JavaScript";
          r2.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
        } }), Ad = te({ "src/language-js/parse/parsers.js"() {
          ne();
        } }), Ln = te({ "node_modules/linguist-languages/data/JavaScript.json"(e, r2) {
          r2.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
        } }), Sd = te({ "node_modules/linguist-languages/data/TypeScript.json"(e, r2) {
          r2.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
        } }), xd = te({ "node_modules/linguist-languages/data/TSX.json"(e, r2) {
          r2.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
        } }), wa = te({ "node_modules/linguist-languages/data/JSON.json"(e, r2) {
          r2.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
        } }), bd = te({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, r2) {
          r2.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
        } }), Td = te({ "node_modules/linguist-languages/data/JSON5.json"(e, r2) {
          r2.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        } }), Bd = te({ "src/language-js/index.js"(e, r2) {
          ne();
          var t = _t(), s = Cd(), a = Ed(), n = Fd(), u = Ad(), i = [t(Ln(), (p) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p.interpreters, "zx"], extensions: [...p.extensions.filter((y) => y !== ".jsx"), ".wxs"] })), t(Ln(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Ln(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(Sd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(xd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(wa(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(wa(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p.extensions.filter((y) => y !== ".jsonl") })), t(bd(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p.filenames, ".eslintrc", ".swcrc"] })), t(Td(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a };
          r2.exports = { languages: i, options: n, printers: l, parsers: u };
        } }), Nd = te({ "src/language-css/clean.js"(e, r2) {
          ne();
          var { isFrontMatterNode: t } = Ue(), s = lt(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function n(i, l, p) {
            if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && p.type === "css-root" && p.nodes.length > 0 && ((p.nodes[0] === i || t(p.nodes[0]) && p.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || p.type === "css-root" && s(p.nodes) === i)) return null;
            if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y, h, g) => {
              let c2 = Number(h);
              return Number.isNaN(c2) ? y : c2 + g.toLowerCase();
            })), i.type === "selector-tag") {
              let y = i.value.toLowerCase();
              ["from", "to"].includes(y) && (l.value = y);
            }
            if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
              let y = i.groups.findIndex((h) => h.type === "value-number" && h.unit === "...");
              y !== -1 && (l.groups[y].unit = "", l.groups.splice(y + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
            }
            if (i.type === "value-comma_group" && i.groups.some((y) => y.type === "value-atword" && y.value.endsWith("[") || y.type === "value-word" && y.value.startsWith("]"))) return { type: "value-atword", value: i.groups.map((y) => y.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
          }
          n.ignoredProperties = a;
          function u(i) {
            return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          r2.exports = n;
        } }), su = te({ "src/utils/front-matter/print.js"(e, r2) {
          ne();
          var { builders: { hardline: t, markAsRoot: s } } = qe();
          function a(n, u) {
            if (n.lang === "yaml") {
              let i = n.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
              return s([n.startDelimiter, t, l, l ? t : "", n.endDelimiter]);
            }
          }
          r2.exports = a;
        } }), wd = te({ "src/language-css/embed.js"(e, r2) {
          ne();
          var { builders: { hardline: t } } = qe(), s = su();
          function a(n, u, i) {
            let l = n.getValue();
            if (l.type === "front-matter") {
              let p = s(l, i);
              return p ? [p, t] : "";
            }
          }
          r2.exports = a;
        } }), _o = te({ "src/utils/front-matter/parse.js"(e, r2) {
          ne();
          var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s(a) {
            let n = a.match(t);
            if (!n) return { content: a };
            let { startDelimiter: u, language: i, value: l = "", endDelimiter: p } = n.groups, y = i.trim() || "yaml";
            if (u === "+++" && (y = "toml"), y !== "yaml" && u !== p) return { content: a };
            let [h] = n;
            return { frontMatter: { type: "front-matter", lang: y, value: l, startDelimiter: u, endDelimiter: p, raw: h.replace(/\n$/, "") }, content: h.replace(/[^\n]/g, " ") + a.slice(h.length) };
          }
          r2.exports = s;
        } }), _d = te({ "src/language-css/pragma.js"(e, r2) {
          ne();
          var t = Co(), s = _o();
          function a(u) {
            return t.hasPragma(s(u).content);
          }
          function n(u) {
            let { frontMatter: i, content: l } = s(u);
            return (i ? i.raw + `

` : "") + t.insertPragma(l);
          }
          r2.exports = { hasPragma: a, insertPragma: n };
        } }), Pd = te({ "src/language-css/utils/index.js"(e, r2) {
          ne();
          var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function s(z, U) {
            let Z = Array.isArray(U) ? U : [U], se = -1, fe;
            for (; fe = z.getParentNode(++se); ) if (Z.includes(fe.type)) return se;
            return -1;
          }
          function a(z, U) {
            let Z = s(z, U);
            return Z === -1 ? null : z.getParentNode(Z);
          }
          function n(z) {
            var U;
            let Z = a(z, "css-decl");
            return Z == null || (U = Z.prop) === null || U === void 0 ? void 0 : U.toLowerCase();
          }
          var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
          function i(z) {
            return u.has(z.toLowerCase());
          }
          function l(z, U) {
            let Z = a(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U.toLowerCase());
          }
          function p(z) {
            return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
          }
          function y(z, U) {
            var Z;
            let se = a(z, "value-func");
            return (se == null || (Z = se.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U;
          }
          function h(z) {
            var U;
            let Z = a(z, "css-rule"), se = Z == null || (U = Z.raws) === null || U === void 0 ? void 0 : U.selector;
            return se && (se.startsWith(":import") || se.startsWith(":export"));
          }
          function g(z, U) {
            let Z = Array.isArray(U) ? U : [U], se = a(z, "css-atrule");
            return se && Z.includes(se.name.toLowerCase());
          }
          function c2(z) {
            let U = z.getValue(), Z = a(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) === "import" && U.groups[0].value === "url" && U.groups.length === 2;
          }
          function f(z) {
            return z.type === "value-func" && z.value.toLowerCase() === "url";
          }
          function F(z, U) {
            var Z;
            let se = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
            return se && se.indexOf(U) === se.length - 1;
          }
          function _(z) {
            let { selector: U } = z;
            return U ? typeof U == "string" && /^@.+:.*$/.test(U) || U.value && /^@.+:.*$/.test(U.value) : false;
          }
          function w(z) {
            return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
          }
          function E(z) {
            return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
          }
          function N(z) {
            return z.type === "value-word" && z.value === "in";
          }
          function x(z) {
            return z.type === "value-operator" && z.value === "*";
          }
          function I(z) {
            return z.type === "value-operator" && z.value === "/";
          }
          function P(z) {
            return z.type === "value-operator" && z.value === "+";
          }
          function $(z) {
            return z.type === "value-operator" && z.value === "-";
          }
          function D(z) {
            return z.type === "value-operator" && z.value === "%";
          }
          function T(z) {
            return x(z) || I(z) || P(z) || $(z) || D(z);
          }
          function m(z) {
            return z.type === "value-word" && ["==", "!="].includes(z.value);
          }
          function C(z) {
            return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
          }
          function o(z) {
            return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
          }
          function d(z) {
            var U;
            return ((U = z.raws) === null || U === void 0 ? void 0 : U.params) && /^\(\s*\)$/.test(z.raws.params);
          }
          function v(z) {
            return z.name.startsWith("prettier-placeholder");
          }
          function S(z) {
            return z.prop.startsWith("@prettier-placeholder");
          }
          function b(z, U) {
            return z.value === "$$" && z.type === "value-func" && (U == null ? void 0 : U.type) === "value-word" && !U.raws.before;
          }
          function B(z) {
            var U, Z;
            return ((U = z.value) === null || U === void 0 ? void 0 : U.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
          }
          function k(z) {
            var U, Z, se;
            return ((U = z.value) === null || U === void 0 || (Z = U.group) === null || Z === void 0 || (se = Z.group) === null || se === void 0 ? void 0 : se.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
          }
          function M(z) {
            var U;
            return ((U = z.raws) === null || U === void 0 ? void 0 : U.before) === "";
          }
          function R(z) {
            var U, Z;
            return z.type === "value-comma_group" && ((U = z.groups) === null || U === void 0 || (Z = U[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
          }
          function q(z) {
            var U;
            return z.type === "value-paren_group" && ((U = z.groups) === null || U === void 0 ? void 0 : U[0]) && R(z.groups[0]);
          }
          function J(z) {
            var U;
            let Z = z.getValue();
            if (Z.groups.length === 0) return false;
            let se = z.getParentNode(1);
            if (!q(Z) && !(se && q(se))) return false;
            let fe = a(z, "css-decl");
            return !!(fe != null && (U = fe.prop) !== null && U !== void 0 && U.startsWith("$") || q(se) || se.type === "value-func");
          }
          function L(z) {
            return z.type === "value-comment" && z.inline;
          }
          function Q(z) {
            return z.type === "value-word" && z.value === "#";
          }
          function V(z) {
            return z.type === "value-word" && z.value === "{";
          }
          function j(z) {
            return z.type === "value-word" && z.value === "}";
          }
          function Y(z) {
            return ["value-word", "value-atword"].includes(z.type);
          }
          function ie(z) {
            return (z == null ? void 0 : z.type) === "value-colon";
          }
          function ee(z, U) {
            if (!R(U)) return false;
            let { groups: Z } = U, se = Z.indexOf(z);
            return se === -1 ? false : ie(Z[se + 1]);
          }
          function ce(z) {
            return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
          }
          function W(z) {
            return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
          }
          function K(z) {
            return /\/\//.test(z.split(/[\n\r]/).pop());
          }
          function de(z) {
            return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
          }
          function ue(z, U) {
            var Z, se;
            if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se = z.close) === null || se === void 0 ? void 0 : se.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group")) return false;
            if (U.type === "value-comma_group") {
              let fe = U.groups.indexOf(z) - 1, ge = U.groups[fe];
              if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with") return true;
            }
            return false;
          }
          function Fe(z) {
            var U, Z;
            return z.type === "value-paren_group" && ((U = z.open) === null || U === void 0 ? void 0 : U.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
          }
          r2.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: n, maybeToLowerCase: p, insideValueFunctionNode: y, insideICSSRuleNode: h, insideAtRuleNode: g, insideURLFunctionInImportAtRuleNode: c2, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: F, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C, isEqualityOperatorNode: m, isMultiplicationNode: x, isDivisionNode: I, isAdditionNode: P, isSubtractionNode: $, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N, isForKeywordNode: w, isURLFunctionNode: f, isIfElseKeywordNode: E, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M, isDetachedRulesetCallNode: d, isTemplatePlaceholderNode: v, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: ee, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Q, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j, isWordNode: Y, isColonNode: ie, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K, isAtWordPlaceholderNode: de, isConfigurationNode: ue, isParenGroupNode: Fe };
        } }), Id = te({ "src/utils/line-column-to-index.js"(e, r2) {
          ne(), r2.exports = function(t, s) {
            let a = 0;
            for (let n = 0; n < t.line - 1; ++n) a = s.indexOf(`
`, a) + 1;
            return a + t.column;
          };
        } }), kd = te({ "src/language-css/loc.js"(e, r2) {
          ne();
          var { skipEverythingButNewLine: t } = Pr(), s = lt(), a = Id();
          function n(c2, f) {
            return typeof c2.sourceIndex == "number" ? c2.sourceIndex : c2.source ? a(c2.source.start, f) - 1 : null;
          }
          function u(c2, f) {
            if (c2.type === "css-comment" && c2.inline) return t(f, c2.source.startOffset);
            let F = c2.nodes && s(c2.nodes);
            return F && c2.source && !c2.source.end && (c2 = F), c2.source && c2.source.end ? a(c2.source.end, f) : null;
          }
          function i(c2, f) {
            c2.source && (c2.source.startOffset = n(c2, f), c2.source.endOffset = u(c2, f));
            for (let F in c2) {
              let _ = c2[F];
              F === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p(c2), _.text || _.value) : i(_, f));
            }
          }
          function l(c2, f, F) {
            c2.source && (c2.source.startOffset = n(c2, F) + f, c2.source.endOffset = u(c2, F) + f);
            for (let _ in c2) {
              let w = c2[_];
              _ === "source" || !w || typeof w != "object" || l(w, f, F);
            }
          }
          function p(c2) {
            let f = c2.source.startOffset;
            return typeof c2.prop == "string" && (f += c2.prop.length), c2.type === "css-atrule" && typeof c2.name == "string" && (f += 1 + c2.name.length + c2.raws.afterName.match(/^\s*:?\s*/)[0].length), c2.type !== "css-atrule" && c2.raws && typeof c2.raws.between == "string" && (f += c2.raws.between.length), f;
          }
          function y(c2) {
            let f = "initial", F = "initial", _, w = false, E = [];
            for (let N = 0; N < c2.length; N++) {
              let x = c2[N];
              switch (f) {
                case "initial":
                  if (x === "'") {
                    f = "single-quotes";
                    continue;
                  }
                  if (x === '"') {
                    f = "double-quotes";
                    continue;
                  }
                  if ((x === "u" || x === "U") && c2.slice(N, N + 4).toLowerCase() === "url(") {
                    f = "url", N += 3;
                    continue;
                  }
                  if (x === "*" && c2[N - 1] === "/") {
                    f = "comment-block";
                    continue;
                  }
                  if (x === "/" && c2[N - 1] === "/") {
                    f = "comment-inline", _ = N - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (x === "'" && c2[N - 1] !== "\\" && (f = F, F = "initial"), x === `
` || x === "\r") return c2;
                  continue;
                case "double-quotes":
                  if (x === '"' && c2[N - 1] !== "\\" && (f = F, F = "initial"), x === `
` || x === "\r") return c2;
                  continue;
                case "url":
                  if (x === ")" && (f = "initial"), x === `
` || x === "\r") return c2;
                  if (x === "'") {
                    f = "single-quotes", F = "url";
                    continue;
                  }
                  if (x === '"') {
                    f = "double-quotes", F = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  x === "/" && c2[N - 1] === "*" && (f = "initial");
                  continue;
                case "comment-inline":
                  (x === '"' || x === "'" || x === "*") && (w = true), (x === `
` || x === "\r") && (w && E.push([_, N]), f = "initial", w = false);
                  continue;
              }
            }
            for (let [N, x] of E) c2 = c2.slice(0, N) + c2.slice(N, x).replace(/["'*]/g, " ") + c2.slice(x);
            return c2;
          }
          function h(c2) {
            return c2.source.startOffset;
          }
          function g(c2) {
            return c2.source.endOffset;
          }
          r2.exports = { locStart: h, locEnd: g, calculateLoc: i, replaceQuotesInInlineComments: y };
        } }), Ld = te({ "src/language-css/utils/is-less-parser.js"(e, r2) {
          ne();
          function t(s) {
            return s.parser === "css" || s.parser === "less";
          }
          r2.exports = t;
        } }), Od = te({ "src/language-css/utils/is-scss.js"(e, r2) {
          ne();
          function t(s, a) {
            return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
          }
          r2.exports = t;
        } }), jd = te({ "src/language-css/utils/css-units.evaluate.js"(e, r2) {
          r2.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
        } }), qd = te({ "src/language-css/utils/print-unit.js"(e, r2) {
          ne();
          var t = jd();
          function s(a) {
            let n = a.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t, n) ? t[n] : a;
          }
          r2.exports = s;
        } }), Md = te({ "src/language-css/printer-postcss.js"(e, r2) {
          ne();
          var t = lt(), { printNumber: s, printString: a, hasNewline: n, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ue(), { builders: { join: p, line: y, hardline: h, softline: g, group: c2, fill: f, indent: F, dedent: _, ifBreak: w, breakParent: E }, utils: { removeLines: N, getDocParts: x } } = qe(), I = Nd(), P = wd(), { insertPragma: $ } = _d(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m, insideValueFunctionNode: C, insideICSSRuleNode: o, insideAtRuleNode: d, insideURLFunctionInImportAtRuleNode: v, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: R, isEqualityOperatorNode: q, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Q, isSubtractionNode: V, isMathOperatorNode: j, isEachKeywordNode: Y, isForKeywordNode: ie, isURLFunctionNode: ee, isIfElseKeywordNode: ce, hasComposesNode: W, hasParensAroundNode: K, hasEmptyRawBefore: de, isKeyValuePairNode: ue, isKeyInValuePairNode: Fe, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U, isTemplatePropNode: Z, isPostcssSimpleVarNode: se, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: he, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: ke, isWordNode: Re, isColonNode: Ne, isMediaAndSupportsKeywords: Pe, isColorAdjusterFuncNode: oe, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe, isConfigurationNode: X, isParenGroupNode: le } = Pd(), { locStart: Ae, locEnd: Ee } = kd(), De = Ld(), A = Od(), G = qd();
          function re(Te) {
            return Te.trailingComma === "es5" || Te.trailingComma === "all";
          }
          function ye(Te, je, Me) {
            let ae = Te.getValue();
            if (!ae) return "";
            if (typeof ae == "string") return ae;
            switch (ae.type) {
              case "front-matter":
                return [ae.raw, h];
              case "css-root": {
                let Ve = Ce(Te, je, Me), We = ae.raws.after.trim();
                return We.startsWith(";") && (We = We.slice(1).trim()), [Ve, We ? ` ${We}` : "", x(Ve).length > 0 ? h : ""];
              }
              case "css-comment": {
                let Ve = ae.inline || ae.raws.inline, We = je.originalText.slice(Ae(ae), Ee(ae));
                return Ve ? We.trimEnd() : We;
              }
              case "css-rule":
                return [Me("selector"), ae.important ? " !important" : "", ae.nodes ? [ae.selector && ae.selector.type === "selector-unknown" && H(ae.selector.value) ? y : " ", "{", ae.nodes.length > 0 ? F([h, Ce(Te, je, Me)]) : "", h, "}", M(ae) ? ";" : ""] : ";"];
              case "css-decl": {
                let Ve = Te.getParentNode(), { between: We } = ae.raws, Xe = We.trim(), st = Xe === ":", O = W(ae) ? N(Me("value")) : Me("value");
                return !st && H(Xe) && (O = F([h, _(O)])), [ae.raws.before.replace(/[\s;]/g, ""), Ve.type === "css-atrule" && Ve.variable || o(Te) ? ae.prop : m(ae.prop), Xe.startsWith("//") ? " " : "", Xe, ae.extend ? "" : " ", De(je) && ae.extend && ae.selector ? ["extend(", Me("selector"), ")"] : "", O, ae.raws.important ? ae.raws.important.replace(/\s*!\s*important/i, " !important") : ae.important ? " !important" : "", ae.raws.scssDefault ? ae.raws.scssDefault.replace(/\s*!default/i, " !default") : ae.scssDefault ? " !default" : "", ae.raws.scssGlobal ? ae.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae.scssGlobal ? " !global" : "", ae.nodes ? [" {", F([g, Ce(Te, je, Me)]), g, "}"] : Z(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";" ? "" : je.__isHTMLStyleAttribute && B(Te, ae) ? w(";") : ";"];
              }
              case "css-atrule": {
                let Ve = Te.getParentNode(), We = U(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";";
                if (De(je)) {
                  if (ae.mixin) return [Me("selector"), ae.important ? " !important" : "", We ? "" : ";"];
                  if (ae.function) return [ae.name, Me("params"), We ? "" : ";"];
                  if (ae.variable) return ["@", ae.name, ": ", ae.value ? Me("value") : "", ae.raws.between.trim() ? ae.raws.between.trim() + " " : "", ae.nodes ? ["{", F([ae.nodes.length > 0 ? g : "", Ce(Te, je, Me)]), g, "}"] : "", We ? "" : ";"];
                }
                return ["@", z(ae) || ae.name.endsWith(":") ? ae.name : m(ae.name), ae.params ? [z(ae) ? "" : U(ae) ? ae.raws.afterName === "" ? "" : ae.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae.raws.afterName) ? [h, h] : /^\s*\n/.test(ae.raws.afterName) ? h : " " : " ", Me("params")] : "", ae.selector ? F([" ", Me("selector")]) : "", ae.value ? c2([" ", Me("value"), k(ae) ? K(ae) ? " " : y : ""]) : ae.name === "else" ? " " : "", ae.nodes ? [k(ae) ? "" : ae.selector && !ae.selector.nodes && typeof ae.selector.value == "string" && H(ae.selector.value) || !ae.selector && typeof ae.params == "string" && H(ae.params) ? y : " ", "{", F([ae.nodes.length > 0 ? g : "", Ce(Te, je, Me)]), g, "}"] : We ? "" : ";"];
              }
              case "media-query-list": {
                let Ve = [];
                return Te.each((We) => {
                  let Xe = We.getValue();
                  Xe.type === "media-query" && Xe.value === "" || Ve.push(Me());
                }, "nodes"), c2(F(p(y, Ve)));
              }
              case "media-query":
                return [p(" ", Te.map(Me, "nodes")), B(Te, ae) ? "" : ","];
              case "media-type":
                return Oe(Se(ae.value, je));
              case "media-feature-expression":
                return ae.nodes ? ["(", ...Te.map(Me, "nodes"), ")"] : ae.value;
              case "media-feature":
                return m(Se(ae.value.replace(/ +/g, " "), je));
              case "media-colon":
                return [ae.value, " "];
              case "media-value":
                return Oe(Se(ae.value, je));
              case "media-keyword":
                return Se(ae.value, je);
              case "media-url":
                return Se(ae.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je);
              case "media-unknown":
                return ae.value;
              case "selector-root":
                return c2([d(Te, "custom-selector") ? [D(Te, "css-atrule").customSelector, y] : "", p([",", d(Te, ["extend", "custom-selector", "nest"]) ? y : h], Te.map(Me, "nodes"))]);
              case "selector-selector":
                return c2(F(Te.map(Me, "nodes")));
              case "selector-comment":
                return ae.value;
              case "selector-string":
                return Se(ae.value, je);
              case "selector-tag": {
                let Ve = Te.getParentNode(), We = Ve && Ve.nodes.indexOf(ae), Xe = We && Ve.nodes[We - 1];
                return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ae.value : Oe(S(Te, ae.value) ? ae.value.toLowerCase() : ae.value)];
              }
              case "selector-id":
                return ["#", ae.value];
              case "selector-class":
                return [".", Oe(Se(ae.value, je))];
              case "selector-attribute": {
                var nt;
                return ["[", ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.attribute.trim(), (nt = ae.operator) !== null && nt !== void 0 ? nt : "", ae.value ? Ie(Se(ae.value.trim(), je), je) : "", ae.insensitive ? " i" : "", "]"];
              }
              case "selector-combinator": {
                if (ae.value === "+" || ae.value === ">" || ae.value === "~" || ae.value === ">>>") {
                  let Xe = Te.getParentNode();
                  return [Xe.type === "selector-selector" && Xe.nodes[0] === ae ? "" : y, ae.value, B(Te, ae) ? "" : " "];
                }
                let Ve = ae.value.trim().startsWith("(") ? y : "", We = Oe(Se(ae.value.trim(), je)) || y;
                return [Ve, We];
              }
              case "selector-universal":
                return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.value];
              case "selector-pseudo":
                return [m(ae.value), l(ae.nodes) ? c2(["(", F([g, p([",", y], Te.map(Me, "nodes"))]), g, ")"]) : ""];
              case "selector-nesting":
                return ae.value;
              case "selector-unknown": {
                let Ve = D(Te, "css-rule");
                if (Ve && Ve.isSCSSNesterProperty) return Oe(Se(m(ae.value), je));
                let We = Te.getParentNode();
                if (We.raws && We.raws.selector) {
                  let st = Ae(We), O = st + We.raws.selector.length;
                  return je.originalText.slice(st, O).trim();
                }
                let Xe = Te.getParentNode(1);
                if (We.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
                  let st = Ee(We.open) + 1, O = Ae(We.close), me = je.originalText.slice(st, O).trim();
                  return H(me) ? [E, me] : me;
                }
                return ae.value;
              }
              case "value-value":
              case "value-root":
                return Me("group");
              case "value-comment":
                return je.originalText.slice(Ae(ae), Ee(ae));
              case "value-comma_group": {
                let Ve = Te.getParentNode(), We = Te.getParentNode(1), Xe = T(Te), st = Xe && Ve.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), O = D(Te, "css-atrule"), me = O && k(O), _e = ae.groups.some((at) => ge(at)), He = Te.map(Me, "groups"), Ge = [], it = C(Te, "url"), Qe = false, rt = false;
                for (let at = 0; at < ae.groups.length; ++at) {
                  var tt;
                  Ge.push(He[at]);
                  let Ze = ae.groups[at - 1], Le = ae.groups[at], $e = ae.groups[at + 1], sr = ae.groups[at + 2];
                  if (it) {
                    ($e && Q($e) || Q(Le)) && Ge.push(" ");
                    continue;
                  }
                  if (d(Te, "forward") && Le.type === "value-word" && Le.value && Ze !== void 0 && Ze.type === "value-word" && Ze.value === "as" && $e.type === "value-operator" && $e.value === "*" || !$e || Le.type === "value-word" && Le.value.endsWith("-") && pe($e)) continue;
                  if (Le.type === "value-string" && Le.quoted) {
                    let $r = Le.value.lastIndexOf("#{"), Vr = Le.value.lastIndexOf("}");
                    $r !== -1 && Vr !== -1 ? Qe = $r > Vr : $r !== -1 ? Qe = true : Vr !== -1 && (Qe = false);
                  }
                  if (Qe || Ne(Le) || Ne($e) || Le.type === "value-atword" && (Le.value === "" || Le.value.endsWith("[")) || $e.type === "value-word" && $e.value.startsWith("]") || Le.value === "~" || Le.value && Le.value.includes("\\") && $e && $e.type !== "value-comment" || Ze && Ze.value && Ze.value.indexOf("\\") === Ze.value.length - 1 && Le.type === "value-operator" && Le.value === "/" || Le.value === "\\" || se(Le, $e) || he(Le) || we(Le) || ke($e) || we($e) && de($e) || ke(Le) && de($e) || Le.value === "--" && he($e)) continue;
                  let Rr = j(Le), ou = j($e);
                  if ((Rr && he($e) || ou && ke(Le)) && de($e) || !Ze && L(Le) || C(Te, "calc") && (Q(Le) || Q($e) || V(Le) || V($e)) && de($e)) continue;
                  let qo = (Q(Le) || V(Le)) && at === 0 && ($e.type === "value-number" || $e.isHex) && We && oe(We) && !de($e), lu = sr && sr.type === "value-func" || sr && Re(sr) || Le.type === "value-func" || Re(Le), cu = $e.type === "value-func" || Re($e) || Ze && Ze.type === "value-func" || Ze && Re(Ze);
                  if (!(!(J($e) || J(Le)) && !C(Te, "calc") && !qo && (L($e) && !lu || L(Le) && !cu || Q($e) && !lu || Q(Le) && !cu || V($e) || V(Le)) && (de($e) || Rr && (!Ze || Ze && j(Ze)))) && !((je.parser === "scss" || je.parser === "less") && Rr && Le.value === "-" && le($e) && Ee(Le) === Ae($e.open) && $e.open.value === "(")) {
                    if (ge(Le)) {
                      if (Ve.type === "value-paren_group") {
                        Ge.push(_(h));
                        continue;
                      }
                      Ge.push(h);
                      continue;
                    }
                    if (me && (q($e) || R($e) || ce($e) || Y(Le) || ie(Le))) {
                      Ge.push(" ");
                      continue;
                    }
                    if (O && O.name.toLowerCase() === "namespace") {
                      Ge.push(" ");
                      continue;
                    }
                    if (st) {
                      Le.source && $e.source && Le.source.start.line !== $e.source.start.line ? (Ge.push(h), rt = true) : Ge.push(" ");
                      continue;
                    }
                    if (ou) {
                      Ge.push(" ");
                      continue;
                    }
                    if (!($e && $e.value === "...") && !(pe(Le) && pe($e) && Ee(Le) === Ae($e))) {
                      if (pe(Le) && le($e) && Ee(Le) === Ae($e.open)) {
                        Ge.push(g);
                        continue;
                      }
                      if (Le.value === "with" && le($e)) {
                        Ge.push(" ");
                        continue;
                      }
                      (tt = Le.value) !== null && tt !== void 0 && tt.endsWith("#") && $e.value === "{" && le($e.group) || Ge.push(y);
                    }
                  }
                }
                return _e && Ge.push(E), rt && Ge.unshift(h), me ? c2(F(Ge)) : v(Te) ? c2(f(Ge)) : c2(F(f(Ge)));
              }
              case "value-paren_group": {
                let Ve = Te.getParentNode();
                if (Ve && ee(Ve) && (ae.groups.length === 1 || ae.groups.length > 0 && ae.groups[0].type === "value-comma_group" && ae.groups[0].groups.length > 0 && ae.groups[0].groups[0].type === "value-word" && ae.groups[0].groups[0].value.startsWith("data:"))) return [ae.open ? Me("open") : "", p(",", Te.map(Me, "groups")), ae.close ? Me("close") : ""];
                if (!ae.open) {
                  let it = Te.map(Me, "groups"), Qe = [];
                  for (let rt = 0; rt < it.length; rt++) rt !== 0 && Qe.push([",", y]), Qe.push(it[rt]);
                  return c2(F(f(Qe)));
                }
                let We = fe(Te), Xe = t(ae.groups), st = Xe && Xe.type === "value-comment", O = Fe(ae, Ve), me = X(ae, Ve), _e = me || We && !O, He = me || O, Ge = c2([ae.open ? Me("open") : "", F([g, p([y], Te.map((it, Qe) => {
                  let rt = it.getValue(), at = Qe === ae.groups.length - 1, Ze = [Me(), at ? "" : ","];
                  if (ue(rt) && rt.type === "value-comma_group" && rt.groups && rt.groups[0].type !== "value-paren_group" && rt.groups[2] && rt.groups[2].type === "value-paren_group") {
                    let Le = x(Ze[0].contents.contents);
                    Le[1] = c2(Le[1]), Ze = [c2(_(Ze))];
                  }
                  if (!at && rt.type === "value-comma_group" && l(rt.groups)) {
                    let Le = t(rt.groups);
                    !Le.source && Le.close && (Le = Le.close), Le.source && i(je.originalText, Le, Ee) && Ze.push(h);
                  }
                  return Ze;
                }, "groups"))]), w(!st && A(je.parser, je.originalText) && We && re(je) ? "," : ""), g, ae.close ? Me("close") : ""], { shouldBreak: _e });
                return He ? _(Ge) : Ge;
              }
              case "value-func":
                return [ae.value, d(Te, "supports") && Pe(ae) ? " " : "", Me("group")];
              case "value-paren":
                return ae.value;
              case "value-number":
                return [Je(ae.value), G(ae.unit)];
              case "value-operator":
                return ae.value;
              case "value-word":
                return ae.isColor && ae.isHex || b(ae.value) ? ae.value.toLowerCase() : ae.value;
              case "value-colon": {
                let Ve = Te.getParentNode(), We = Ve && Ve.groups.indexOf(ae), Xe = We && Ve.groups[We - 1];
                return [ae.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || C(Te, "url") ? "" : y];
              }
              case "value-comma":
                return [ae.value, " "];
              case "value-string":
                return a(ae.raws.quote + ae.value + ae.raws.quote, je);
              case "value-atword":
                return ["@", ae.value];
              case "value-unicode-range":
                return ae.value;
              case "value-unknown":
                return ae.value;
              default:
                throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`);
            }
          }
          function Ce(Te, je, Me) {
            let ae = [];
            return Te.each((nt, tt, Ve) => {
              let We = Ve[tt - 1];
              if (We && We.type === "css-comment" && We.text.trim() === "prettier-ignore") {
                let Xe = nt.getValue();
                ae.push(je.originalText.slice(Ae(Xe), Ee(Xe)));
              } else ae.push(Me());
              tt !== Ve.length - 1 && (Ve[tt + 1].type === "css-comment" && !n(je.originalText, Ae(Ve[tt + 1]), { backwards: true }) && !u(Ve[tt]) || Ve[tt + 1].type === "css-atrule" && Ve[tt + 1].name === "else" && Ve[tt].type !== "css-comment" ? ae.push(" ") : (ae.push(je.__isHTMLStyleAttribute ? y : h), i(je.originalText, nt.getValue(), Ee) && !u(Ve[tt]) && ae.push(h)));
            }, "nodes"), ae;
          }
          var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, be = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye = new RegExp(Be.source + `|(${be.source})?(${ve.source})(${ze.source})?`, "g");
          function Se(Te, je) {
            return Te.replace(Be, (Me) => a(Me, je));
          }
          function Ie(Te, je) {
            let Me = je.singleQuote ? "'" : '"';
            return Te.includes('"') || Te.includes("'") ? Te : Me + Te + Me;
          }
          function Oe(Te) {
            return Te.replace(Ye, (je, Me, ae, nt, tt) => !ae && nt ? Je(nt) + m(tt || "") : je);
          }
          function Je(Te) {
            return s(Te).replace(/\.0(?=$|e)/, "");
          }
          r2.exports = { print: ye, embed: P, insertPragma: $, massageAstNode: I };
        } }), Rd = te({ "src/language-css/options.js"(e, r2) {
          ne();
          var t = Mt();
          r2.exports = { singleQuote: t.singleQuote };
        } }), $d = te({ "src/language-css/parsers.js"() {
          ne();
        } }), Vd = te({ "node_modules/linguist-languages/data/CSS.json"(e, r2) {
          r2.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
        } }), Wd = te({ "node_modules/linguist-languages/data/PostCSS.json"(e, r2) {
          r2.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
        } }), Hd = te({ "node_modules/linguist-languages/data/Less.json"(e, r2) {
          r2.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
        } }), Gd = te({ "node_modules/linguist-languages/data/SCSS.json"(e, r2) {
          r2.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        } }), Ud = te({ "src/language-css/index.js"(e, r2) {
          ne();
          var t = _t(), s = Md(), a = Rd(), n = $d(), u = [t(Vd(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(Wd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Hd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Gd(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
          r2.exports = { languages: u, options: a, printers: i, parsers: n };
        } }), Jd = te({ "src/language-handlebars/loc.js"(e, r2) {
          ne();
          function t(a) {
            return a.loc.start.offset;
          }
          function s(a) {
            return a.loc.end.offset;
          }
          r2.exports = { locStart: t, locEnd: s };
        } }), zd = te({ "src/language-handlebars/clean.js"(e, r2) {
          ne();
          function t(s, a) {
            if (s.type === "TextNode") {
              let n = s.chars.trim();
              if (!n) return null;
              a.chars = n.replace(/[\t\n\f\r ]+/g, " ");
            }
            s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
          }
          t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r2.exports = t;
        } }), Xd = te({ "src/language-handlebars/html-void-elements.evaluate.js"(e, r2) {
          r2.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
        } }), Kd = te({ "src/language-handlebars/utils.js"(e, r2) {
          ne();
          var t = lt(), s = Xd();
          function a(x) {
            let I = x.getValue(), P = x.getParentNode(0);
            return !!(g(x, ["ElementNode"]) && t(P.children) === I || g(x, ["Block"]) && t(P.body) === I);
          }
          function n(x) {
            return x.toUpperCase() === x;
          }
          function u(x) {
            return h(x, ["ElementNode"]) && typeof x.tag == "string" && !x.tag.startsWith(":") && (n(x.tag[0]) || x.tag.includes("."));
          }
          var i = new Set(s);
          function l(x) {
            return i.has(x.toLowerCase()) && !n(x[0]);
          }
          function p(x) {
            return x.selfClosing === true || l(x.tag) || u(x) && x.children.every((I) => y(I));
          }
          function y(x) {
            return h(x, ["TextNode"]) && !/\S/.test(x.chars);
          }
          function h(x, I) {
            return x && I.includes(x.type);
          }
          function g(x, I) {
            let P = x.getParentNode(0);
            return h(P, I);
          }
          function c2(x, I) {
            let P = _(x);
            return h(P, I);
          }
          function f(x, I) {
            let P = w(x);
            return h(P, I);
          }
          function F(x, I) {
            var P, $, D, T;
            let m = x.getValue(), C = (P = x.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($ = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $ !== void 0 ? $ : [], d = o.indexOf(m);
            return d !== -1 && o[d + I];
          }
          function _(x) {
            let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return F(x, -I);
          }
          function w(x) {
            return F(x, 1);
          }
          function E(x) {
            return h(x, ["MustacheCommentStatement"]) && typeof x.value == "string" && x.value.trim() === "prettier-ignore";
          }
          function N(x) {
            let I = x.getValue(), P = _(x, 2);
            return E(I) || E(P);
          }
          r2.exports = { getNextNode: w, getPreviousNode: _, hasPrettierIgnore: N, isLastNodeOfSiblings: a, isNextNodeOfSomeType: f, isNodeOfSomeType: h, isParentOfSomeType: g, isPreviousNodeOfSomeType: c2, isVoid: p, isWhitespaceNode: y };
        } }), Yd = te({ "src/language-handlebars/printer-glimmer.js"(e, r2) {
          ne();
          var { builders: { dedent: t, fill: s, group: a, hardline: n, ifBreak: u, indent: i, join: l, line: p, softline: y }, utils: { getDocParts: h, replaceTextEndOfLine: g } } = qe(), { getPreferredQuote: c2, isNonEmptyArray: f } = Ue(), { locStart: F, locEnd: _ } = Jd(), w = zd(), { getNextNode: E, getPreviousNode: N, hasPrettierIgnore: x, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P, isNodeOfSomeType: $, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m, isWhitespaceNode: C } = Kd(), o = 2;
          function d(H, pe, X) {
            let le = H.getValue();
            if (!le) return "";
            if (x(H)) return pe.originalText.slice(F(le), _(le));
            let Ae = pe.singleQuote ? "'" : '"';
            switch (le.type) {
              case "Block":
              case "Program":
              case "Template":
                return a(H.map(X, "body"));
              case "ElementNode": {
                let Ee = a(S(H, X)), De = pe.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? y : "";
                if (m(le)) return [Ee, De];
                let A = ["</", le.tag, ">"];
                return le.children.length === 0 ? [Ee, i(A), De] : pe.htmlWhitespaceSensitivity === "ignore" ? [Ee, i(b(H, pe, X)), n, i(A), De] : [Ee, i(a(b(H, pe, X))), i(A), De];
              }
              case "BlockStatement": {
                let Ee = H.getParentNode(1);
                return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe), ue(H, X, pe)] : [j(H, X), a([de(H, X, pe), ue(H, X, pe), ee(H, X, pe)])];
              }
              case "ElementModifierStatement":
                return a(["{{", Re(H, X), "}}"]);
              case "MustacheStatement":
                return a([k(le), Re(H, X), M(le)]);
              case "SubExpression":
                return a(["(", ke(H, X), y, ")"]);
              case "AttrNode": {
                let Ee = le.value.type === "TextNode";
                if (Ee && le.value.chars === "" && F(le.value) === _(le.value)) return le.name;
                let A = Ee ? c2(le.value.chars, Ae).quote : le.value.type === "ConcatStatement" ? c2(le.value.parts.filter((re) => re.type === "TextNode").map((re) => re.chars).join(""), Ae).quote : "", G = X("value");
                return [le.name, "=", A, le.name === "class" && A ? a(i(G)) : G, A];
              }
              case "ConcatStatement":
                return H.map(X, "parts");
              case "Hash":
                return l(p, H.map(X, "pairs"));
              case "HashPair":
                return [le.key, "=", X("value")];
              case "TextNode": {
                let Ee = le.chars.replace(/{{/g, "\\{{"), De = U(H);
                if (De) {
                  if (De === "class") {
                    let Ye = Ee.trim().split(/\s+/).join(" "), Se = false, Ie = false;
                    return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee) && (Se = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee) && Ye !== "" && (Ie = true)), [Se ? p : "", Ye, Ie ? p : ""];
                  }
                  return g(Ee);
                }
                let G = /^[\t\n\f\r ]*$/.test(Ee), re = !N(H), ye = !E(H);
                if (pe.htmlWhitespaceSensitivity !== "ignore") {
                  let Ye = /^[\t\n\f\r ]*/, Se = /[\t\n\f\r ]*$/, Ie = ye && D(H, ["Template"]), Oe = re && D(H, ["Template"]);
                  if (G) {
                    if (Oe || Ie) return "";
                    let ae = [p], nt = Z(Ee);
                    return nt && (ae = ge(nt)), I(H) && (ae = ae.map((tt) => t(tt))), ae;
                  }
                  let [Je] = Ee.match(Ye), [Te] = Ee.match(Se), je = [];
                  if (Je) {
                    je = [p];
                    let ae = Z(Je);
                    ae && (je = ge(ae)), Ee = Ee.replace(Ye, "");
                  }
                  let Me = [];
                  if (Te) {
                    if (!Ie) {
                      Me = [p];
                      let ae = Z(Te);
                      ae && (Me = ge(ae)), I(H) && (Me = Me.map((nt) => t(nt)));
                    }
                    Ee = Ee.replace(Se, "");
                  }
                  return [...je, s(Fe(Ee)), ...Me];
                }
                let Ce = Z(Ee), Be = se(Ee), ve = fe(Ee);
                if ((re || ye) && G && D(H, ["Block", "ElementNode", "Template"])) return "";
                G && Ce ? (Be = Math.min(Ce, o), ve = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve = Math.max(ve, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                let ze = "", be = "";
                return ve === 0 && P(H, ["MustacheStatement"]) && (be = " "), Be === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re && (Be = 0, ze = ""), ye && (ve = 0, be = ""), Ee = Ee.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, be), [...ge(Be), s(Fe(Ee)), ...ge(ve)];
              }
              case "MustacheCommentStatement": {
                let Ee = F(le), De = _(le), A = pe.originalText.charAt(Ee + 2) === "~", G = pe.originalText.charAt(De - 3) === "~", re = le.value.includes("}}") ? "--" : "";
                return ["{{", A ? "~" : "", "!", re, le.value, re, G ? "~" : "", "}}"];
              }
              case "PathExpression":
                return le.original;
              case "BooleanLiteral":
                return String(le.value);
              case "CommentStatement":
                return ["<!--", le.value, "-->"];
              case "StringLiteral": {
                if (we(H)) {
                  let Ee = pe.singleQuote ? '"' : "'";
                  return he(le.value, Ee);
                }
                return he(le.value, Ae);
              }
              case "NumberLiteral":
                return String(le.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(le.type));
            }
          }
          function v(H, pe) {
            return F(H) - F(pe);
          }
          function S(H, pe) {
            let X = H.getValue(), le = ["attributes", "modifiers", "comments"].filter((Ee) => f(X[Ee])), Ae = le.flatMap((Ee) => X[Ee]).sort(v);
            for (let Ee of le) H.each((De) => {
              let A = Ae.indexOf(De.getValue());
              Ae.splice(A, 1, [p, pe()]);
            }, Ee);
            return f(X.blockParams) && Ae.push(p, oe(X)), ["<", X.tag, i(Ae), B(X)];
          }
          function b(H, pe, X) {
            let Ae = H.getValue().children.every((Ee) => C(Ee));
            return pe.htmlWhitespaceSensitivity === "ignore" && Ae ? "" : H.map((Ee, De) => {
              let A = X();
              return De === 0 && pe.htmlWhitespaceSensitivity === "ignore" ? [y, A] : A;
            }, "children");
          }
          function B(H) {
            return m(H) ? u([y, "/>"], [" />", y]) : u([y, ">"], ">");
          }
          function k(H) {
            let pe = H.escaped === false ? "{{{" : "{{", X = H.strip && H.strip.open ? "~" : "";
            return [pe, X];
          }
          function M(H) {
            let pe = H.escaped === false ? "}}}" : "}}";
            return [H.strip && H.strip.close ? "~" : "", pe];
          }
          function R(H) {
            let pe = k(H), X = H.openStrip.open ? "~" : "";
            return [pe, X, "#"];
          }
          function q(H) {
            let pe = M(H);
            return [H.openStrip.close ? "~" : "", pe];
          }
          function J(H) {
            let pe = k(H), X = H.closeStrip.open ? "~" : "";
            return [pe, X, "/"];
          }
          function L(H) {
            let pe = M(H);
            return [H.closeStrip.close ? "~" : "", pe];
          }
          function Q(H) {
            let pe = k(H), X = H.inverseStrip.open ? "~" : "";
            return [pe, X];
          }
          function V(H) {
            let pe = M(H);
            return [H.inverseStrip.close ? "~" : "", pe];
          }
          function j(H, pe) {
            let X = H.getValue(), le = [], Ae = Pe(H, pe);
            return Ae && le.push(a(Ae)), f(X.program.blockParams) && le.push(oe(X.program)), a([R(X), Ne(H, pe), le.length > 0 ? i([p, l(p, le)]) : "", y, q(X)]);
          }
          function Y(H, pe) {
            return [pe.htmlWhitespaceSensitivity === "ignore" ? n : "", Q(H), "else", V(H)];
          }
          function ie(H, pe, X) {
            let le = H.getValue(), Ae = H.getParentNode(1);
            return a([Q(Ae), ["else", " ", X], i([p, a(Pe(H, pe)), ...f(le.program.blockParams) ? [p, oe(le.program)] : []]), y, V(Ae)]);
          }
          function ee(H, pe, X) {
            let le = H.getValue();
            return X.htmlWhitespaceSensitivity === "ignore" ? [ce(le) ? y : n, J(le), pe("path"), L(le)] : [J(le), pe("path"), L(le)];
          }
          function ce(H) {
            return $(H, ["BlockStatement"]) && H.program.body.every((pe) => C(pe));
          }
          function W(H) {
            return K(H) && H.inverse.body.length === 1 && $(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
          }
          function K(H) {
            return $(H, ["BlockStatement"]) && H.inverse;
          }
          function de(H, pe, X) {
            let le = H.getValue();
            if (ce(le)) return "";
            let Ae = pe("program");
            return X.htmlWhitespaceSensitivity === "ignore" ? i([n, Ae]) : i(Ae);
          }
          function ue(H, pe, X) {
            let le = H.getValue(), Ae = pe("inverse"), Ee = X.htmlWhitespaceSensitivity === "ignore" ? [n, Ae] : Ae;
            return W(le) ? Ee : K(le) ? [Y(le, X), i(Ee)] : "";
          }
          function Fe(H) {
            return h(l(p, z(H)));
          }
          function z(H) {
            return H.split(/[\t\n\f\r ]+/);
          }
          function U(H) {
            for (let pe = 0; pe < 2; pe++) {
              let X = H.getParentNode(pe);
              if (X && X.type === "AttrNode") return X.name.toLowerCase();
            }
          }
          function Z(H) {
            return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
          }
          function se(H) {
            H = typeof H == "string" ? H : "";
            let pe = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return Z(pe);
          }
          function fe(H) {
            H = typeof H == "string" ? H : "";
            let pe = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return Z(pe);
          }
          function ge() {
            let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({ length: Math.min(H, o) }).fill(n);
          }
          function he(H, pe) {
            let { quote: X, regex: le } = c2(H, pe);
            return [X, H.replace(le, `\\${X}`), X];
          }
          function we(H) {
            let pe = 0, X = H.getParentNode(pe);
            for (; X && $(X, ["SubExpression"]); ) pe++, X = H.getParentNode(pe);
            return !!(X && $(H.getParentNode(pe + 1), ["ConcatStatement"]) && $(H.getParentNode(pe + 2), ["AttrNode"]));
          }
          function ke(H, pe) {
            let X = Ne(H, pe), le = Pe(H, pe);
            return le ? i([X, p, a(le)]) : X;
          }
          function Re(H, pe) {
            let X = Ne(H, pe), le = Pe(H, pe);
            return le ? [i([X, p, le]), y] : X;
          }
          function Ne(H, pe) {
            return pe("path");
          }
          function Pe(H, pe) {
            let X = H.getValue(), le = [];
            if (X.params.length > 0) {
              let Ae = H.map(pe, "params");
              le.push(...Ae);
            }
            if (X.hash && X.hash.pairs.length > 0) {
              let Ae = pe("hash");
              le.push(Ae);
            }
            return le.length === 0 ? "" : l(p, le);
          }
          function oe(H) {
            return ["as |", H.blockParams.join(" "), "|"];
          }
          r2.exports = { print: d, massageAstNode: w };
        } }), Qd = te({ "src/language-handlebars/parsers.js"() {
          ne();
        } }), Zd = te({ "node_modules/linguist-languages/data/Handlebars.json"(e, r2) {
          r2.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
        } }), eg = te({ "src/language-handlebars/index.js"(e, r2) {
          ne();
          var t = _t(), s = Yd(), a = Qd(), n = [t(Zd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
          r2.exports = { languages: n, printers: u, parsers: a };
        } }), tg = te({ "src/language-graphql/pragma.js"(e, r2) {
          ne();
          function t(a) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
          }
          function s(a) {
            return `# @format

` + a;
          }
          r2.exports = { hasPragma: t, insertPragma: s };
        } }), rg = te({ "src/language-graphql/loc.js"(e, r2) {
          ne();
          function t(a) {
            return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
          }
          function s(a) {
            return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
          }
          r2.exports = { locStart: t, locEnd: s };
        } }), ng = te({ "src/language-graphql/printer-graphql.js"(e, r2) {
          ne();
          var { builders: { join: t, hardline: s, line: a, softline: n, group: u, indent: i, ifBreak: l } } = qe(), { isNextLineEmpty: p, isNonEmptyArray: y } = Ue(), { insertPragma: h } = tg(), { locStart: g, locEnd: c2 } = rg();
          function f(P, $, D) {
            let T = P.getValue();
            if (!T) return "";
            if (typeof T == "string") return T;
            switch (T.kind) {
              case "Document": {
                let m = [];
                return P.each((C, o, d) => {
                  m.push(D()), o !== d.length - 1 && (m.push(s), p($.originalText, C.getValue(), c2) && m.push(s));
                }, "definitions"), [...m, s];
              }
              case "OperationDefinition": {
                let m = $.originalText[g(T)] !== "{", C = Boolean(T.name);
                return [m ? T.operation : "", m && C ? [" ", D("name")] : "", m && !C && y(T.variableDefinitions) ? " " : "", y(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", F(P, D, T), T.selectionSet ? !m && !C ? "" : " " : "", D("selectionSet")];
              }
              case "FragmentDefinition":
                return ["fragment ", D("name"), y(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", " on ", D("typeCondition"), F(P, D, T), " ", D("selectionSet")];
              case "SelectionSet":
                return ["{", i([s, t(s, _(P, $, D, "selections"))]), s, "}"];
              case "Field":
                return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", F(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
              case "Name":
                return T.value;
              case "StringValue": {
                if (T.block) {
                  let m = T.value.replace(/"""/g, "\\$&").split(`
`);
                  return m.length === 1 && (m[0] = m[0].trim()), m.every((C) => C === "") && (m.length = 0), t(s, ['"""', ...m, '"""']);
                }
                return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
              }
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return T.value;
              case "BooleanValue":
                return T.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", D("name")];
              case "ListValue":
                return u(["[", i([n, t([l("", ", "), n], P.map(D, "values"))]), n, "]"]);
              case "ObjectValue":
                return u(["{", $.bracketSpacing && T.fields.length > 0 ? " " : "", i([n, t([l("", ", "), n], P.map(D, "fields"))]), n, l("", $.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [D("name"), ": ", D("value")];
              case "Directive":
                return ["@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : ""];
              case "NamedType":
                return D("name");
              case "VariableDefinition":
                return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
              case "FieldDefinition":
                return [D("description"), T.description ? s : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", ": ", D("type"), F(P, D, T)];
              case "DirectiveDefinition":
                return [D("description"), T.description ? s : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t(" | ", P.map(D, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), F(P, D, T), T.values.length > 0 ? [" {", i([s, t(s, _(P, $, D, "values"))]), s, "}"] : ""];
              case "EnumValueDefinition":
                return [D("description"), T.description ? s : "", D("name"), F(P, D, T)];
              case "InputValueDefinition":
                return [D("description"), T.description ? T.description.block ? s : a : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
              case "SchemaExtension":
                return ["extend schema", F(P, D, T), ...T.operationTypes.length > 0 ? [" {", i([s, t(s, _(P, $, D, "operationTypes"))]), s, "}"] : []];
              case "SchemaDefinition":
                return [D("description"), T.description ? s : "", "schema", F(P, D, T), " {", T.operationTypes.length > 0 ? i([s, t(s, _(P, $, D, "operationTypes"))]) : "", s, "}"];
              case "OperationTypeDefinition":
                return [D("operation"), ": ", D("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
              case "FragmentSpread":
                return ["...", D("name"), F(P, D, T)];
              case "InlineFragment":
                return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", F(P, D, T), " ", D("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return u([D("description"), T.description ? s : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), F(P, D, T), T.types.length > 0 ? [" =", l("", " "), i([l([a, "  "]), t([a, "| "], P.map(D, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), F(P, D, T)];
              case "NonNullType":
                return [D("type"), "!"];
              case "ListType":
                return ["[", D("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
            }
          }
          function F(P, $, D) {
            if (D.directives.length === 0) return "";
            let T = t(a, P.map($, "directives"));
            return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a, T]) : [" ", u(i([n, T]))];
          }
          function _(P, $, D, T) {
            return P.map((m, C, o) => {
              let d = D();
              return C < o.length - 1 && p($.originalText, m.getValue(), c2) ? [d, s] : d;
            }, T);
          }
          function w(P) {
            return P.kind && P.kind !== "Comment";
          }
          function E(P) {
            let $ = P.getValue();
            if ($.kind === "Comment") return "#" + $.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify($));
          }
          function N(P, $, D) {
            let T = P.getNode(), m = [], { interfaces: C } = T, o = P.map((d) => D(d), "interfaces");
            for (let d = 0; d < C.length; d++) {
              let v = C[d];
              m.push(o[d]);
              let S = C[d + 1];
              if (S) {
                let b = $.originalText.slice(v.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
                m.push(k === "," ? "," : " &", B ? a : " ");
              }
            }
            return m;
          }
          function x(P, $) {
            P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($.value = $.value.trim());
          }
          x.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
          function I(P) {
            var $;
            let D = P.getValue();
            return D == null || ($ = D.comments) === null || $ === void 0 ? void 0 : $.some((T) => T.value.trim() === "prettier-ignore");
          }
          r2.exports = { print: f, massageAstNode: x, hasPrettierIgnore: I, insertPragma: h, printComment: E, canAttachComment: w };
        } }), ug = te({ "src/language-graphql/options.js"(e, r2) {
          ne();
          var t = Mt();
          r2.exports = { bracketSpacing: t.bracketSpacing };
        } }), sg = te({ "src/language-graphql/parsers.js"() {
          ne();
        } }), ig = te({ "node_modules/linguist-languages/data/GraphQL.json"(e, r2) {
          r2.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
        } }), ag = te({ "src/language-graphql/index.js"(e, r2) {
          ne();
          var t = _t(), s = ng(), a = ug(), n = sg(), u = [t(ig(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
          r2.exports = { languages: u, options: a, printers: i, parsers: n };
        } }), Po = te({ "node_modules/collapse-white-space/index.js"(e, r2) {
          ne(), r2.exports = t;
          function t(s) {
            return String(s).replace(/\s+/g, " ");
          }
        } }), Io = te({ "src/language-markdown/loc.js"(e, r2) {
          ne();
          function t(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          r2.exports = { locStart: t, locEnd: s };
        } }), og = te({ "src/language-markdown/constants.evaluate.js"(e, r2) {
          r2.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), iu = te({ "src/language-markdown/utils.js"(e, r2) {
          ne();
          var { getLast: t } = Ue(), { locStart: s, locEnd: a } = Io(), { cjkPattern: n, kPattern: u, punctuationPattern: i } = og(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p = [...l, "tableCell", "paragraph", "heading"], y = new RegExp(u), h = new RegExp(i);
          function g(E, N) {
            let x = "non-cjk", I = "cj-letter", P = "k-letter", $ = "cjk-punctuation", D = [], T = (N.proseWrap === "preserve" ? E : E.replace(new RegExp(`(${n})
(${n})`, "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [C, o] of T.entries()) {
              if (C % 2 === 1) {
                D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                continue;
              }
              if ((C === 0 || C === T.length - 1) && o === "") continue;
              let d = o.split(new RegExp(`(${n})`));
              for (let [v, S] of d.entries()) if (!((v === 0 || v === d.length - 1) && S === "")) {
                if (v % 2 === 0) {
                  S !== "" && m({ type: "word", value: S, kind: x, hasLeadingPunctuation: h.test(S[0]), hasTrailingPunctuation: h.test(t(S)) });
                  continue;
                }
                m(h.test(S) ? { type: "word", value: S, kind: $, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: y.test(S) ? P : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
              }
            }
            return D;
            function m(C) {
              let o = t(D);
              o && o.type === "word" && (o.kind === x && C.kind === I && !o.hasTrailingPunctuation || o.kind === I && C.kind === x && !C.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !d(x, $) && ![o.value, C.value].some((v) => /\u3000/.test(v)) && D.push({ type: "whitespace", value: "" })), D.push(C);
              function d(v, S) {
                return o.kind === v && C.kind === S || o.kind === S && C.kind === v;
              }
            }
          }
          function c2(E, N) {
            let [, x, I, P] = N.slice(E.position.start.offset, E.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: x, marker: I, leadingSpaces: P };
          }
          function f(E, N) {
            if (!E.ordered || E.children.length < 2) return false;
            let x = Number(c2(E.children[0], N.originalText).numberText), I = Number(c2(E.children[1], N.originalText).numberText);
            if (x === 0 && E.children.length > 2) {
              let P = Number(c2(E.children[2], N.originalText).numberText);
              return I === 1 && P === 1;
            }
            return I === 1;
          }
          function F(E, N) {
            let { value: x } = E;
            return E.position.end.offset === N.length && x.endsWith(`
`) && N.endsWith(`
`) ? x.slice(0, -1) : x;
          }
          function _(E, N) {
            return (function x(I, P, $) {
              let D = Object.assign({}, N(I, P, $));
              return D.children && (D.children = D.children.map((T, m) => x(T, m, [D, ...$]))), D;
            })(E, null, []);
          }
          function w(E) {
            if ((E == null ? void 0 : E.type) !== "link" || E.children.length !== 1) return false;
            let [N] = E.children;
            return s(E) === s(N) && a(E) === a(N);
          }
          r2.exports = { mapAst: _, splitText: g, punctuationPattern: i, getFencedCodeBlockValue: F, getOrderedListItemInfo: c2, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p, isAutolink: w };
        } }), lg = te({ "src/language-markdown/embed.js"(e, r2) {
          ne();
          var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ue(), { builders: { hardline: a, markAsRoot: n }, utils: { replaceEndOfLine: u } } = qe(), i = su(), { getFencedCodeBlockValue: l } = iu();
          function p(y, h, g, c2) {
            let f = y.getValue();
            if (f.type === "code" && f.lang !== null) {
              let F = t(f.lang, c2);
              if (F) {
                let _ = c2.__inJsTemplate ? "~" : "`", w = _.repeat(Math.max(3, s(f.value, _) + 1)), E = { parser: F };
                f.lang === "tsx" && (E.filepath = "dummy.tsx");
                let N = g(l(f, c2.originalText), E, { stripTrailingHardline: true });
                return n([w, f.lang, f.meta ? " " + f.meta : "", a, u(N), a, w]);
              }
            }
            switch (f.type) {
              case "front-matter":
                return i(f, g);
              case "importExport":
                return [g(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
              case "jsx":
                return g(`<$>${f.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
            }
            return null;
          }
          r2.exports = p;
        } }), ko = te({ "src/language-markdown/pragma.js"(e, r2) {
          ne();
          var t = _o(), s = ["format", "prettier"];
          function a(n) {
            let u = `@(${s.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n.match(i);
            return (l == null ? void 0 : l.index) === 0;
          }
          r2.exports = { startWithPragma: a, hasPragma: (n) => a(t(n).content.trimStart()), insertPragma: (n) => {
            let u = t(n), i = `<!-- @${s[0]} -->`;
            return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
          } };
        } }), cg = te({ "src/language-markdown/print-preprocess.js"(e, r2) {
          ne();
          var t = lt(), { getOrderedListItemInfo: s, mapAst: a, splitText: n } = iu(), u = /^.$/su;
          function i(w, E) {
            return w = y(w, E), w = c2(w), w = p(w, E), w = F(w, E), w = _(w, E), w = f(w, E), w = l(w), w = h(w), w;
          }
          function l(w) {
            return a(w, (E) => E.type !== "import" && E.type !== "export" ? E : Object.assign(Object.assign({}, E), {}, { type: "importExport" }));
          }
          function p(w, E) {
            return a(w, (N) => N.type !== "inlineCode" || E.proseWrap === "preserve" ? N : Object.assign(Object.assign({}, N), {}, { value: N.value.replace(/\s+/g, " ") }));
          }
          function y(w, E) {
            return a(w, (N) => N.type !== "text" || N.value === "*" || N.value === "_" || !u.test(N.value) || N.position.end.offset - N.position.start.offset === N.value.length ? N : Object.assign(Object.assign({}, N), {}, { value: E.originalText.slice(N.position.start.offset, N.position.end.offset) }));
          }
          function h(w) {
            return g(w, (E, N) => E.type === "importExport" && N.type === "importExport", (E, N) => ({ type: "importExport", value: E.value + `

` + N.value, position: { start: E.position.start, end: N.position.end } }));
          }
          function g(w, E, N) {
            return a(w, (x) => {
              if (!x.children) return x;
              let I = x.children.reduce((P, $) => {
                let D = t(P);
                return D && E(D, $) ? P.splice(-1, 1, N(D, $)) : P.push($), P;
              }, []);
              return Object.assign(Object.assign({}, x), {}, { children: I });
            });
          }
          function c2(w) {
            return g(w, (E, N) => E.type === "text" && N.type === "text", (E, N) => ({ type: "text", value: E.value + N.value, position: { start: E.position.start, end: N.position.end } }));
          }
          function f(w, E) {
            return a(w, (N, x, I) => {
              let [P] = I;
              if (N.type !== "text") return N;
              let { value: $ } = N;
              return P.type === "paragraph" && (x === 0 && ($ = $.trimStart()), x === P.children.length - 1 && ($ = $.trimEnd())), { type: "sentence", position: N.position, children: n($, E) };
            });
          }
          function F(w, E) {
            return a(w, (N, x, I) => {
              if (N.type === "code") {
                let P = /^\n?(?: {4,}|\t)/.test(E.originalText.slice(N.position.start.offset, N.position.end.offset));
                if (N.isIndented = P, P) for (let $ = 0; $ < I.length; $++) {
                  let D = I[$];
                  if (D.hasIndentedCodeblock) break;
                  D.type === "list" && (D.hasIndentedCodeblock = true);
                }
              }
              return N;
            });
          }
          function _(w, E) {
            return a(w, (I, P, $) => {
              if (I.type === "list" && I.children.length > 0) {
                for (let D = 0; D < $.length; D++) {
                  let T = $[D];
                  if (T.type === "list" && !T.isAligned) return I.isAligned = false, I;
                }
                I.isAligned = x(I);
              }
              return I;
            });
            function N(I) {
              return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
            }
            function x(I) {
              if (!I.ordered) return true;
              let [P, $] = I.children;
              if (s(P, E.originalText).leadingSpaces.length > 1) return true;
              let T = N(P);
              if (T === -1) return false;
              if (I.children.length === 1) return T % E.tabWidth === 0;
              let m = N($);
              return T !== m ? false : T % E.tabWidth === 0 ? true : s($, E.originalText).leadingSpaces.length > 1;
            }
          }
          r2.exports = i;
        } }), pg = te({ "src/language-markdown/clean.js"(e, r2) {
          ne();
          var t = Po(), { isFrontMatterNode: s } = Ue(), { startWithPragma: a } = ko(), n = /* @__PURE__ */ new Set(["position", "raw"]);
          function u(i, l, p) {
            if ((i.type === "front-matter" || i.type === "code" || i.type === "yaml" || i.type === "import" || i.type === "export" || i.type === "jsx") && delete l.value, i.type === "list" && delete l.isAligned, (i.type === "list" || i.type === "listItem") && (delete l.spread, delete l.loose), i.type === "text" || (i.type === "inlineCode" && (l.value = i.value.replace(/[\t\n ]+/g, " ")), i.type === "wikiLink" && (l.value = i.value.trim().replace(/[\t\n]+/g, " ")), (i.type === "definition" || i.type === "linkReference" || i.type === "imageReference") && (l.label = t(i.label)), (i.type === "definition" || i.type === "link" || i.type === "image") && i.title && (l.title = i.title.replace(/\\(["')])/g, "$1")), p && p.type === "root" && p.children.length > 0 && (p.children[0] === i || s(p.children[0]) && p.children[1] === i) && i.type === "html" && a(i.value))) return null;
          }
          u.ignoredProperties = n, r2.exports = u;
        } }), fg = te({ "src/language-markdown/printer-markdown.js"(e, r2) {
          ne();
          var t = Po(), { getLast: s, getMinNotPresentContinuousCount: a, getMaxContinuousCount: n, getStringWidth: u, isNonEmptyArray: i } = Ue(), { builders: { breakParent: l, join: p, line: y, literalline: h, markAsRoot: g, hardline: c2, softline: f, ifBreak: F, fill: _, align: w, indent: E, group: N, hardlineWithoutBreakParent: x }, utils: { normalizeDoc: I, replaceTextEndOfLine: P }, printer: { printDocToString: $ } } = qe(), D = lg(), { insertPragma: T } = ko(), { locStart: m, locEnd: C } = Io(), o = cg(), d = pg(), { getFencedCodeBlockValue: v, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M, isAutolink: R } = iu(), q = /* @__PURE__ */ new Set(["importExport"]), J = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
          function Q(oe, H, pe) {
            let X = oe.getValue();
            if (ge(oe)) return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map((le) => le.type === "word" ? le.value : le.value === "" ? "" : W(oe, le.value, H));
            switch (X.type) {
              case "front-matter":
                return H.originalText.slice(X.position.start.offset, X.position.end.offset);
              case "root":
                return X.children.length === 0 ? "" : [I(de(oe, H, pe)), q.has(z(X).type) ? "" : c2];
              case "paragraph":
                return ue(oe, H, pe, { postprocessor: _ });
              case "sentence":
                return ue(oe, H, pe);
              case "word": {
                let le = X.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De, A, G, re, ye) => (G ? `${A}${G}` : `${re}${ye}`).replace(/_/g, "\\_")), Ae = (De, A, G) => De.type === "sentence" && G === 0, Ee = (De, A, G) => R(De.children[G - 1]);
                return le !== X.value && (oe.match(void 0, Ae, Ee) || oe.match(void 0, Ae, (De, A, G) => De.type === "emphasis" && G === 0, Ee)) && (le = le.replace(/^(\\?[*_])+/, (De) => De.replace(/\\/g, ""))), le;
              }
              case "whitespace": {
                let le = oe.getParentNode(), Ae = le.children.indexOf(X), Ee = le.children[Ae + 1], De = Ee && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee.value) ? "never" : H.proseWrap;
                return W(oe, X.value, { proseWrap: De });
              }
              case "emphasis": {
                let le;
                if (R(X.children[0])) le = H.originalText[X.position.start.offset];
                else {
                  let Ae = oe.getParentNode(), Ee = Ae.children.indexOf(X), De = Ae.children[Ee - 1], A = Ae.children[Ee + 1];
                  le = De && De.type === "sentence" && De.children.length > 0 && s(De.children).type === "word" && !s(De.children).hasTrailingPunctuation || A && A.type === "sentence" && A.children.length > 0 && A.children[0].type === "word" && !A.children[0].hasLeadingPunctuation || ce(oe, "emphasis") ? "*" : "_";
                }
                return [le, ue(oe, H, pe), le];
              }
              case "strong":
                return ["**", ue(oe, H, pe), "**"];
              case "delete":
                return ["~~", ue(oe, H, pe), "~~"];
              case "inlineCode": {
                let le = a(X.value, "`"), Ae = "`".repeat(le || 1), Ee = le && !/^\s/.test(X.value) ? " " : "";
                return [Ae, Ee, X.value, Ee, Ae];
              }
              case "wikiLink": {
                let le = "";
                return H.proseWrap === "preserve" ? le = X.value : le = X.value.replace(/[\t\n]+/g, " "), ["[[", le, "]]"];
              }
              case "link":
                switch (H.originalText[X.position.start.offset]) {
                  case "<": {
                    let le = "mailto:";
                    return ["<", X.url.startsWith(le) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le.length) !== le ? X.url.slice(le.length) : X.url, ">"];
                  }
                  case "[":
                    return ["[", ue(oe, H, pe), "](", he(X.url, ")"), we(X.title, H), ")"];
                  default:
                    return H.originalText.slice(X.position.start.offset, X.position.end.offset);
                }
              case "image":
                return ["![", X.alt || "", "](", he(X.url, ")"), we(X.title, H), ")"];
              case "blockquote":
                return ["> ", w("> ", ue(oe, H, pe))];
              case "heading":
                return ["#".repeat(X.depth) + " ", ue(oe, H, pe)];
              case "code": {
                if (X.isIndented) {
                  let Ee = " ".repeat(4);
                  return w(Ee, [Ee, ...P(X.value, c2)]);
                }
                let le = H.__inJsTemplate ? "~" : "`", Ae = le.repeat(Math.max(3, n(X.value, le) + 1));
                return [Ae, X.lang || "", X.meta ? " " + X.meta : "", c2, ...P(v(X, H.originalText), c2), c2, Ae];
              }
              case "html": {
                let le = oe.getParentNode(), Ae = le.type === "root" && s(le.children) === X ? X.value.trimEnd() : X.value, Ee = /^<!--.*-->$/s.test(Ae);
                return P(Ae, Ee ? c2 : g(h));
              }
              case "list": {
                let le = Y(X, oe.getParentNode()), Ae = S(X, H);
                return ue(oe, H, pe, { processor: (Ee, De) => {
                  let A = re(), G = Ee.getValue();
                  if (G.children.length === 2 && G.children[1].type === "html" && G.children[0].position.start.column !== G.children[1].position.start.column) return [A, V(Ee, H, pe, A)];
                  return [A, w(" ".repeat(A.length), V(Ee, H, pe, A))];
                  function re() {
                    let ye = X.ordered ? (De === 0 ? X.start : Ae ? 1 : X.start + De) + (le % 2 === 0 ? ". " : ") ") : le % 2 === 0 ? "- " : "* ";
                    return X.isAligned || X.hasIndentedCodeblock ? j(ye, H) : ye;
                  }
                } });
              }
              case "thematicBreak": {
                let le = ee(oe, "list");
                return le === -1 ? "---" : Y(oe.getParentNode(le), oe.getParentNode(le + 1)) % 2 === 0 ? "***" : "---";
              }
              case "linkReference":
                return ["[", ue(oe, H, pe), "]", X.referenceType === "full" ? Ne(X) : X.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (X.referenceType) {
                  case "full":
                    return ["![", X.alt || "", "]", Ne(X)];
                  default:
                    return ["![", X.alt, "]", X.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition": {
                let le = H.proseWrap === "always" ? y : " ";
                return N([Ne(X), ":", E([le, he(X.url), X.title === null ? "" : [le, we(X.title, H, false)]])]);
              }
              case "footnote":
                return ["[^", ue(oe, H, pe), "]"];
              case "footnoteReference":
                return Pe(X);
              case "footnoteDefinition": {
                let le = oe.getParentNode().children[oe.getName() + 1], Ae = X.children.length === 1 && X.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X.children[0].position.start.line === X.children[0].position.end.line);
                return [Pe(X), ": ", Ae ? ue(oe, H, pe) : N([w(" ".repeat(4), ue(oe, H, pe, { processor: (Ee, De) => De === 0 ? N([f, pe()]) : pe() })), le && le.type === "footnoteDefinition" ? f : ""])];
              }
              case "table":
                return K(oe, H, pe);
              case "tableCell":
                return ue(oe, H, pe);
              case "break":
                return /\s/.test(H.originalText[X.position.start.offset]) ? ["  ", g(h)] : ["\\", c2];
              case "liquidNode":
                return P(X.value, c2);
              case "importExport":
                return [X.value, c2];
              case "esComment":
                return ["{/* ", X.value, " */}"];
              case "jsx":
                return X.value;
              case "math":
                return ["$$", c2, X.value ? [...P(X.value, c2), c2] : "", "$$"];
              case "inlineMath":
                return H.originalText.slice(m(X), C(X));
              case "tableRow":
              case "listItem":
              default:
                throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);
            }
          }
          function V(oe, H, pe, X) {
            let le = oe.getValue(), Ae = le.checked === null ? "" : le.checked ? "[x] " : "[ ] ";
            return [Ae, ue(oe, H, pe, { processor: (Ee, De) => {
              if (De === 0 && Ee.getValue().type !== "list") return w(" ".repeat(Ae.length), pe());
              let A = " ".repeat(ke(H.tabWidth - X.length, 0, 3));
              return [A, w(A, pe())];
            } })];
          }
          function j(oe, H) {
            let pe = X();
            return oe + " ".repeat(pe >= 4 ? 0 : pe);
            function X() {
              let le = oe.length % H.tabWidth;
              return le === 0 ? 0 : H.tabWidth - le;
            }
          }
          function Y(oe, H) {
            return ie(oe, H, (pe) => pe.ordered === oe.ordered);
          }
          function ie(oe, H, pe) {
            let X = -1;
            for (let le of H.children) if (le.type === oe.type && pe(le) ? X++ : X = -1, le === oe) return X;
          }
          function ee(oe, H) {
            let pe = Array.isArray(H) ? H : [H], X = -1, le;
            for (; le = oe.getParentNode(++X); ) if (pe.includes(le.type)) return X;
            return -1;
          }
          function ce(oe, H) {
            let pe = ee(oe, H);
            return pe === -1 ? null : oe.getParentNode(pe);
          }
          function W(oe, H, pe) {
            if (pe.proseWrap === "preserve" && H === `
`) return c2;
            let X = pe.proseWrap === "always" && !ce(oe, J);
            return H !== "" ? X ? y : " " : X ? f : "";
          }
          function K(oe, H, pe) {
            let X = oe.getValue(), le = [], Ae = oe.map((ye) => ye.map((Ce, Be) => {
              let ve = $(pe(), H).formatted, ze = u(ve);
              return le[Be] = Math.max(le[Be] || 3, ze), { text: ve, width: ze };
            }, "children"), "children"), Ee = A(false);
            if (H.proseWrap !== "never") return [l, Ee];
            let De = A(true);
            return [l, N(F(De, Ee))];
            function A(ye) {
              let Ce = [re(Ae[0], ye), G(ye)];
              return Ae.length > 1 && Ce.push(p(x, Ae.slice(1).map((Be) => re(Be, ye)))), p(x, Ce);
            }
            function G(ye) {
              return `| ${le.map((Be, ve) => {
                let ze = X.align[ve], be = ze === "center" || ze === "left" ? ":" : "-", Ye = ze === "center" || ze === "right" ? ":" : "-", Se = ye ? "-" : "-".repeat(Be - 2);
                return `${be}${Se}${Ye}`;
              }).join(" | ")} |`;
            }
            function re(ye, Ce) {
              return `| ${ye.map((ve, ze) => {
                let { text: be, width: Ye } = ve;
                if (Ce) return be;
                let Se = le[ze] - Ye, Ie = X.align[ze], Oe = 0;
                Ie === "right" ? Oe = Se : Ie === "center" && (Oe = Math.floor(Se / 2));
                let Je = Se - Oe;
                return `${" ".repeat(Oe)}${be}${" ".repeat(Je)}`;
              }).join(" | ")} |`;
            }
          }
          function de(oe, H, pe) {
            let X = [], le = null, { children: Ae } = oe.getValue();
            for (let [Ee, De] of Ae.entries()) switch (U(De)) {
              case "start":
                le === null && (le = { index: Ee, offset: De.position.end.offset });
                break;
              case "end":
                le !== null && (X.push({ start: le, end: { index: Ee, offset: De.position.start.offset } }), le = null);
                break;
            }
            return ue(oe, H, pe, { processor: (Ee, De) => {
              if (X.length > 0) {
                let A = X[0];
                if (De === A.start.index) return [Fe(Ae[A.start.index]), H.originalText.slice(A.start.offset, A.end.offset), Fe(Ae[A.end.index])];
                if (A.start.index < De && De < A.end.index) return false;
                if (De === A.end.index) return X.shift(), false;
              }
              return pe();
            } });
          }
          function ue(oe, H, pe) {
            let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le } = X, Ae = X.processor || (() => pe()), Ee = oe.getValue(), De = [], A;
            return oe.each((G, re) => {
              let ye = G.getValue(), Ce = Ae(G, re);
              if (Ce !== false) {
                let Be = { parts: De, prevNode: A, parentNode: Ee};
                Z(ye, Be) && (De.push(c2), A && q.has(A.type) || (se(ye, Be) || fe(ye, Be)) && De.push(c2), fe(ye, Be) && De.push(c2)), De.push(Ce), A = ye;
              }
            }, "children"), le ? le(De) : De;
          }
          function Fe(oe) {
            if (oe.type === "html") return oe.value;
            if (oe.type === "paragraph" && Array.isArray(oe.children) && oe.children.length === 1 && oe.children[0].type === "esComment") return ["{/* ", oe.children[0].value, " */}"];
          }
          function z(oe) {
            let H = oe;
            for (; i(H.children); ) H = s(H.children);
            return H;
          }
          function U(oe) {
            let H;
            if (oe.type === "html") H = oe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
            else {
              let pe;
              oe.type === "esComment" ? pe = oe : oe.type === "paragraph" && oe.children.length === 1 && oe.children[0].type === "esComment" && (pe = oe.children[0]), pe && (H = pe.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return H ? H[1] || "next" : false;
          }
          function Z(oe, H) {
            let pe = H.parts.length === 0, X = k.includes(oe.type), le = oe.type === "html" && M.includes(H.parentNode.type);
            return !pe && !X && !le;
          }
          function se(oe, H) {
            var pe, X, le;
            let Ee = (H.prevNode && H.prevNode.type) === oe.type && L.has(oe.type), De = H.parentNode.type === "listItem" && !H.parentNode.loose, A = ((pe = H.prevNode) === null || pe === void 0 ? void 0 : pe.type) === "listItem" && H.prevNode.loose, G = U(H.prevNode) === "next", re = oe.type === "html" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === "html" && H.prevNode.position.end.line + 1 === oe.position.start.line, ye = oe.type === "html" && H.parentNode.type === "listItem" && ((le = H.prevNode) === null || le === void 0 ? void 0 : le.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe.position.start.line;
            return A || !(Ee || De || G || re || ye);
          }
          function fe(oe, H) {
            let pe = H.prevNode && H.prevNode.type === "list", X = oe.type === "code" && oe.isIndented;
            return pe && X;
          }
          function ge(oe) {
            let H = ce(oe, ["linkReference", "imageReference"]);
            return H && (H.type !== "linkReference" || H.referenceType !== "full");
          }
          function he(oe) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe = [" ", ...Array.isArray(H) ? H : [H]];
            return new RegExp(pe.map((X) => `\\${X}`).join("|")).test(oe) ? `<${oe}>` : oe;
          }
          function we(oe, H) {
            let pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (!oe) return "";
            if (pe) return " " + we(oe, H, false);
            if (oe = oe.replace(/\\(["')])/g, "$1"), oe.includes('"') && oe.includes("'") && !oe.includes(")")) return `(${oe})`;
            let X = oe.split("'").length - 1, le = oe.split('"').length - 1, Ae = X > le ? '"' : le > X || H.singleQuote ? "'" : '"';
            return oe = oe.replace(/\\/, "\\\\"), oe = oe.replace(new RegExp(`(${Ae})`, "g"), "\\$1"), `${Ae}${oe}${Ae}`;
          }
          function ke(oe, H, pe) {
            return oe < H ? H : oe > pe ? pe : oe;
          }
          function Re(oe) {
            let H = Number(oe.getName());
            if (H === 0) return false;
            let pe = oe.getParentNode().children[H - 1];
            return U(pe) === "next";
          }
          function Ne(oe) {
            return `[${t(oe.label)}]`;
          }
          function Pe(oe) {
            return `[^${oe.label}]`;
          }
          r2.exports = { preprocess: o, print: Q, embed: D, massageAstNode: d, hasPrettierIgnore: Re, insertPragma: T };
        } }), Dg = te({ "src/language-markdown/options.js"(e, r2) {
          ne();
          var t = Mt();
          r2.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
        } }), mg = te({ "src/language-markdown/parsers.js"() {
          ne();
        } }), _a = te({ "node_modules/linguist-languages/data/Markdown.json"(e, r2) {
          r2.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        } }), dg = te({ "src/language-markdown/index.js"(e, r2) {
          ne();
          var t = _t(), s = fg(), a = Dg(), n = mg(), u = [t(_a(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p) => p !== ".mdx") })), t(_a(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
          r2.exports = { languages: u, options: a, printers: i, parsers: n };
        } }), gg = te({ "src/language-html/clean.js"(e, r2) {
          ne();
          var { isFrontMatterNode: t } = Ue(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
          function a(n, u) {
            if (n.type === "text" || n.type === "comment" || t(n) || n.type === "yaml" || n.type === "toml") return null;
            n.type === "attribute" && delete u.value, n.type === "docType" && delete u.value;
          }
          a.ignoredProperties = s, r2.exports = a;
        } }), yg = te({ "src/language-html/constants.evaluate.js"(e, r2) {
          r2.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
        } }), hg = te({ "src/language-html/utils/is-unknown-namespace.js"(e, r2) {
          ne();
          function t(s) {
            return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
          }
          r2.exports = t;
        } }), Rt = te({ "src/language-html/utils/index.js"(e, r2) {
          ne();
          var { inferParserByLanguage: t, isFrontMatterNode: s } = Ue(), { builders: { line: a, hardline: n, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: p, CSS_DISPLAY_DEFAULT: y, CSS_WHITE_SPACE_TAGS: h, CSS_WHITE_SPACE_DEFAULT: g } = yg(), c2 = hg(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), F = (A) => A.replace(/^[\t\n\f\r ]+/, ""), _ = (A) => A.replace(/[\t\n\f\r ]+$/, ""), w = (A) => F(_(A)), E = (A) => A.replace(/^[\t\f\r ]*\n/g, ""), N = (A) => E(_(A)), x = (A) => A.split(/[\t\n\f\r ]+/), I = (A) => A.match(/^[\t\n\f\r ]*/)[0], P = (A) => {
            let [, G, re, ye] = A.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return { leadingWhitespace: G, trailingWhitespace: ye, text: re };
          }, $ = (A) => /[\t\n\f\r ]/.test(A);
          function D(A, G) {
            return !!(A.type === "ieConditionalComment" && A.lastChild && !A.lastChild.isSelfClosing && !A.lastChild.endSourceSpan || A.type === "ieConditionalComment" && !A.complete || se(A) && A.children.some((re) => re.type !== "text" && re.type !== "interpolation") || X(A, G) && !o(A) && A.type !== "interpolation");
          }
          function T(A) {
            return A.type === "attribute" || !A.parent || !A.prev ? false : m(A.prev);
          }
          function m(A) {
            return A.type === "comment" && A.value.trim() === "prettier-ignore";
          }
          function C(A) {
            return A.type === "text" || A.type === "comment";
          }
          function o(A) {
            return A.type === "element" && (A.fullName === "script" || A.fullName === "style" || A.fullName === "svg:style" || c2(A) && (A.name === "script" || A.name === "style"));
          }
          function d(A) {
            return A.children && !o(A);
          }
          function v(A) {
            return o(A) || A.type === "interpolation" || S(A);
          }
          function S(A) {
            return we(A).startsWith("pre");
          }
          function b(A, G) {
            let re = ye();
            if (re && !A.prev && A.parent && A.parent.tagDefinition && A.parent.tagDefinition.ignoreFirstLf) return A.type === "interpolation";
            return re;
            function ye() {
              return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.prev && (A.prev.type === "text" || A.prev.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.prev && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !ue(A.parent.cssDisplay)) || A.prev && !U(A.prev.cssDisplay));
            }
          }
          function B(A, G) {
            return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.next && (A.next.type === "text" || A.next.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.next && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !Fe(A.parent.cssDisplay)) || A.next && !z(A.next.cssDisplay));
          }
          function k(A) {
            return Z(A.cssDisplay) && !o(A);
          }
          function M(A) {
            return s(A) || A.next && A.sourceSpan.end && A.sourceSpan.end.line + 1 < A.next.sourceSpan.start.line;
          }
          function R(A) {
            return q(A) || A.type === "element" && A.children.length > 0 && (["body", "script", "style"].includes(A.name) || A.children.some((G) => ee(G))) || A.firstChild && A.firstChild === A.lastChild && A.firstChild.type !== "text" && V(A.firstChild) && (!A.lastChild.isTrailingSpaceSensitive || j(A.lastChild));
          }
          function q(A) {
            return A.type === "element" && A.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A.name) || A.cssDisplay.startsWith("table") && A.cssDisplay !== "table-cell");
          }
          function J(A) {
            return Y(A) || A.prev && L(A.prev) || Q(A);
          }
          function L(A) {
            return Y(A) || A.type === "element" && A.fullName === "br" || Q(A);
          }
          function Q(A) {
            return V(A) && j(A);
          }
          function V(A) {
            return A.hasLeadingSpaces && (A.prev ? A.prev.sourceSpan.end.line < A.sourceSpan.start.line : A.parent.type === "root" || A.parent.startSourceSpan.end.line < A.sourceSpan.start.line);
          }
          function j(A) {
            return A.hasTrailingSpaces && (A.next ? A.next.sourceSpan.start.line > A.sourceSpan.end.line : A.parent.type === "root" || A.parent.endSourceSpan && A.parent.endSourceSpan.start.line > A.sourceSpan.end.line);
          }
          function Y(A) {
            switch (A.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return true;
              case "element":
                return ["script", "select"].includes(A.name);
            }
            return false;
          }
          function ie(A) {
            return A.lastChild ? ie(A.lastChild) : A;
          }
          function ee(A) {
            return A.children && A.children.some((G) => G.type !== "text");
          }
          function ce(A) {
            let { type: G, lang: re } = A.attrMap;
            if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || re === "jsx") return "babel";
            if (G === "application/x-typescript" || re === "ts" || re === "tsx") return "typescript";
            if (G === "text/markdown") return "markdown";
            if (G === "text/html") return "html";
            if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules") return "json";
            if (G === "text/x-handlebars-template") return "glimmer";
          }
          function W(A, G) {
            let { lang: re } = A.attrMap;
            if (!re || re === "postcss" || re === "css") return "css";
            if (re === "scss") return "scss";
            if (re === "less") return "less";
            if (re === "stylus") return t("stylus", G);
          }
          function K(A, G) {
            if (A.name === "script" && !A.attrMap.src) return !A.attrMap.lang && !A.attrMap.type ? "babel" : ce(A);
            if (A.name === "style") return W(A, G);
            if (G && X(A, G)) return ce(A) || !("src" in A.attrMap) && t(A.attrMap.lang, G);
          }
          function de(A) {
            return A === "block" || A === "list-item" || A.startsWith("table");
          }
          function ue(A) {
            return !de(A) && A !== "inline-block";
          }
          function Fe(A) {
            return !de(A) && A !== "inline-block";
          }
          function z(A) {
            return !de(A);
          }
          function U(A) {
            return !de(A);
          }
          function Z(A) {
            return !de(A) && A !== "inline-block";
          }
          function se(A) {
            return we(A).startsWith("pre");
          }
          function fe(A, G) {
            let re = 0;
            for (let ye = A.stack.length - 1; ye >= 0; ye--) {
              let Ce = A.stack[ye];
              Ce && typeof Ce == "object" && !Array.isArray(Ce) && G(Ce) && re++;
            }
            return re;
          }
          function ge(A, G) {
            let re = A;
            for (; re; ) {
              if (G(re)) return true;
              re = re.parent;
            }
            return false;
          }
          function he(A, G) {
            if (A.prev && A.prev.type === "comment") {
              let ye = A.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (ye) return ye[1];
            }
            let re = false;
            if (A.type === "element" && A.namespace === "svg") if (ge(A, (ye) => ye.fullName === "svg:foreignObject")) re = true;
            else return A.name === "svg" ? "inline-block" : "block";
            switch (G.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return G.parser === "vue" && A.parent && A.parent.type === "root" ? "block" : A.type === "element" && (!A.namespace || re || c2(A)) && p[A.name] || y;
            }
          }
          function we(A) {
            return A.type === "element" && (!A.namespace || c2(A)) && h[A.name] || g;
          }
          function ke(A) {
            let G = Number.POSITIVE_INFINITY;
            for (let re of A.split(`
`)) {
              if (re.length === 0) continue;
              if (!f.has(re[0])) return 0;
              let ye = I(re).length;
              re.length !== ye && ye < G && (G = ye);
            }
            return G === Number.POSITIVE_INFINITY ? 0 : G;
          }
          function Re(A) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke(A);
            return G === 0 ? A : A.split(`
`).map((re) => re.slice(G)).join(`
`);
          }
          function Ne(A, G) {
            let re = 0;
            for (let ye = 0; ye < A.length; ye++) A[ye] === G && re++;
            return re;
          }
          function Pe(A) {
            return A.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          var oe = /* @__PURE__ */ new Set(["template", "style", "script"]);
          function H(A, G) {
            return pe(A, G) && !oe.has(A.fullName);
          }
          function pe(A, G) {
            return G.parser === "vue" && A.type === "element" && A.parent.type === "root" && A.fullName.toLowerCase() !== "html";
          }
          function X(A, G) {
            return pe(A, G) && (H(A, G) || A.attrMap.lang && A.attrMap.lang !== "html");
          }
          function le(A) {
            let G = A.fullName;
            return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
          }
          function Ae(A, G) {
            let re = A.parent;
            if (!pe(re, G)) return false;
            let ye = re.fullName, Ce = A.fullName;
            return ye === "script" && Ce === "setup" || ye === "style" && Ce === "vars";
          }
          function Ee(A) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.value;
            return A.parent.isWhitespaceSensitive ? A.parent.isIndentationSensitive ? l(G) : l(Re(N(G)), n) : i(u(a, x(G)));
          }
          function De(A, G) {
            return pe(A, G) && A.name === "script";
          }
          r2.exports = { htmlTrim: w, htmlTrimPreserveIndentation: N, hasHtmlWhitespace: $, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: d, countChars: Ne, countParents: fe, dedentString: Re, forceBreakChildren: q, forceBreakContent: R, forceNextEmptyLine: M, getLastDescendant: ie, getNodeCssStyleDisplay: he, getNodeCssStyleWhiteSpace: we, hasPrettierIgnore: T, inferScriptParser: K, isVueCustomBlock: H, isVueNonHtmlBlock: X, isVueScriptTag: De, isVueSlotAttribute: le, isVueSfcBindingsAttribute: Ae, isVueSfcBlock: pe, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se, isScriptLikeTag: o, isTextLikeNode: C, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v, isUnknownNamespace: c2, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe, getTextValueParts: Ee };
        } }), vg = te({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
          function r2(i) {
            return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
          }
          e.isWhitespace = r2;
          function t(i) {
            return e.$0 <= i && i <= e.$9;
          }
          e.isDigit = t;
          function s(i) {
            return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
          }
          e.isAsciiLetter = s;
          function a(i) {
            return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
          }
          e.isAsciiHexDigit = a;
          function n(i) {
            return i === e.$LF || i === e.$CR;
          }
          e.isNewLine = n;
          function u(i) {
            return e.$0 <= i && i <= e.$7;
          }
          e.isOctalDigit = u;
        } }), Cg = te({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = class {
            constructor(s, a, n) {
              this.filePath = s, this.name = a, this.members = n;
            }
            assertNoMembers() {
              if (this.members.length) throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
            }
          };
          e.StaticSymbol = r2;
          var t = class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(s, a, n) {
              n = n || [];
              let u = n.length ? `.${n.join(".")}` : "", i = `"${s}".${a}${u}`, l = this.cache.get(i);
              return l || (l = new r2(s, a, n), this.cache.set(i, l)), l;
            }
          };
          e.StaticSymbolCache = t;
        } }), Eg = te({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = /-+([a-z0-9])/g;
          function t(o) {
            return o.replace(r2, function() {
              for (var d = arguments.length, v = new Array(d), S = 0; S < d; S++) v[S] = arguments[S];
              return v[1].toUpperCase();
            });
          }
          e.dashCaseToCamelCase = t;
          function s(o, d) {
            return n(o, ":", d);
          }
          e.splitAtColon = s;
          function a(o, d) {
            return n(o, ".", d);
          }
          e.splitAtPeriod = a;
          function n(o, d, v) {
            let S = o.indexOf(d);
            return S == -1 ? v : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
          }
          function u(o, d, v) {
            return Array.isArray(o) ? d.visitArray(o, v) : E(o) ? d.visitStringMap(o, v) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d.visitPrimitive(o, v) : d.visitOther(o, v);
          }
          e.visitValue = u;
          function i(o) {
            return o != null;
          }
          e.isDefined = i;
          function l(o) {
            return o === void 0 ? null : o;
          }
          e.noUndefined = l;
          var p = class {
            visitArray(o, d) {
              return o.map((v) => u(v, this, d));
            }
            visitStringMap(o, d) {
              let v = {};
              return Object.keys(o).forEach((S) => {
                v[S] = u(o[S], this, d);
              }), v;
            }
            visitPrimitive(o, d) {
              return o;
            }
            visitOther(o, d) {
              return o;
            }
          };
          e.ValueTransformer = p, e.SyncAsync = { assertSync: (o) => {
            if (P(o)) throw new Error("Illegal state: value cannot be a promise");
            return o;
          }, then: (o, d) => P(o) ? o.then(d) : d(o), all: (o) => o.some(P) ? Promise.all(o) : o };
          function y(o) {
            throw new Error(`Internal Error: ${o}`);
          }
          e.error = y;
          function h(o, d) {
            let v = Error(o);
            return v[g] = true, d && (v[c2] = d), v;
          }
          e.syntaxError = h;
          var g = "ngSyntaxError", c2 = "ngParseErrors";
          function f(o) {
            return o[g];
          }
          e.isSyntaxError = f;
          function F(o) {
            return o[c2] || [];
          }
          e.getParseErrors = F;
          function _(o) {
            return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          e.escapeRegExp = _;
          var w = Object.getPrototypeOf({});
          function E(o) {
            return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w;
          }
          function N(o) {
            let d = "";
            for (let v = 0; v < o.length; v++) {
              let S = o.charCodeAt(v);
              if (S >= 55296 && S <= 56319 && o.length > v + 1) {
                let b = o.charCodeAt(v + 1);
                b >= 56320 && b <= 57343 && (v++, S = (S - 55296 << 10) + b - 56320 + 65536);
              }
              S <= 127 ? d += String.fromCharCode(S) : S <= 2047 ? d += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? d += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (d += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
            }
            return d;
          }
          e.utf8Encode = N;
          function x(o) {
            if (typeof o == "string") return o;
            if (o instanceof Array) return "[" + o.map(x).join(", ") + "]";
            if (o == null) return "" + o;
            if (o.overriddenName) return `${o.overriddenName}`;
            if (o.name) return `${o.name}`;
            if (!o.toString) return "object";
            let d = o.toString();
            if (d == null) return "" + d;
            let v = d.indexOf(`
`);
            return v === -1 ? d : d.substring(0, v);
          }
          e.stringify = x;
          function I(o) {
            return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
          }
          e.resolveForwardRef = I;
          function P(o) {
            return !!o && typeof o.then == "function";
          }
          e.isPromise = P;
          var $ = class {
            constructor(o) {
              this.full = o;
              let d = o.split(".");
              this.major = d[0], this.minor = d[1], this.patch = d.slice(2).join(".");
            }
          };
          e.Version = $;
          var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, C = m || D || T;
          e.global = C;
        } }), Fg = te({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = Cg(), t = Eg(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function a(v) {
            return v.replace(/\W/g, "_");
          }
          e.sanitizeIdentifier = a;
          var n = 0;
          function u(v) {
            if (!v || !v.reference) return null;
            let S = v.reference;
            if (S instanceof r2.StaticSymbol) return S.name;
            if (S.__anonymousType) return S.__anonymousType;
            let b = t.stringify(S);
            return b.indexOf("(") >= 0 ? (b = `anonymous_${n++}`, S.__anonymousType = b) : b = a(b), b;
          }
          e.identifierName = u;
          function i(v) {
            let S = v.reference;
            return S instanceof r2.StaticSymbol ? S.filePath : `./${t.stringify(S)}`;
          }
          e.identifierModuleUrl = i;
          function l(v, S) {
            return `View_${u({ reference: v })}_${S}`;
          }
          e.viewClassName = l;
          function p(v) {
            return `RenderType_${u({ reference: v })}`;
          }
          e.rendererTypeName = p;
          function y(v) {
            return `HostView_${u({ reference: v })}`;
          }
          e.hostViewClassName = y;
          function h(v) {
            return `${u({ reference: v })}NgFactory`;
          }
          e.componentFactoryName = h;
          var g;
          (function(v) {
            v[v.Pipe = 0] = "Pipe", v[v.Directive = 1] = "Directive", v[v.NgModule = 2] = "NgModule", v[v.Injectable = 3] = "Injectable";
          })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
          function c2(v) {
            return v.value != null ? a(v.value) : u(v.identifier);
          }
          e.tokenName = c2;
          function f(v) {
            return v.identifier != null ? v.identifier.reference : v.value;
          }
          e.tokenReference = f;
          var F = class {
            constructor() {
              let { moduleUrl: v, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = v || null, this.styles = P(S), this.styleUrls = P(b);
            }
          };
          e.CompileStylesheetMetadata = F;
          var _ = class {
            constructor(v) {
              let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M, styleUrls: R, externalStylesheets: q, animations: J, ngContentSelectors: L, interpolation: Q, isInline: V, preserveWhitespaces: j } = v;
              if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M), this.styleUrls = P(R), this.externalStylesheets = P(q), this.animations = J ? D(J) : [], this.ngContentSelectors = L || [], Q && Q.length != 2) throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Q, this.isInline = V, this.preserveWhitespaces = j;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          e.CompileTemplateMetadata = _;
          var w = class {
            static create(v) {
              let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q, outputs: J, host: L, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de } = v, ue = {}, Fe = {}, z = {};
              L != null && Object.keys(L).forEach((se) => {
                let fe = L[se], ge = se.match(s);
                ge === null ? z[se] = fe : ge[1] != null ? Fe[ge[1]] = fe : ge[2] != null && (ue[ge[2]] = fe);
              });
              let U = {};
              q != null && q.forEach((se) => {
                let fe = t.splitAtColon(se, [se, se]);
                U[fe[0]] = fe[1];
              });
              let Z = {};
              return J != null && J.forEach((se) => {
                let fe = t.splitAtColon(se, [se, se]);
                Z[fe[0]] = fe[1];
              }), new w({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M, changeDetection: R, inputs: U, outputs: Z, hostListeners: ue, hostProperties: Fe, hostAttributes: z, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de });
            }
            constructor(v) {
              let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q, outputs: J, hostListeners: L, hostProperties: Q, hostAttributes: V, providers: j, viewProviders: Y, queries: ie, guards: ee, viewQueries: ce, entryComponents: W, template: K, componentViewType: de, rendererType: ue, componentFactory: Fe } = v;
              this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M, this.changeDetection = R, this.inputs = q, this.outputs = J, this.hostListeners = L, this.hostProperties = Q, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie), this.guards = ee, this.viewQueries = P(ce), this.entryComponents = P(W), this.template = K, this.componentViewType = de, this.rendererType = ue, this.componentFactory = Fe;
            }
            toSummary() {
              return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          };
          e.CompileDirectiveMetadata = w;
          var E = class {
            constructor(v) {
              let { type: S, name: b, pure: B } = v;
              this.type = S, this.name = b, this.pure = !!B;
            }
            toSummary() {
              return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e.CompilePipeMetadata = E;
          var N = class {
          };
          e.CompileShallowModuleMetadata = N;
          var x = class {
            constructor(v) {
              let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M, exportedPipes: R, entryComponents: q, bootstrapComponents: J, importedModules: L, exportedModules: Q, schemas: V, transitiveModule: j, id: Y } = v;
              this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M), this.exportedPipes = P(R), this.providers = P(b), this.entryComponents = P(q), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Q), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;
            }
            toSummary() {
              let v = this.transitiveModule;
              return { summaryKind: g.NgModule, type: this.type, entryComponents: v.entryComponents, providers: v.providers, modules: v.modules, exportedDirectives: v.exportedDirectives, exportedPipes: v.exportedPipes };
            }
          };
          e.CompileNgModuleMetadata = x;
          var I = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(v, S) {
              this.providers.push({ provider: v, module: S });
            }
            addDirective(v) {
              this.directivesSet.has(v.reference) || (this.directivesSet.add(v.reference), this.directives.push(v));
            }
            addExportedDirective(v) {
              this.exportedDirectivesSet.has(v.reference) || (this.exportedDirectivesSet.add(v.reference), this.exportedDirectives.push(v));
            }
            addPipe(v) {
              this.pipesSet.has(v.reference) || (this.pipesSet.add(v.reference), this.pipes.push(v));
            }
            addExportedPipe(v) {
              this.exportedPipesSet.has(v.reference) || (this.exportedPipesSet.add(v.reference), this.exportedPipes.push(v));
            }
            addModule(v) {
              this.modulesSet.has(v.reference) || (this.modulesSet.add(v.reference), this.modules.push(v));
            }
            addEntryComponent(v) {
              this.entryComponentsSet.has(v.componentType) || (this.entryComponentsSet.add(v.componentType), this.entryComponents.push(v));
            }
          };
          e.TransitiveCompileNgModuleMetadata = I;
          function P(v) {
            return v || [];
          }
          var $ = class {
            constructor(v, S) {
              let { useClass: b, useValue: B, useExisting: k, useFactory: M, deps: R, multi: q } = S;
              this.token = v, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M || null, this.dependencies = R || null, this.multi = !!q;
            }
          };
          e.ProviderMeta = $;
          function D(v) {
            return v.reduce((S, b) => {
              let B = Array.isArray(b) ? D(b) : b;
              return S.concat(B);
            }, []);
          }
          e.flatten = D;
          function T(v) {
            return v.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          function m(v, S, b) {
            let B;
            return b.isInline ? S.type.reference instanceof r2.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r2.StaticSymbol ? B : T(B);
          }
          e.templateSourceUrl = m;
          function C(v, S) {
            let b = v.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
            return T(`css/${S}${B}.ngstyle.js`);
          }
          e.sharedStylesheetJitUrl = C;
          function o(v) {
            return T(`${u(v.type)}/module.ngfactory.js`);
          }
          e.ngModuleJitUrl = o;
          function d(v, S) {
            return T(`${u(v)}/${u(S.type)}.ngfactory.js`);
          }
          e.templateJitUrl = d;
        } }), Ag = te({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
          ne(), Object.defineProperty(e, "__esModule", { value: true });
          var r2 = vg(), t = Fg(), s = class {
            constructor(y, h, g, c2) {
              this.file = y, this.offset = h, this.line = g, this.col = c2;
            }
            toString() {
              return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
            }
            moveBy(y) {
              let h = this.file.content, g = h.length, c2 = this.offset, f = this.line, F = this.col;
              for (; c2 > 0 && y < 0; ) if (c2--, y++, h.charCodeAt(c2) == r2.$LF) {
                f--;
                let w = h.substr(0, c2 - 1).lastIndexOf(String.fromCharCode(r2.$LF));
                F = w > 0 ? c2 - w : c2;
              } else F--;
              for (; c2 < g && y > 0; ) {
                let _ = h.charCodeAt(c2);
                c2++, y--, _ == r2.$LF ? (f++, F = 0) : F++;
              }
              return new s(this.file, c2, f, F);
            }
            getContext(y, h) {
              let g = this.file.content, c2 = this.offset;
              if (c2 != null) {
                c2 > g.length - 1 && (c2 = g.length - 1);
                let f = c2, F = 0, _ = 0;
                for (; F < y && c2 > 0 && (c2--, F++, !(g[c2] == `
` && ++_ == h)); ) ;
                for (F = 0, _ = 0; F < y && f < g.length - 1 && (f++, F++, !(g[f] == `
` && ++_ == h)); ) ;
                return { before: g.substring(c2, this.offset), after: g.substring(this.offset, f + 1) };
              }
              return null;
            }
          };
          e.ParseLocation = s;
          var a = class {
            constructor(y, h) {
              this.content = y, this.url = h;
            }
          };
          e.ParseSourceFile = a;
          var n = class {
            constructor(y, h) {
              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = y, this.end = h, this.details = g;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          };
          e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
          var u;
          (function(y) {
            y[y.WARNING = 0] = "WARNING", y[y.ERROR = 1] = "ERROR";
          })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
          var i = class {
            constructor(y, h) {
              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
              this.span = y, this.msg = h, this.level = g;
            }
            contextualMessage() {
              let y = this.span.start.getContext(100, 3);
              return y ? `${this.msg} ("${y.before}[${u[this.level]} ->]${y.after}")` : this.msg;
            }
            toString() {
              let y = this.span.details ? `, ${this.span.details}` : "";
              return `${this.contextualMessage()}: ${this.span.start}${y}`;
            }
          };
          e.ParseError = i;
          function l(y, h) {
            let g = t.identifierModuleUrl(h), c2 = g != null ? `in ${y} ${t.identifierName(h)} in ${g}` : `in ${y} ${t.identifierName(h)}`, f = new a("", c2);
            return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
          }
          e.typeSourceSpan = l;
          function p(y, h, g) {
            let c2 = `in ${y} ${h} in ${g}`, f = new a("", c2);
            return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
          }
          e.r3JitTypeSourceSpan = p;
        } }), Sg = te({ "src/language-html/print-preprocess.js"(e, r2) {
          ne();
          var { ParseSourceSpan: t } = Ag(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: n, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p, isLeadingSpaceSensitiveNode: y, isTrailingSpaceSensitiveNode: h, isWhitespaceSensitiveNode: g, isVueScriptTag: c2 } = Rt(), f = [_, w, N, I, P, T, $, D, m, x, C];
          function F(o, d) {
            for (let v of f) v(o, d);
            return o;
          }
          function _(o) {
            o.walk((d) => {
              if (d.type === "element" && d.tagDefinition.ignoreFirstLf && d.children.length > 0 && d.children[0].type === "text" && d.children[0].value[0] === `
`) {
                let v = d.children[0];
                v.value.length === 1 ? d.removeChild(v) : v.value = v.value.slice(1);
              }
            });
          }
          function w(o) {
            let d = (v) => v.type === "element" && v.prev && v.prev.type === "ieConditionalStartComment" && v.prev.sourceSpan.end.offset === v.startSourceSpan.start.offset && v.firstChild && v.firstChild.type === "ieConditionalEndComment" && v.firstChild.sourceSpan.start.offset === v.startSourceSpan.end.offset;
            o.walk((v) => {
              if (v.children) for (let S = 0; S < v.children.length; S++) {
                let b = v.children[S];
                if (!d(b)) continue;
                let B = b.prev, k = b.firstChild;
                v.removeChild(B), S--;
                let M = new t(B.sourceSpan.start, k.sourceSpan.end), R = new t(M.start, b.sourceSpan.end);
                b.condition = B.condition, b.sourceSpan = R, b.startSourceSpan = M, b.removeChild(k);
              }
            });
          }
          function E(o, d, v) {
            o.walk((S) => {
              if (S.children) for (let b = 0; b < S.children.length; b++) {
                let B = S.children[b];
                if (B.type !== "text" && !d(B)) continue;
                B.type !== "text" && (B.type = "text", B.value = v(B));
                let k = B.prev;
                !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
              }
            });
          }
          function N(o) {
            return E(o, (d) => d.type === "cdata", (d) => `<![CDATA[${d.value}]]>`);
          }
          function x(o) {
            let d = (v) => v.type === "element" && v.attrs.length === 0 && v.children.length === 1 && v.firstChild.type === "text" && !n(v.children[0].value) && !v.firstChild.hasLeadingSpaces && !v.firstChild.hasTrailingSpaces && v.isLeadingSpaceSensitive && !v.hasLeadingSpaces && v.isTrailingSpaceSensitive && !v.hasTrailingSpaces && v.prev && v.prev.type === "text" && v.next && v.next.type === "text";
            o.walk((v) => {
              if (v.children) for (let S = 0; S < v.children.length; S++) {
                let b = v.children[S];
                if (!d(b)) continue;
                let B = b.prev, k = b.next;
                B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v.removeChild(b), S--, v.removeChild(k);
              }
            });
          }
          function I(o, d) {
            if (d.parser === "html") return;
            let v = /{{(.+?)}}/s;
            o.walk((S) => {
              if (u(S)) for (let b of S.children) {
                if (b.type !== "text") continue;
                let B = b.sourceSpan.start, k = null, M = b.value.split(v);
                for (let R = 0; R < M.length; R++, B = k) {
                  let q = M[R];
                  if (R % 2 === 0) {
                    k = B.moveBy(q.length), q.length > 0 && S.insertChildBefore(b, { type: "text", value: q, sourceSpan: new t(B, k) });
                    continue;
                  }
                  k = B.moveBy(q.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(B, k), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t(B.moveBy(2), k.moveBy(-2)) }] });
                }
                S.removeChild(b);
              }
            });
          }
          function P(o) {
            o.walk((d) => {
              if (!d.children) return;
              if (d.children.length === 0 || d.children.length === 1 && d.children[0].type === "text" && s(d.children[0].value).length === 0) {
                d.hasDanglingSpaces = d.children.length > 0, d.children = [];
                return;
              }
              let v = g(d), S = p(d);
              if (!v) for (let b = 0; b < d.children.length; b++) {
                let B = d.children[b];
                if (B.type !== "text") continue;
                let { leadingWhitespace: k, text: M, trailingWhitespace: R } = a(B.value), q = B.prev, J = B.next;
                M ? (B.value = M, B.sourceSpan = new t(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R.length)), k && (q && (q.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R && (B.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (d.removeChild(B), b--, (k || R) && (q && (q.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
              }
              d.isWhitespaceSensitive = v, d.isIndentationSensitive = S;
            });
          }
          function $(o) {
            o.walk((d) => {
              d.isSelfClosing = !d.children || d.type === "element" && (d.tagDefinition.isVoid || d.startSourceSpan === d.endSourceSpan);
            });
          }
          function D(o, d) {
            o.walk((v) => {
              v.type === "element" && (v.hasHtmComponentClosingTag = v.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d.originalText.slice(v.endSourceSpan.start.offset, v.endSourceSpan.end.offset)));
            });
          }
          function T(o, d) {
            o.walk((v) => {
              v.cssDisplay = i(v, d);
            });
          }
          function m(o, d) {
            o.walk((v) => {
              let { children: S } = v;
              if (S) {
                if (S.length === 0) {
                  v.isDanglingSpaceSensitive = l(v);
                  return;
                }
                for (let b of S) b.isLeadingSpaceSensitive = y(b, d), b.isTrailingSpaceSensitive = h(b, d);
                for (let b = 0; b < S.length; b++) {
                  let B = S[b];
                  B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
                }
              }
            });
          }
          function C(o, d) {
            if (d.parser === "vue") {
              let v = o.children.find((b) => c2(b, d));
              if (!v) return;
              let { lang: S } = v.attrMap;
              (S === "ts" || S === "typescript") && (d.__should_parse_vue_template_with_ts = true);
            }
          }
          r2.exports = F;
        } }), xg = te({ "src/language-html/pragma.js"(e, r2) {
          ne();
          function t(a) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
          }
          function s(a) {
            return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
          }
          r2.exports = { hasPragma: t, insertPragma: s };
        } }), au = te({ "src/language-html/loc.js"(e, r2) {
          ne();
          function t(a) {
            return a.sourceSpan.start.offset;
          }
          function s(a) {
            return a.sourceSpan.end.offset;
          }
          r2.exports = { locStart: t, locEnd: s };
        } }), ur = te({ "src/language-html/print/tag.js"(e, r2) {
          ne();
          var t = Zt(), { isNonEmptyArray: s } = Ue(), { builders: { indent: a, join: n, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: p } } = qe(), { locStart: y, locEnd: h } = au(), { isTextLikeNode: g, getLastDescendant: c2, isPreLikeNode: f, hasPrettierIgnore: F, shouldPreserveContent: _, isVueSfcBlock: w } = Rt();
          function E(L, Q) {
            return [L.isSelfClosing ? "" : N(L, Q), x(L, Q)];
          }
          function N(L, Q) {
            return L.lastChild && o(L.lastChild) ? "" : [I(L, Q), $(L, Q)];
          }
          function x(L, Q) {
            return (L.next ? m(L.next) : C(L.parent)) ? "" : [D(L, Q), P(L, Q)];
          }
          function I(L, Q) {
            return C(L) ? D(L.lastChild, Q) : "";
          }
          function P(L, Q) {
            return o(L) ? $(L.parent, Q) : d(L) ? q(L.next) : "";
          }
          function $(L, Q) {
            if (t(!L.isSelfClosing), T(L, Q)) return "";
            switch (L.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (L.hasHtmComponentClosingTag) return "<//";
              default:
                return `</${L.rawName}`;
            }
          }
          function D(L, Q) {
            if (T(L, Q)) return "";
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (L.isSelfClosing) return "/>";
              default:
                return ">";
            }
          }
          function T(L, Q) {
            return !L.isSelfClosing && !L.endSourceSpan && (F(L) || _(L.parent, Q));
          }
          function m(L) {
            return L.prev && L.prev.type !== "docType" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          function C(L) {
            return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(c2(L.lastChild)) && !f(L);
          }
          function o(L) {
            return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(c2(L));
          }
          function d(L) {
            return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
          }
          function v(L) {
            let Q = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return Q ? Q[1] ? Q[1].split(/\s+/) : true : false;
          }
          function S(L) {
            return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          function b(L, Q, V) {
            let j = L.getValue();
            if (!s(j.attrs)) return j.isSelfClosing ? " " : "";
            let Y = j.prev && j.prev.type === "comment" && v(j.prev.value), ie = typeof Y == "boolean" ? () => Y : Array.isArray(Y) ? (ue) => Y.includes(ue.rawName) : () => false, ee = L.map((ue) => {
              let Fe = ue.getValue();
              return ie(Fe) ? p(Q.originalText.slice(y(Fe), h(Fe))) : V();
            }, "attrs"), ce = j.type === "element" && j.fullName === "script" && j.attrs.length === 1 && j.attrs[0].fullName === "src" && j.children.length === 0, K = Q.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q) ? l : u, de = [a([ce ? " " : u, n(K, ee)])];
            return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce ? de.push(j.isSelfClosing ? " " : "") : de.push(Q.bracketSameLine ? j.isSelfClosing ? " " : "" : j.isSelfClosing ? u : i), de;
          }
          function B(L) {
            return L.firstChild && S(L.firstChild) ? "" : J(L);
          }
          function k(L, Q, V) {
            let j = L.getValue();
            return [M(j, Q), b(L, Q, V), j.isSelfClosing ? "" : B(j)];
          }
          function M(L, Q) {
            return L.prev && d(L.prev) ? "" : [R(L, Q), q(L)];
          }
          function R(L, Q) {
            return S(L) ? J(L.parent) : m(L) ? D(L.prev, Q) : "";
          }
          function q(L) {
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return `<!--[if ${L.condition}`;
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (L.condition) return `<!--[if ${L.condition}]><!--><${L.rawName}`;
              default:
                return `<${L.rawName}`;
            }
          }
          function J(L) {
            switch (t(!L.isSelfClosing), L.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (L.condition) return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          r2.exports = { printClosingTag: E, printClosingTagStart: N, printClosingTagStartMarker: $, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x, needsToBorrowLastChildClosingTagEndMarker: C, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: M, printOpeningTagPrefix: R, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: d, needsToBorrowParentOpeningTagEndMarker: S };
        } }), bg = te({ "node_modules/parse-srcset/src/parse-srcset.js"(e, r2) {
          ne(), (function(t, s) {
            typeof define == "function" && define.amd ? define([], s) : typeof r2 == "object" && r2.exports ? r2.exports = s() : t.parseSrcset = s();
          })(e, function() {
            return function(t, s) {
              var a = s && s.logger || console;
              function n($) {
                return $ === " " || $ === "	" || $ === `
` || $ === "\f" || $ === "\r";
              }
              function u($) {
                var D, T = $.exec(t.substring(N));
                if (T) return D = T[0], N += D.length, D;
              }
              for (var i = t.length, l = /^[ \t\n\r\u000c]+/, p = /^[, \t\n\r\u000c]+/, y = /^[^ \t\n\r\u000c]+/, h = /[,]+$/, g = /^\d+$/, c2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, F, _, w, E, N = 0, x = []; ; ) {
                if (u(p), N >= i) return x;
                f = u(y), F = [], f.slice(-1) === "," ? (f = f.replace(h, ""), P()) : I();
              }
              function I() {
                for (u(l), _ = "", w = "in descriptor"; ; ) {
                  if (E = t.charAt(N), w === "in descriptor") if (n(E)) _ && (F.push(_), _ = "", w = "after descriptor");
                  else if (E === ",") {
                    N += 1, _ && F.push(_), P();
                    return;
                  } else if (E === "(") _ = _ + E, w = "in parens";
                  else if (E === "") {
                    _ && F.push(_), P();
                    return;
                  } else _ = _ + E;
                  else if (w === "in parens") if (E === ")") _ = _ + E, w = "in descriptor";
                  else if (E === "") {
                    F.push(_), P();
                    return;
                  } else _ = _ + E;
                  else if (w === "after descriptor" && !n(E)) if (E === "") {
                    P();
                    return;
                  } else w = "in descriptor", N -= 1;
                  N += 1;
                }
              }
              function P() {
                var $ = false, D, T, m, C, o = {}, d, v, S, b, B;
                for (C = 0; C < F.length; C++) d = F[C], v = d[d.length - 1], S = d.substring(0, d.length - 1), b = parseInt(S, 10), B = parseFloat(S), g.test(S) && v === "w" ? ((D || T) && ($ = true), b === 0 ? $ = true : D = b) : c2.test(S) && v === "x" ? ((D || T || m) && ($ = true), B < 0 ? $ = true : T = B) : g.test(S) && v === "h" ? ((m || T) && ($ = true), b === 0 ? $ = true : m = b) : $ = true;
                $ ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + d + "'.") : (o.url = f, D && (o.w = D), T && (o.d = T), m && (o.h = m), x.push(o));
              }
            };
          });
        } }), Tg = te({ "src/language-html/syntax-attribute.js"(e, r2) {
          ne();
          var t = bg(), { builders: { ifBreak: s, join: a, line: n } } = qe();
          function u(l) {
            let p = t(l, { logger: { error(I) {
              throw new Error(I);
            } } }), y = p.some((I) => {
              let { w: P } = I;
              return P;
            }), h = p.some((I) => {
              let { h: P } = I;
              return P;
            }), g = p.some((I) => {
              let { d: P } = I;
              return P;
            });
            if (y + h + g > 1) throw new Error("Mixed descriptor in srcset is not supported");
            let c2 = y ? "w" : h ? "h" : "d", f = y ? "w" : h ? "h" : "x", F = (I) => Math.max(...I), _ = p.map((I) => I.url), w = F(_.map((I) => I.length)), E = p.map((I) => I[c2]).map((I) => I ? I.toString() : ""), N = E.map((I) => {
              let P = I.indexOf(".");
              return P === -1 ? I.length : P;
            }), x = F(N);
            return a([",", n], _.map((I, P) => {
              let $ = [I], D = E[P];
              if (D) {
                let T = w - I.length + 1, m = x - N[P], C = " ".repeat(T + m);
                $.push(s(C, " "), D + f);
              }
              return $;
            }));
          }
          function i(l) {
            return l.trim().split(/\s+/).join(" ");
          }
          r2.exports = { printImgSrcset: u, printClassNames: i };
        } }), Bg = te({ "src/language-html/syntax-vue.js"(e, r2) {
          ne();
          var { builders: { group: t } } = qe();
          function s(i, l) {
            let { left: p, operator: y, right: h } = a(i);
            return [t(l(`function _(${p}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y, " ", l(h, { parser: "__js_expression" }, { stripTrailingHardline: true })];
          }
          function a(i) {
            let l = /(.*?)\s+(in|of)\s+(.*)/s, p = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y = /^\(|\)$/g, h = i.match(l);
            if (!h) return;
            let g = {};
            if (g.for = h[3].trim(), !g.for) return;
            let c2 = h[1].trim().replace(y, ""), f = c2.match(p);
            f ? (g.alias = c2.replace(p, ""), g.iterator1 = f[1].trim(), f[2] && (g.iterator2 = f[2].trim())) : g.alias = c2;
            let F = [g.alias, g.iterator1, g.iterator2];
            if (!F.some((_, w) => !_ && (w === 0 || F.slice(w + 1).some(Boolean)))) return { left: F.filter(Boolean).join(","), operator: h[2], right: g.for };
          }
          function n(i, l) {
            return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
          }
          function u(i) {
            let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y = i.trim();
            return l.test(y) || p.test(y);
          }
          r2.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: n };
        } }), Lo = te({ "src/language-html/get-node-content.js"(e, r2) {
          ne();
          var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: n, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = ur();
          function l(p, y) {
            let h = p.startSourceSpan.end.offset;
            p.firstChild && u(p.firstChild) && (h -= i(p).length);
            let g = p.endSourceSpan.start.offset;
            return p.lastChild && t(p.lastChild) ? g += s(p, y).length : a(p) && (g -= n(p.lastChild, y).length), y.originalText.slice(h, g);
          }
          r2.exports = l;
        } }), Ng = te({ "src/language-html/embed.js"(e, r2) {
          ne();
          var { builders: { breakParent: t, group: s, hardline: a, indent: n, line: u, fill: i, softline: l }, utils: { mapDoc: p, replaceTextEndOfLine: y } } = qe(), h = su(), { printClosingTag: g, printClosingTagSuffix: c2, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: F, printOpeningTag: _ } = ur(), { printImgSrcset: w, printClassNames: E } = Tg(), { printVueFor: N, printVueBindings: x, isVueEventBindingExpression: I } = Bg(), { isScriptLikeTag: P, isVueNonHtmlBlock: $, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m, unescapeQuoteEntities: C, isVueSlotAttribute: o, isVueSfcBindingsAttribute: d, getTextValueParts: v } = Rt(), S = Lo();
          function b(k, M, R) {
            let q = (ee) => new RegExp(ee.join("|")).test(k.fullName), J = () => C(k.value), L = false, Q = (ee, ce) => {
              let W = ee.type === "NGRoot" ? ee.node.type === "NGMicrosyntax" && ee.node.body.length === 1 && ee.node.body[0].type === "NGMicrosyntaxExpression" ? ee.node.body[0].expression : ee.node : ee.type === "JsExpressionRoot" ? ee.node : ee;
              W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
            }, V = (ee) => s(ee), j = function(ee) {
              let ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return s([n([l, ee]), ce ? l : ""]);
            }, Y = (ee) => L ? V(ee) : j(ee), ie = (ee, ce) => M(ee, Object.assign({ __onHtmlBindingRoot: Q, __embeddedInHtml: true }, ce));
            if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source")) return j(w(J()));
            if (k.fullName === "class" && !R.parentParser) {
              let ee = J();
              if (!ee.includes("{{")) return E(ee);
            }
            if (k.fullName === "style" && !R.parentParser) {
              let ee = J();
              if (!ee.includes("{{")) return j(ie(ee, { parser: "css", __isHTMLStyleAttribute: true }));
            }
            if (R.parser === "vue") {
              if (k.fullName === "v-for") return N(J(), ie);
              if (o(k) || d(k, R)) return x(J(), ie);
              let ee = ["^@", "^v-on:"], ce = ["^:", "^v-bind:"], W = ["^v-"];
              if (q(ee)) {
                let K = J(), de = I(K) ? "__js_expression" : R.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                return Y(ie(K, { parser: de }));
              }
              if (q(ce)) return Y(ie(J(), { parser: "__vue_expression" }));
              if (q(W)) return Y(ie(J(), { parser: "__js_expression" }));
            }
            if (R.parser === "angular") {
              let ee = (z, U) => ie(z, Object.assign(Object.assign({}, U), {}, { trailingComma: "none" })), ce = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de = ["^i18n(-.+)?$"];
              if (q(W)) return Y(ee(J(), { parser: "__ng_action" }));
              if (q(K)) return Y(ee(J(), { parser: "__ng_binding" }));
              if (q(de)) {
                let z = J().trim();
                return j(i(v(k, z)), !z.includes("@@"));
              }
              if (q(ce)) return Y(ee(J(), { parser: "__ng_directive" }));
              let ue = /{{(.+?)}}/s, Fe = J();
              if (ue.test(Fe)) {
                let z = [];
                for (let [U, Z] of Fe.split(ue).entries()) if (U % 2 === 0) z.push(y(Z));
                else try {
                  z.push(s(["{{", n([u, ee(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                } catch {
                  z.push("{{", y(Z), "}}");
                }
                return s(z);
              }
            }
            return null;
          }
          function B(k, M, R, q) {
            let J = k.getValue();
            switch (J.type) {
              case "element": {
                if (P(J) || J.type === "interpolation") return;
                if (!J.isSelfClosing && $(J, q)) {
                  let L = D(J, q);
                  if (!L) return;
                  let Q = S(J, q), V = /^\s*$/.test(Q), j = "";
                  return V || (j = R(T(Q), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j === ""), [F(J, q), s(_(k, q, M)), V ? "" : a, j, V ? "" : a, g(J, q), c2(J, q)];
                }
                break;
              }
              case "text": {
                if (P(J.parent)) {
                  let L = D(J.parent, q);
                  if (L) {
                    let Q = L === "markdown" ? m(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
                    if (q.parser === "html" && L === "babel") {
                      let j = "script", { attrMap: Y } = J.parent;
                      Y && (Y.type === "module" || Y.type === "text/babel" && Y["data-type"] === "module") && (j = "module"), V.__babelSourceType = j;
                    }
                    return [t, F(J, q), R(Q, V, { stripTrailingHardline: true }), c2(J, q)];
                  }
                } else if (J.parent.type === "interpolation") {
                  let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                  return q.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q.parser === "vue" ? L.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n([u, R(J.value, L, { stripTrailingHardline: true })]), J.parent.next && f(J.parent.next) ? " " : u];
                }
                break;
              }
              case "attribute": {
                if (!J.value) break;
                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset))) return [J.rawName, "=", J.value];
                if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset))) return [J.rawName, "=", J.value];
                let L = b(J, (Q, V) => R(Q, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
                if (L) return [J.rawName, '="', s(p(L, (Q) => typeof Q == "string" ? Q.replace(/"/g, "&quot;") : Q)), '"'];
                break;
              }
              case "front-matter":
                return h(J, R);
            }
          }
          r2.exports = B;
        } }), Oo = te({ "src/language-html/print/children.js"(e, r2) {
          ne();
          var { builders: { breakParent: t, group: s, ifBreak: a, line: n, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: p, locEnd: y } = au(), { forceBreakChildren: h, forceNextEmptyLine: g, isTextLikeNode: c2, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: F } = Rt(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w, printOpeningTagStartMarker: E, needsToBorrowPrevClosingTagEndMarker: N, printClosingTagEndMarker: x, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P } = ur();
          function $(m, C, o) {
            let d = m.getValue();
            return f(d) ? [_(d, C), ...l(C.originalText.slice(p(d) + (d.prev && w(d.prev) ? E(d).length : 0), y(d) - (d.next && N(d.next) ? x(d, C).length : 0))), I(d, C)] : o();
          }
          function D(m, C) {
            return c2(m) && c2(C) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? F(C) ? i : n : "" : F(C) ? i : u : w(m) && (f(C) || C.firstChild || C.isSelfClosing || C.type === "element" && C.attrs.length > 0) || m.type === "element" && m.isSelfClosing && N(C) ? "" : !C.isLeadingSpaceSensitive || F(C) || N(C) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n : u;
          }
          function T(m, C, o) {
            let d = m.getValue();
            if (h(d)) return [t, ...m.map((S) => {
              let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
              return [B ? [B, g(b.prev) ? i : ""] : "", $(S, C, o)];
            }, "children")];
            let v = d.children.map(() => Symbol(""));
            return m.map((S, b) => {
              let B = S.getValue();
              if (c2(B)) {
                if (B.prev && c2(B.prev)) {
                  let Q = D(B.prev, B);
                  if (Q) return g(B.prev) ? [i, i, $(S, C, o)] : [Q, $(S, C, o)];
                }
                return $(S, C, o);
              }
              let k = [], M = [], R = [], q = [], J = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
              return J && (g(B.prev) ? k.push(i, i) : J === i ? k.push(i) : c2(B.prev) ? M.push(J) : M.push(a("", u, { groupId: v[b - 1] }))), L && (g(B) ? c2(B.next) && q.push(i, i) : L === i ? c2(B.next) && q.push(i) : R.push(L)), [...k, s([...M, s([$(S, C, o), ...R], { id: v[b] })]), ...q];
            }, "children");
          }
          r2.exports = { printChildren: T };
        } }), wg = te({ "src/language-html/print/element.js"(e, r2) {
          ne();
          var { builders: { breakParent: t, dedentToRoot: s, group: a, ifBreak: n, indentIfBreak: u, indent: i, line: l, softline: p }, utils: { replaceTextEndOfLine: y } } = qe(), h = Lo(), { shouldPreserveContent: g, isScriptLikeTag: c2, isVueCustomBlock: f, countParents: F, forceBreakContent: _ } = Rt(), { printOpeningTagPrefix: w, printOpeningTag: E, printClosingTagSuffix: N, printClosingTag: x, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P } = ur(), { printChildren: $ } = Oo();
          function D(T, m, C) {
            let o = T.getValue();
            if (g(o, m)) return [w(o, m), a(E(T, m, C)), ...y(h(o, m)), ...x(o, m), N(o, m)];
            let d = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v = Symbol("element-attr-group-id"), S = (M) => a([a(E(T, m, C), { id: v }), M, x(o, m)]), b = (M) => d ? u(M, { groupId: v }) : (c2(o) || f(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? M : i(M), B = () => d ? n(p, "", { groupId: v }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(p) : p, k = () => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : d ? n(p, "", { groupId: v }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * F(T, (R) => R.parent && R.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p;
            return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t : "", b([B(), $(T, m, C)]), k()]);
          }
          r2.exports = { printElement: D };
        } }), _g = te({ "src/language-html/printer-html.js"(e, r2) {
          ne();
          var { builders: { fill: t, group: s, hardline: a, literalline: n }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: p } } = qe(), y = gg(), { countChars: h, unescapeQuoteEntities: g, getTextValueParts: c2 } = Rt(), f = Sg(), { insertPragma: F } = xg(), { locStart: _, locEnd: w } = au(), E = Ng(), { printClosingTagSuffix: N, printClosingTagEnd: x, printOpeningTagPrefix: I, printOpeningTagStart: P } = ur(), { printElement: $ } = wg(), { printChildren: D } = Oo();
          function T(m, C, o) {
            let d = m.getValue();
            switch (d.type) {
              case "front-matter":
                return p(d.raw);
              case "root":
                return C.__onHtmlRoot && C.__onHtmlRoot(d), [s(D(m, C, o)), a];
              case "element":
              case "ieConditionalComment":
                return $(m, C, o);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [P(d), x(d)];
              case "interpolation":
                return [P(d, C), ...m.map(o, "children"), x(d, C)];
              case "text": {
                if (d.parent.type === "interpolation") {
                  let S = /\n[^\S\n]*$/, b = S.test(d.value), B = b ? d.value.replace(S, "") : d.value;
                  return [...p(B), b ? a : ""];
                }
                let v = u([I(d, C), ...c2(d), N(d, C)]);
                return l(v) || v.type === "fill" ? t(i(v)) : v;
              }
              case "docType":
                return [s([P(d, C), " ", d.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x(d, C)];
              case "comment":
                return [I(d, C), ...p(C.originalText.slice(_(d), w(d)), n), N(d, C)];
              case "attribute": {
                if (d.value === null) return d.rawName;
                let v = g(d.value), S = h(v, "'"), b = h(v, '"'), B = S < b ? "'" : '"';
                return [d.rawName, "=", B, ...p(B === '"' ? v.replace(/"/g, "&quot;") : v.replace(/'/g, "&apos;")), B];
              }
              default:
                throw new Error(`Unexpected node type ${d.type}`);
            }
          }
          r2.exports = { preprocess: f, print: T, insertPragma: F, massageAstNode: y, embed: E };
        } }), Pg = te({ "src/language-html/options.js"(e, r2) {
          ne();
          var t = Mt(), s = "HTML";
          r2.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
        } }), Ig = te({ "src/language-html/parsers.js"() {
          ne();
        } }), On = te({ "node_modules/linguist-languages/data/HTML.json"(e, r2) {
          r2.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
        } }), kg = te({ "node_modules/linguist-languages/data/Vue.json"(e, r2) {
          r2.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        } }), Lg = te({ "src/language-html/index.js"(e, r2) {
          ne();
          var t = _t(), s = _g(), a = Pg(), n = Ig(), u = [t(On(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(On(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(On(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(kg(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
          r2.exports = { languages: u, printers: i, options: a, parsers: n };
        } }), Og = te({ "src/language-yaml/pragma.js"(e, r2) {
          ne();
          function t(n) {
            return /^\s*@(?:prettier|format)\s*$/.test(n);
          }
          function s(n) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n);
          }
          function a(n) {
            return `# @format

${n}`;
          }
          r2.exports = { isPragma: t, hasPragma: s, insertPragma: a };
        } }), jg = te({ "src/language-yaml/loc.js"(e, r2) {
          ne();
          function t(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          r2.exports = { locStart: t, locEnd: s };
        } }), qg = te({ "src/language-yaml/embed.js"(e, r2) {
          ne();
          function t(s, a, n, u) {
            if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath)) return n(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
          }
          r2.exports = t;
        } }), $t = te({ "src/language-yaml/utils.js"(e, r2) {
          ne();
          var { getLast: t, isNonEmptyArray: s } = Ue();
          function a(D, T) {
            let m = 0, C = D.stack.length - 1;
            for (let o = 0; o < C; o++) {
              let d = D.stack[o];
              n(d) && T(d) && m++;
            }
            return m;
          }
          function n(D, T) {
            return D && typeof D.type == "string" && (!T || T.includes(D.type));
          }
          function u(D, T, m) {
            return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C) => u(C, T, D)) }) : D, m);
          }
          function i(D, T, m) {
            Object.defineProperty(D, T, { get: m, enumerable: false });
          }
          function l(D, T) {
            let m = 0, C = T.length;
            for (let o = D.position.end.offset - 1; o < C; o++) {
              let d = T[o];
              if (d === `
` && m++, m === 1 && /\S/.test(d)) return false;
              if (m === 2) return true;
            }
            return false;
          }
          function p(D) {
            switch (D.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return false;
            }
            let m = D.stack.length;
            for (let C = 1; C < m; C++) {
              let o = D.stack[C], d = D.stack[C - 1];
              if (Array.isArray(d) && typeof o == "number" && o !== d.length - 1) return false;
            }
            return true;
          }
          function y(D) {
            return s(D.children) ? y(t(D.children)) : D;
          }
          function h(D) {
            return D.value.trim() === "prettier-ignore";
          }
          function g(D) {
            let T = D.getValue();
            if (T.type === "documentBody") {
              let m = D.getParentNode();
              return N(m.head) && h(t(m.head.endComments));
            }
            return F(T) && h(t(T.leadingComments));
          }
          function c2(D) {
            return !s(D.children) && !f(D);
          }
          function f(D) {
            return F(D) || _(D) || w(D) || E(D) || N(D);
          }
          function F(D) {
            return s(D == null ? void 0 : D.leadingComments);
          }
          function _(D) {
            return s(D == null ? void 0 : D.middleComments);
          }
          function w(D) {
            return D == null ? void 0 : D.indicatorComment;
          }
          function E(D) {
            return D == null ? void 0 : D.trailingComment;
          }
          function N(D) {
            return s(D == null ? void 0 : D.endComments);
          }
          function x(D) {
            let T = [], m;
            for (let C of D.split(/( +)/)) C !== " " ? m === " " ? T.push(C) : T.push((T.pop() || "") + C) : m === void 0 && T.unshift(""), m = C;
            return m === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
          }
          function I(D, T, m) {
            let C = T.split(`
`).map((o, d, v) => d === 0 && d === v.length - 1 ? o : d !== 0 && d !== v.length - 1 ? o.trim() : d === 0 ? o.trimEnd() : o.trimStart());
            return m.proseWrap === "preserve" ? C.map((o) => o.length === 0 ? [] : [o]) : C.map((o) => o.length === 0 ? [] : x(o)).reduce((o, d, v) => v !== 0 && C[v - 1].length > 0 && d.length > 0 && !(D === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...d]] : [...o, d], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
          }
          function P(D, T) {
            let { parentIndent: m, isLastDescendant: C, options: o } = T, d = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v;
            if (D.indent === null) {
              let B = d.match(/^(?<leadingSpace> *)[^\n\r ]/m);
              v = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else v = D.indent - 1 + m;
            let S = d.split(`
`).map((B) => B.slice(v));
            if (o.proseWrap === "preserve" || D.type === "blockLiteral") return b(S.map((B) => B.length === 0 ? [] : [B]));
            return b(S.map((B) => B.length === 0 ? [] : x(B)).reduce((B, k, M) => M !== 0 && S[M - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + M] : [...k, M], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
            function b(B) {
              if (D.chomping === "keep") return t(B).length === 0 ? B.slice(0, -1) : B;
              let k = 0;
              for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--) k++;
              return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);
            }
          }
          function $(D) {
            if (!D) return true;
            switch (D.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return true;
              default:
                return false;
            }
          }
          r2.exports = { getLast: t, getAncestorCount: a, isNode: n, isEmptyNode: c2, isInlineNode: $, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: p, getBlockValueLineContents: P, getFlowScalarLineContents: I, getLastDescendantNode: y, hasPrettierIgnore: g, hasLeadingComments: F, hasMiddleComments: _, hasIndicatorComment: w, hasTrailingComment: E, hasEndComments: N };
        } }), Mg = te({ "src/language-yaml/print-preprocess.js"(e, r2) {
          ne();
          var { defineShortcut: t, mapNode: s } = $t();
          function a(u) {
            return s(u, n);
          }
          function n(u) {
            switch (u.type) {
              case "document":
                t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t(u, "content", () => u.children[0]);
                break;
              case "mappingItem":
              case "flowMappingItem":
                t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                break;
            }
            return u;
          }
          r2.exports = a;
        } }), Mr = te({ "src/language-yaml/print/misc.js"(e, r2) {
          ne();
          var { builders: { softline: t, align: s } } = qe(), { hasEndComments: a, isNextLineEmpty: n, isNode: u } = $t(), i = /* @__PURE__ */ new WeakMap();
          function l(h, g) {
            let c2 = h.getValue(), f = h.stack[0], F;
            return i.has(f) ? F = i.get(f) : (F = /* @__PURE__ */ new Set(), i.set(f, F)), !F.has(c2.position.end.line) && (F.add(c2.position.end.line), n(c2, g) && !p(h.getParentNode())) ? t : "";
          }
          function p(h) {
            return a(h) && !u(h, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          function y(h, g) {
            return s(" ".repeat(h), g);
          }
          r2.exports = { alignWithSpaces: y, shouldPrintEndComments: p, printNextEmptyLine: l };
        } }), Rg = te({ "src/language-yaml/print/flow-mapping-sequence.js"(e, r2) {
          ne();
          var { builders: { ifBreak: t, line: s, softline: a, hardline: n, join: u } } = qe(), { isEmptyNode: i, getLast: l, hasEndComments: p } = $t(), { printNextEmptyLine: y, alignWithSpaces: h } = Mr();
          function g(f, F, _) {
            let w = f.getValue(), E = w.type === "flowMapping", N = E ? "{" : "[", x = E ? "}" : "]", I = a;
            E && w.children.length > 0 && _.bracketSpacing && (I = s);
            let P = l(w.children), $ = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
            return [N, h(_.tabWidth, [I, c2(f, F, _), _.trailingComma === "none" ? "" : t(","), p(w) ? [n, u(n, f.map(F, "endComments"))] : ""]), $ ? "" : I, x];
          }
          function c2(f, F, _) {
            let w = f.getValue();
            return f.map((N, x) => [F(), x === w.children.length - 1 ? "" : [",", s, w.children[x].position.start.line !== w.children[x + 1].position.start.line ? y(N, _.originalText) : ""]], "children");
          }
          r2.exports = { printFlowMapping: g, printFlowSequence: g };
        } }), $g = te({ "src/language-yaml/print/mapping-item.js"(e, r2) {
          ne();
          var { builders: { conditionalGroup: t, group: s, hardline: a, ifBreak: n, join: u, line: i } } = qe(), { hasLeadingComments: l, hasMiddleComments: p, hasTrailingComment: y, hasEndComments: h, isNode: g, isEmptyNode: c2, isInlineNode: f } = $t(), { alignWithSpaces: F } = Mr();
          function _(x, I, P, $, D) {
            let { key: T, value: m } = x, C = c2(T), o = c2(m);
            if (C && o) return ": ";
            let d = $("key"), v = E(x) ? " " : "";
            if (o) return x.type === "flowMappingItem" && I.type === "flowMapping" ? d : x.type === "mappingItem" && w(T.content, D) && !y(T.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [d, v, ":"] : ["? ", F(2, d)];
            let S = $("value");
            if (C) return [": ", F(2, S)];
            if (l(m) || !f(T.content)) return ["? ", F(2, d), a, u("", P.map($, "value", "leadingComments").map((q) => [q, a])), ": ", F(2, S)];
            if (N(T.content) && !l(T.content) && !p(T.content) && !y(T.content) && !h(T) && !l(m.content) && !p(m.content) && !h(m) && w(m.content, D)) return [d, v, ": ", S];
            let b = Symbol("mappingKey"), B = s([n("? "), s(F(2, d), { id: b })]), k = [a, ": ", F(2, S)], M = [v, ":"];
            l(m.content) || h(m) && m.content && !g(m.content, ["mapping", "sequence"]) || I.type === "mapping" && y(T.content) && f(m.content) || g(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? M.push(a) : m.content && M.push(i), M.push(S);
            let R = F(D.tabWidth, M);
            return w(T.content, D) && !l(T.content) && !p(T.content) && !h(T) ? t([[d, R]]) : t([[B, n(k, R, { groupId: b })]]);
          }
          function w(x, I) {
            if (!x) return true;
            switch (x.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return true;
              default:
                return false;
            }
            if (I.proseWrap === "preserve") return x.position.start.line === x.position.end.line;
            if (/\\$/m.test(I.originalText.slice(x.position.start.offset, x.position.end.offset))) return false;
            switch (I.proseWrap) {
              case "never":
                return !x.value.includes(`
`);
              case "always":
                return !/[\n ]/.test(x.value);
              default:
                return false;
            }
          }
          function E(x) {
            return x.key.content && x.key.content.type === "alias";
          }
          function N(x) {
            if (!x) return true;
            switch (x.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return x.position.start.line === x.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }
          r2.exports = _;
        } }), Vg = te({ "src/language-yaml/print/block.js"(e, r2) {
          ne();
          var { builders: { dedent: t, dedentToRoot: s, fill: a, hardline: n, join: u, line: i, literalline: l, markAsRoot: p }, utils: { getDocParts: y } } = qe(), { getAncestorCount: h, getBlockValueLineContents: g, hasIndicatorComment: c2, isLastDescendantNode: f, isNode: F } = $t(), { alignWithSpaces: _ } = Mr();
          function w(E, N, x) {
            let I = E.getValue(), P = h(E, (C) => F(C, ["sequence", "mapping"])), $ = f(E), D = [I.type === "blockFolded" ? ">" : "|"];
            I.indent !== null && D.push(I.indent.toString()), I.chomping !== "clip" && D.push(I.chomping === "keep" ? "+" : "-"), c2(I) && D.push(" ", N("indicatorComment"));
            let T = g(I, { parentIndent: P, isLastDescendant: $, options: x }), m = [];
            for (let [C, o] of T.entries()) C === 0 && m.push(n), m.push(a(y(u(i, o)))), C !== T.length - 1 ? m.push(o.length === 0 ? n : p(l)) : I.chomping === "keep" && $ && m.push(s(o.length === 0 ? n : l));
            return I.indent === null ? D.push(t(_(x.tabWidth, m))) : D.push(s(_(I.indent - 1 + P, m))), D;
          }
          r2.exports = w;
        } }), Wg = te({ "src/language-yaml/printer-yaml.js"(e, r2) {
          ne();
          var { builders: { breakParent: t, fill: s, group: a, hardline: n, join: u, line: i, lineSuffix: l, literalline: p }, utils: { getDocParts: y, replaceTextEndOfLine: h } } = qe(), { isPreviousLineEmpty: g } = Ue(), { insertPragma: c2, isPragma: f } = Og(), { locStart: F } = jg(), _ = qg(), { getFlowScalarLineContents: w, getLastDescendantNode: E, hasLeadingComments: N, hasMiddleComments: x, hasTrailingComment: I, hasEndComments: P, hasPrettierIgnore: $, isLastDescendantNode: D, isNode: T, isInlineNode: m } = $t(), C = Mg(), { alignWithSpaces: o, printNextEmptyLine: d, shouldPrintEndComments: v } = Mr(), { printFlowMapping: S, printFlowSequence: b } = Rg(), B = $g(), k = Vg();
          function M(j, Y, ie) {
            let ee = j.getValue(), ce = [];
            ee.type !== "mappingValue" && N(ee) && ce.push([u(n, j.map(ie, "leadingComments")), n]);
            let { tag: W, anchor: K } = ee;
            W && ce.push(ie("tag")), W && K && ce.push(" "), K && ce.push(ie("anchor"));
            let de = "";
            T(ee, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j) && (de = d(j, Y.originalText)), (W || K) && (T(ee, ["sequence", "mapping"]) && !x(ee) ? ce.push(n) : ce.push(" ")), x(ee) && ce.push([ee.middleComments.length === 1 ? "" : n, u(n, j.map(ie, "middleComments")), n]);
            let ue = j.getParentNode();
            return $(j) ? ce.push(h(Y.originalText.slice(ee.position.start.offset, ee.position.end.offset).trimEnd(), p)) : ce.push(a(R(ee, ue, j, Y, ie))), I(ee) && !T(ee, ["document", "documentHead"]) && ce.push(l([ee.type === "mappingValue" && !ee.content ? "" : " ", ue.type === "mappingKey" && j.getParentNode(2).type === "mapping" && m(ee) ? "" : t, ie("trailingComment")])), v(ee) && ce.push(o(ee.type === "sequenceItem" ? 2 : 0, [n, u(n, j.map((Fe) => [g(Y.originalText, Fe.getValue(), F) ? n : "", ie()], "endComments"))])), ce.push(de), ce;
          }
          function R(j, Y, ie, ee, ce) {
            switch (j.type) {
              case "root": {
                let { children: W } = j, K = [];
                ie.each((ue, Fe) => {
                  let z = W[Fe], U = W[Fe + 1];
                  Fe !== 0 && K.push(n), K.push(ce()), J(z, U) ? (K.push(n, "..."), I(z) && K.push(" ", ce("trailingComment"))) : U && !I(U.head) && K.push(n, "---");
                }, "children");
                let de = E(j);
                return (!T(de, ["blockLiteral", "blockFolded"]) || de.chomping !== "keep") && K.push(n), K;
              }
              case "document": {
                let W = Y.children[ie.getName() + 1], K = [];
                return L(j, W, Y, ee) === "head" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K.push(ce("head")), I(j.head) ? K.push(["---", " ", ce(["head", "trailingComment"])]) : K.push("---")), q(j) && K.push(ce("body")), u(n, K);
              }
              case "documentHead":
                return u(n, [...ie.map(ce, "children"), ...ie.map(ce, "endComments")]);
              case "documentBody": {
                let { children: W, endComments: K } = j, de = "";
                if (W.length > 0 && K.length > 0) {
                  let ue = E(j);
                  T(ue, ["blockFolded", "blockLiteral"]) ? ue.chomping !== "keep" && (de = [n, n]) : de = n;
                }
                return [u(n, ie.map(ce, "children")), de, u(n, ie.map(ce, "endComments"))];
              }
              case "directive":
                return ["%", u(" ", [j.name, ...j.parameters])];
              case "comment":
                return ["#", j.value];
              case "alias":
                return ["*", j.value];
              case "tag":
                return ee.originalText.slice(j.position.start.offset, j.position.end.offset);
              case "anchor":
                return ["&", j.value];
              case "plain":
                return Q(j.type, ee.originalText.slice(j.position.start.offset, j.position.end.offset), ee);
              case "quoteDouble":
              case "quoteSingle": {
                let W = "'", K = '"', de = ee.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);
                if (j.type === "quoteSingle" && de.includes("\\") || j.type === "quoteDouble" && /\\[^"]/.test(de)) {
                  let Fe = j.type === "quoteDouble" ? K : W;
                  return [Fe, Q(j.type, de, ee), Fe];
                }
                if (de.includes(K)) return [W, Q(j.type, j.type === "quoteDouble" ? de.replace(/\\"/g, K).replace(/'/g, W.repeat(2)) : de, ee), W];
                if (de.includes(W)) return [K, Q(j.type, j.type === "quoteSingle" ? de.replace(/''/g, W) : de, ee), K];
                let ue = ee.singleQuote ? W : K;
                return [ue, Q(j.type, de, ee), ue];
              }
              case "blockFolded":
              case "blockLiteral":
                return k(ie, ce, ee);
              case "mapping":
              case "sequence":
                return u(n, ie.map(ce, "children"));
              case "sequenceItem":
                return ["- ", o(2, j.content ? ce("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return j.content ? ce("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return B(j, Y, ie, ce, ee);
              case "flowMapping":
                return S(ie, ce, ee);
              case "flowSequence":
                return b(ie, ce, ee);
              case "flowSequenceItem":
                return ce("content");
              default:
                throw new Error(`Unexpected node type ${j.type}`);
            }
          }
          function q(j) {
            return j.body.children.length > 0 || P(j.body);
          }
          function J(j, Y) {
            return I(j) || Y && (Y.head.children.length > 0 || P(Y.head));
          }
          function L(j, Y, ie, ee) {
            return ie.children[0] === j && /---(?:\s|$)/.test(ee.originalText.slice(F(j), F(j) + 4)) || j.head.children.length > 0 || P(j.head) || I(j.head) ? "head" : J(j, Y) ? false : Y ? "root" : false;
          }
          function Q(j, Y, ie) {
            let ee = w(j, Y, ie);
            return u(n, ee.map((ce) => s(y(u(i, ce)))));
          }
          function V(j, Y) {
            if (T(Y)) switch (delete Y.position, Y.type) {
              case "comment":
                if (f(Y.value)) return null;
                break;
              case "quoteDouble":
              case "quoteSingle":
                Y.type = "quote";
                break;
            }
          }
          r2.exports = { preprocess: C, embed: _, print: M, massageAstNode: V, insertPragma: c2 };
        } }), Hg = te({ "src/language-yaml/options.js"(e, r2) {
          ne();
          var t = Mt();
          r2.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
        } }), Gg = te({ "src/language-yaml/parsers.js"() {
          ne();
        } }), Ug = te({ "node_modules/linguist-languages/data/YAML.json"(e, r2) {
          r2.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
        } }), Jg = te({ "src/language-yaml/index.js"(e, r2) {
          ne();
          var t = _t(), s = Wg(), a = Hg(), n = Gg(), u = [t(Ug(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
          r2.exports = { languages: u, printers: { yaml: s }, options: a, parsers: n };
        } }), zg = te({ "src/languages.js"(e, r2) {
          ne(), r2.exports = [Bd(), Ud(), eg(), ag(), dg(), Lg(), Jg()];
        } });
        ne();
        var { version: Xg } = Ia(), Ot = Gm(), { getSupportInfo: Kg } = Xn(), Yg = Um(), Qg = zg(), Zg = qe();
        function Nt(e) {
          let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) s[a] = arguments[a];
            let n = s[r2] || {}, u = n.plugins || [];
            return s[r2] = Object.assign(Object.assign({}, n), {}, { plugins: [...Qg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
          };
        }
        var jn = Nt(Ot.formatWithCursor);
        jo.exports = { formatWithCursor: jn, format(e, r2) {
          return jn(e, r2).formatted;
        }, check(e, r2) {
          let { formatted: t } = jn(e, r2);
          return t === e;
        }, doc: Zg, getSupportInfo: Nt(Kg, 0), version: Xg, util: Yg, __debug: { parse: Nt(Ot.parse), formatAST: Nt(Ot.formatAST), formatDoc: Nt(Ot.formatDoc), printToDoc: Nt(Ot.printToDoc), printDocToString: Nt(Ot.printDocToString) } };
      });
      return e0();
    });
  }
});

// src/converter.ts
init_esm_shims();

// ../core/src/index.ts
init_esm_shims();

// ../core/src/extensions/index.ts
init_esm_shims();

// ../core/src/extensions/alert.ts
init_esm_shims();

// ../core/src/utils/index.ts
init_esm_shims();

// ../core/src/utils/basicHelpers.ts
init_esm_shims();
function ucfirst(str) {
  return str.slice(0, 1).toUpperCase() + str.slice(1).toLowerCase();
}

// ../core/src/utils/initializeMermaid.ts
init_esm_shims();

// ../core/src/utils/languages.ts
init_esm_shims();
var COMMON_LANGUAGES = {
  bash,
  c,
  cpp,
  csharp,
  css,
  diff,
  go,
  graphql,
  ini,
  java,
  javascript,
  json,
  kotlin,
  less,
  lua,
  makefile,
  markdown,
  objectivec,
  perl,
  php,
  "php-template": phpTemplate,
  plaintext,
  python,
  "python-repl": pythonRepl,
  r,
  ruby,
  rust,
  scss,
  shell,
  sql,
  swift,
  typescript,
  vbnet,
  wasm,
  xml,
  yaml
};
function formatHighlightedCode(html, preserveNewlines = false) {
  let formatted = html;
  formatted = formatted.replace(/(<span[^>]*>[^<]*<\/span>)(\s+)(<span[^>]*>[^<]*<\/span>)/g, (_, span1, spaces, span2) => span1 + span2.replace(/^(<span[^>]*>)/, `$1${spaces}`));
  formatted = formatted.replace(/(\s+)(<span[^>]*>)/g, (_, spaces, span) => span.replace(/^(<span[^>]*>)/, `$1${spaces}`));
  formatted = formatted.replace(/\t/g, `    `);
  if (preserveNewlines) {
    formatted = formatted.replace(/\r\n/g, `<br/>`).replace(/\n/g, `<br/>`).replace(/(>[^<]+)|(^[^<]+)/g, (str) => str.replace(/\s/g, `&nbsp;`));
  } else {
    formatted = formatted.replace(/(>[^<]+)|(^[^<]+)/g, (str) => str.replace(/\s/g, `&nbsp;`));
  }
  return formatted;
}
function highlightAndFormatCode(text, language, hljs2, showLineNumber) {
  let highlighted = ``;
  if (showLineNumber) {
    const rawLines = text.replace(/\r\n/g, `
`).split(`
`);
    const highlightedLines = rawLines.map((lineRaw) => {
      const lineHtml = hljs2.highlight(lineRaw, { language }).value;
      const formatted = formatHighlightedCode(lineHtml, false);
      return formatted === `` ? `&nbsp;` : formatted;
    });
    const lineNumbersHtml = highlightedLines.map((_, idx) => `<section style="padding:0 10px 0 0;line-height:1.75">${idx + 1}</section>`).join(``);
    const codeInnerHtml = highlightedLines.join(`<br/>`);
    const codeLinesHtml = `<div style="white-space:pre;min-width:max-content;line-height:1.75">${codeInnerHtml}</div>`;
    const lineNumberColumnStyles = `text-align:right;padding:8px 0;border-right:1px solid rgba(0,0,0,0.04);user-select:none;background:var(--code-bg,transparent);`;
    highlighted = `
      <section style="display:flex;align-items:flex-start;overflow-x:hidden;overflow-y:auto;width:100%;max-width:100%;padding:0;box-sizing:border-box">
        <section class="line-numbers" style="${lineNumberColumnStyles}">${lineNumbersHtml}</section>
        <section class="code-scroll" style="flex:1 1 auto;overflow-x:auto;overflow-y:visible;padding:8px;min-width:0;box-sizing:border-box">${codeLinesHtml}</section>
      </section>
    `;
  } else {
    const rawHighlighted = hljs2.highlight(text, { language }).value;
    highlighted = formatHighlightedCode(rawHighlighted, true);
  }
  return highlighted;
}

// ../core/src/utils/markdownHelpers.ts
init_esm_shims();
function renderMarkdown(raw, renderer) {
  const { markdownContent, readingTime: readingTime2 } = renderer.parseFrontMatterAndContent(raw);
  let html = marked.parse(markdownContent);
  html = DOMPurify.sanitize(html, { ADD_TAGS: [`mp-common-profile`] });
  return { html, readingTime: readingTime2 };
}
function postProcessHtml(baseHtml, reading, renderer) {
  let html = baseHtml;
  html = renderer.buildReadingTime(reading) + html;
  html = html.replace(/(style=".*?)"/, `$1;margin-top: 0"`);
  html += renderer.buildFootnotes();
  html += renderer.buildAddition();
  html += `
    <style>
      .hljs.code__pre > .mac-sign {
        display: ${renderer.getOpts().isMacCodeBlock ? `flex` : `none`};
      }
    </style>
  `;
  html += `
    <style>
      .code__pre {
        padding: 0 !important;
      }

      .hljs.code__pre code {
        display: -webkit-box;
        padding: 0.5em 1em 1em;
        overflow-x: auto;
        text-indent: 0;
      }
      h2 strong {
        color: inherit !important;
      }
    </style>
  `;
  return renderer.createContainer(html);
}

// ../core/src/utils/themeHelpers.ts
init_esm_shims();
function customizeTheme(theme, options) {
  const newTheme = JSON.parse(JSON.stringify(theme));
  const { fontSize, color } = options;
  if (fontSize) {
    for (let i = 1; i <= 6; i++) {
      const v = newTheme.block[`h${i}`][`font-size`];
      newTheme.block[`h${i}`][`font-size`] = `${fontSize * Number.parseFloat(v)}px`;
    }
  }
  if (color) {
    newTheme.base[`--md-primary-color`] = color;
  }
  return newTheme;
}
function customCssWithTemplate(jsonString, color, theme) {
  const newTheme = customizeTheme(theme, { color });
  const mergeProperties = (target, source, keys) => {
    keys.forEach((key) => {
      if (source[key]) {
        target[key] = Object.assign(target[key] || {}, source[key]);
      }
    });
  };
  const blockKeys = [
    `container`,
    `h1`,
    `h2`,
    `h3`,
    `h4`,
    `h5`,
    `h6`,
    `code`,
    `code_pre`,
    `p`,
    `hr`,
    `blockquote`,
    `blockquote_note`,
    `blockquote_tip`,
    `blockquote_important`,
    `blockquote_warning`,
    `blockquote_caution`,
    `blockquote_p`,
    `blockquote_p_note`,
    `blockquote_p_tip`,
    `blockquote_p_important`,
    `blockquote_p_warning`,
    `blockquote_p_caution`,
    `blockquote_title`,
    `blockquote_title_note`,
    `blockquote_title_tip`,
    `blockquote_title_important`,
    `blockquote_title_warning`,
    `blockquote_title_caution`,
    `image`,
    `ul`,
    `ol`,
    `block_katex`
  ];
  const inlineKeys = [`listitem`, `codespan`, `link`, `wx_link`, `strong`, `table`, `thead`, `th`, `td`, `footnote`, `figcaption`, `em`, `inline_katex`];
  mergeProperties(newTheme.block, jsonString, blockKeys);
  mergeProperties(newTheme.inline, jsonString, inlineKeys);
  return newTheme;
}
function getStyleString(style) {
  return Object.entries(style ?? {}).map(([key, value]) => `${key}: ${value}`).join(`; `);
}

// ../core/src/extensions/alert.ts
function markedAlert(options = {}) {
  const { className = `markdown-alert`, variants = [], withoutStyle = false } = options;
  const resolvedVariants = resolveVariants(variants);
  function buildMeta(variantType, matchedVariant, fromContainer = false) {
    const { styles } = options;
    return {
      className,
      variant: variantType,
      icon: matchedVariant.icon,
      title: matchedVariant.title ?? ucfirst(variantType),
      titleClassName: `${className}-title`,
      fromContainer,
      wrapperStyle: {
        ...styles?.blockquote,
        ...styles?.[`blockquote_${variantType}`]
      },
      titleStyle: {
        ...styles?.blockquote_title,
        ...styles?.[`blockquote_title_${variantType}`]
      },
      contentStyle: {
        ...styles?.blockquote_p,
        ...styles?.[`blockquote_p_${variantType}`]
      }
    };
  }
  function renderAlert(token) {
    const { meta, tokens = [] } = token;
    let text = this.parser.parse(tokens);
    text = text.replace(/<p .*?>/g, `<p style="${getStyleString(meta.contentStyle)}">`);
    let tmpl = `<blockquote class="${meta.className} ${meta.className}-${meta.variant}" style="${getStyleString(meta.wrapperStyle)}">
`;
    tmpl += `<p class="${meta.titleClassName}" style="${getStyleString(meta.titleStyle)}">`;
    if (!withoutStyle) {
      tmpl += meta.icon.replace(
        `<svg`,
        `<svg style="fill: ${meta.titleStyle?.color ?? `inherit`}"`
      );
    }
    tmpl += meta.title;
    tmpl += `</p>
`;
    tmpl += text;
    tmpl += `</blockquote>
`;
    return tmpl;
  }
  return {
    walkTokens(token) {
      if (token.type !== `blockquote`)
        return;
      const matchedVariant = resolvedVariants.find(
        ({ type }) => new RegExp(createSyntaxPattern(type), `i`).test(token.text)
      );
      if (matchedVariant) {
        const { type: variantType } = matchedVariant;
        const typeRegexp = new RegExp(createSyntaxPattern(variantType), `i`);
        Object.assign(token, {
          type: `alert`,
          meta: buildMeta(variantType, matchedVariant)
        });
        const firstLine = token.tokens?.[0];
        const firstLineText = firstLine.raw?.replace(typeRegexp, ``).trim();
        if (firstLineText) {
          const patternToken = firstLine.tokens[0];
          Object.assign(patternToken, {
            raw: patternToken.raw.replace(typeRegexp, ``),
            text: patternToken.text.replace(typeRegexp, ``)
          });
          if (firstLine.tokens[1]?.type === `br`) {
            firstLine.tokens.splice(1, 1);
          }
        } else {
          token.tokens?.shift();
        }
      }
    },
    extensions: [
      {
        name: `alert`,
        level: `block`,
        renderer: renderAlert
      },
      {
        name: `alertContainer`,
        level: `block`,
        start(src) {
          return src.match(/^:::/)?.index;
        },
        tokenizer(src, _tokens) {
          const match = /^:::\s*(\w+)\s*\n([\s\S]*?)\n:::/.exec(src);
          if (match) {
            const [raw, variant, content] = match;
            const matchedVariant = resolvedVariants.find((v) => v.type === variant);
            if (!matchedVariant)
              return;
            return {
              type: `alert`,
              raw,
              text: content.trim(),
              tokens: this.lexer.blockTokens(content.trim()),
              meta: buildMeta(variant, matchedVariant, true)
            };
          }
        },
        renderer: renderAlert
      }
    ]
  };
}
var defaultAlertVariant = [
  {
    type: `note`,
    icon: `<svg class="octicon octicon-info" style="margin-right: 0.25em;" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>`
  },
  {
    type: `info`,
    icon: `<svg class="octicon octicon-info" style="margin-right: 0.25em;" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>`
  },
  {
    type: `tip`,
    icon: `<svg class="octicon octicon-light-bulb" style="margin-right: 0.25em;" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>`
  },
  {
    type: `important`,
    icon: `<svg class="octicon octicon-report" style="margin-right: 0.25em;" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>`
  },
  {
    type: `warning`,
    icon: `<svg class="octicon octicon-alert" style="margin-right: 0.25em;" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>`
  },
  {
    type: `caution`,
    icon: `<svg class="octicon octicon-stop" style="margin-right: 0.25em;" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>`
  }
];
function resolveVariants(variants) {
  if (!variants.length)
    return defaultAlertVariant;
  return Object.values(
    [...defaultAlertVariant, ...variants].reduce(
      (map, item) => {
        map[item.type] = item;
        return map;
      },
      {}
    )
  );
}
function createSyntaxPattern(type) {
  return `^(?:\\[!${type}])\\s*?
*`;
}

// ../core/src/extensions/footnotes.ts
init_esm_shims();
var fnMap = /* @__PURE__ */ new Map();
function markedFootnotes() {
  return {
    extensions: [
      {
        name: `footnoteDef`,
        level: `block`,
        start(src) {
          fnMap.clear();
          return src.match(/^\[\^/)?.index;
        },
        tokenizer(src) {
          const match = src.match(/^\[\^(.*)\]:(.*)/);
          if (match) {
            const [raw, fnId, text] = match;
            const index = fnMap.size + 1;
            fnMap.set(fnId, { index, text });
            return {
              type: `footnoteDef`,
              raw,
              fnId,
              index,
              text
            };
          }
          return void 0;
        },
        renderer(token) {
          const { index, text, fnId } = token;
          const fnInner = `
                <code>${index}.</code> 
                <span>${text}</span> 
                    <a id="fnDef-${fnId}" href="#fnRef-${fnId}" style="color: var(--md-primary-color);">\u21A9\uFE0E</a>
                <br>`;
          if (index === 1) {
            return `
            <p style="font-size: 80%;margin: 0.5em 8px;word-break:break-all;">${fnInner}`;
          }
          if (index === fnMap.size) {
            return `${fnInner}</p>`;
          }
          return fnInner;
        }
      },
      {
        name: `footnoteRef`,
        level: `inline`,
        start(src) {
          return src.match(/\[\^/)?.index;
        },
        tokenizer(src) {
          const match = src.match(/^\[\^(.*?)\]/);
          if (match) {
            const [raw, fnId] = match;
            if (fnMap.has(fnId)) {
              return {
                type: `footnoteRef`,
                raw,
                fnId
              };
            }
          }
        },
        renderer(token) {
          const { fnId } = token;
          const { index } = fnMap.get(fnId);
          return `<sup style="color: var(--md-primary-color);">
                    <a href="#fnDef-${fnId}" id="fnRef-${fnId}">[${index}]</a>
                </sup>`;
        }
      }
    ]
  };
}

// ../core/src/extensions/katex.ts
init_esm_shims();
var inlineRule = /^(\${1,2})(?!\$)((?:\\.|[^\\\n])*?(?:\\.|[^\\\n$]))\1(?=[\s?!.,:]|$)/;
var inlineRuleNonStandard = /^(\${1,2})(?!\$)((?:\\.|[^\\\n])*?(?:\\.|[^\\\n$]))\1/;
var blockRule = /^\s{0,3}(\${1,2})[ \t]*\n([\s\S]+?)\n\s{0,3}\1[ \t]*(?:\n|$)/;
var inlineLatexRule = /^\\\(([^\\]*(?:\\.[^\\]*)*?)\\\)/;
var blockLatexRule = /^\\\[([^\\]*(?:\\.[^\\]*)*?)\\\]/;
function createRenderer(display, inlineStyle, blockStyle, withStyle = true) {
  return (token) => {
    window.MathJax.texReset();
    const mjxContainer = window.MathJax.tex2svg(token.text, { display });
    const svg = mjxContainer.firstChild;
    const width = svg.style[`min-width`] || svg.getAttribute(`width`);
    svg.removeAttribute(`width`);
    if (withStyle) {
      svg.style.display = `initial`;
      svg.style.setProperty(`max-width`, `300vw`, `important`);
      svg.style.flexShrink = `0`;
      svg.style.width = width;
    }
    if (!display) {
      return `<span ${inlineStyle}>${svg.outerHTML}</span>`;
    }
    return `<section ${blockStyle}>${svg.outerHTML}</section>`;
  };
}
function inlineKatex(options, renderer) {
  const nonStandard = options && options.nonStandard;
  const ruleReg = nonStandard ? inlineRuleNonStandard : inlineRule;
  return {
    name: `inlineKatex`,
    level: `inline`,
    start(src) {
      let index;
      let indexSrc = src;
      while (indexSrc) {
        index = indexSrc.indexOf(`$`);
        if (index === -1) {
          return;
        }
        const f = nonStandard ? index > -1 : index === 0 || indexSrc.charAt(index - 1) === ` `;
        if (f) {
          const possibleKatex = indexSrc.substring(index);
          if (possibleKatex.match(ruleReg)) {
            return index;
          }
        }
        indexSrc = indexSrc.substring(index + 1).replace(/^\$+/, ``);
      }
    },
    tokenizer(src) {
      const match = src.match(ruleReg);
      if (match) {
        return {
          type: `inlineKatex`,
          raw: match[0],
          text: match[2].trim(),
          displayMode: match[1].length === 2
        };
      }
    },
    renderer
  };
}
function blockKatex(_options, renderer) {
  return {
    name: `blockKatex`,
    level: `block`,
    tokenizer(src) {
      const match = src.match(blockRule);
      if (match) {
        return {
          type: `blockKatex`,
          raw: match[0],
          text: match[2].trim(),
          displayMode: match[1].length === 2
        };
      }
    },
    renderer
  };
}
function inlineLatexKatex(_options, renderer) {
  return {
    name: `inlineLatexKatex`,
    level: `inline`,
    start(src) {
      const index = src.indexOf(`\\(`);
      return index !== -1 ? index : void 0;
    },
    tokenizer(src) {
      const match = src.match(inlineLatexRule);
      if (match) {
        return {
          type: `inlineLatexKatex`,
          raw: match[0],
          text: match[1].trim(),
          displayMode: false
        };
      }
    },
    renderer
  };
}
function blockLatexKatex(_options, renderer) {
  return {
    name: `blockLatexKatex`,
    level: `block`,
    start(src) {
      const index = src.indexOf(`\\[`);
      return index !== -1 ? index : void 0;
    },
    tokenizer(src) {
      const match = src.match(blockLatexRule);
      if (match) {
        return {
          type: `blockLatexKatex`,
          raw: match[0],
          text: match[1].trim(),
          displayMode: true
        };
      }
    },
    renderer
  };
}
function MDKatex(options, inlineStyle, blockStyle, withStyle = true) {
  return {
    extensions: [
      inlineKatex(options, createRenderer(false, inlineStyle, blockStyle, withStyle)),
      blockKatex(options, createRenderer(true, inlineStyle, blockStyle, withStyle)),
      inlineLatexKatex(options, createRenderer(false, inlineStyle, blockStyle, withStyle)),
      blockLatexKatex(options, createRenderer(true, inlineStyle, blockStyle, withStyle))
    ]
  };
}

// ../core/src/extensions/markup.ts
init_esm_shims();
function markedMarkup(options = {}) {
  const { styles } = options;
  return {
    extensions: [
      //  ====
      {
        name: `markup_highlight`,
        level: `inline`,
        start(src) {
          return src.match(/==(?!=)/)?.index;
        },
        tokenizer(src) {
          const rule = /^==((?:[^=]|=(?!=))+)==/;
          const match = rule.exec(src);
          if (match) {
            return {
              type: `markup_highlight`,
              raw: match[0],
              text: match[1]
            };
          }
        },
        renderer(token) {
          const style = getStyleString(styles?.markup_highlight ?? {});
          return `<span class="markup-highlight" style="${style}">${token.text}</span>`;
        }
      },
      //  ++++
      {
        name: `markup_underline`,
        level: `inline`,
        start(src) {
          return src.match(/\+\+(?!\+)/)?.index;
        },
        tokenizer(src) {
          const rule = /^\+\+((?:[^+]|\+(?!\+))+)\+\+/;
          const match = rule.exec(src);
          if (match) {
            return {
              type: `markup_underline`,
              raw: match[0],
              text: match[1]
            };
          }
        },
        renderer(token) {
          const style = getStyleString(styles?.markup_underline ?? {});
          return `<span class="markup-underline" style="${style}">${token.text}</span>`;
        }
      },
      //  ~~
      {
        name: `markup_wavyline`,
        level: `inline`,
        start(src) {
          return src.match(/~(?!~)/)?.index;
        },
        tokenizer(src) {
          const rule = /^~([^~\n]+)~(?!~)/;
          const match = rule.exec(src);
          if (match) {
            return {
              type: `markup_wavyline`,
              raw: match[0],
              text: match[1]
            };
          }
        },
        renderer(token) {
          const style = getStyleString(styles?.markup_wavyline ?? {});
          return `<span class="markup-wavyline" style="${style}">${token.text}</span>`;
        }
      }
    ]
  };
}

// ../core/src/extensions/plantuml.ts
init_esm_shims();
function encode6bit(b) {
  if (b < 10) {
    return String.fromCharCode(48 + b);
  }
  b -= 10;
  if (b < 26) {
    return String.fromCharCode(65 + b);
  }
  b -= 26;
  if (b < 26) {
    return String.fromCharCode(97 + b);
  }
  b -= 26;
  if (b === 0) {
    return `-`;
  }
  if (b === 1) {
    return `_`;
  }
  return `?`;
}
function append3bytes(b1, b2, b3) {
  const c1 = b1 >> 2;
  const c2 = (b1 & 3) << 4 | b2 >> 4;
  const c3 = (b2 & 15) << 2 | b3 >> 6;
  const c4 = b3 & 63;
  let r2 = ``;
  r2 += encode6bit(c1 & 63);
  r2 += encode6bit(c2 & 63);
  r2 += encode6bit(c3 & 63);
  r2 += encode6bit(c4 & 63);
  return r2;
}
function encode64(data) {
  let r2 = ``;
  for (let i = 0; i < data.length; i += 3) {
    if (i + 2 === data.length) {
      r2 += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0);
    } else if (i + 1 === data.length) {
      r2 += append3bytes(data.charCodeAt(i), 0, 0);
    } else {
      r2 += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), data.charCodeAt(i + 2));
    }
  }
  return r2;
}
function performDeflate(input) {
  try {
    const inputBytes = new TextEncoder().encode(input);
    const compressed = deflateSync(inputBytes, { level: 9 });
    return String.fromCharCode(...compressed);
  } catch (error) {
    console.warn(`Deflate compression failed:`, error);
    return input;
  }
}
function encodePlantUML(plantumlCode) {
  try {
    const deflated = performDeflate(plantumlCode);
    return encode64(deflated);
  } catch (error) {
    console.warn(`PlantUML encoding failed, using fallback:`, error);
    const utf8Bytes = new TextEncoder().encode(plantumlCode);
    const base64 = btoa(String.fromCharCode(...utf8Bytes));
    return `~1${base64.replace(/\+/g, `-`).replace(/\//g, `_`).replace(/=/g, ``)}`;
  }
}
function generatePlantUMLUrl(code, options) {
  const encoded = encodePlantUML(code);
  const formatPath = options.format === `svg` ? `svg` : `png`;
  return `${options.serverUrl}/${formatPath}/${encoded}`;
}
function renderPlantUMLDiagram(token, options) {
  const { text: code } = token;
  const finalCode = !code.trim().includes(`@start`) || !code.trim().includes(`@end`) ? `@startuml
${code.trim()}
@enduml` : code;
  const imageUrl = generatePlantUMLUrl(finalCode, options);
  if (options.inlineSvg && options.format === `svg`) {
    const placeholder = `plantuml-placeholder-${Math.random().toString(36).slice(2, 11)}`;
    fetchSvgContent(imageUrl).then((svgContent) => {
      const placeholderElement = document.querySelector(`[data-placeholder="${placeholder}"]`);
      if (placeholderElement) {
        placeholderElement.outerHTML = createPlantUMLHTML(imageUrl, options, svgContent);
      }
    });
    const containerStyles = options.styles.container ? Object.entries(options.styles.container).map(([key, value]) => `${key.replace(/([A-Z])/g, `-$1`).toLowerCase()}: ${value}`).join(`; `) : ``;
    return `<div class="${options.className}" style="${containerStyles}" data-placeholder="${placeholder}">
      <div style="color: #666; font-style: italic;">\u6B63\u5728\u52A0\u8F7DPlantUML\u56FE\u8868...</div>
    </div>`;
  }
  return createPlantUMLHTML(imageUrl, options);
}
async function fetchSvgContent(svgUrl) {
  try {
    const response = await fetch(svgUrl);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    const svgContent = await response.text();
    return svgContent.replace(/(<svg[^>]*)\swidth="[^"]*"/g, `$1`).replace(/(<svg[^>]*)\sheight="[^"]*"/g, `$1`).replace(/(<svg[^>]*style="[^"]*?)width:[^;]*;?/g, `$1`).replace(/(<svg[^>]*style="[^"]*?)height:[^;]*;?/g, `$1`);
  } catch (error) {
    console.warn(`Failed to fetch SVG content from ${svgUrl}:`, error);
    return `<div style="color: #666; font-style: italic;">PlantUML\u56FE\u8868\u52A0\u8F7D\u5931\u8D25</div>`;
  }
}
function createPlantUMLHTML(imageUrl, options, svgContent) {
  const containerStyles = options.styles.container ? Object.entries(options.styles.container).map(([key, value]) => `${key.replace(/([A-Z])/g, `-$1`).toLowerCase()}: ${value}`).join(`; `) : ``;
  if (svgContent) {
    return `<div class="${options.className}" style="${containerStyles}">
      ${svgContent}
    </div>`;
  }
  return `<div class="${options.className}" style="${containerStyles}">
    <img src="${imageUrl}" alt="PlantUML Diagram" style="max-width: 100%; height: auto;" />
  </div>`;
}
function markedPlantUML(options = {}) {
  const resolvedOptions = {
    serverUrl: options.serverUrl || `https://www.plantuml.com/plantuml`,
    format: options.format || `svg`,
    className: options.className || `plantuml-diagram`,
    inlineSvg: options.inlineSvg || false,
    styles: {
      container: {
        textAlign: `center`,
        margin: `16px 8px`,
        overflowX: `auto`,
        ...options.styles?.container
      }
    }
  };
  return {
    extensions: [
      {
        name: `plantuml`,
        level: `block`,
        start(src) {
          return src.match(/^```plantuml/m)?.index;
        },
        tokenizer(src) {
          const match = /^```plantuml\r?\n([\s\S]*?)\r?\n```/.exec(src);
          if (match) {
            const [raw, code] = match;
            return {
              type: `plantuml`,
              raw,
              text: code.trim()
            };
          }
        },
        renderer(token) {
          return renderPlantUMLDiagram(token, resolvedOptions);
        }
      }
    ],
    walkTokens(token) {
      if (token.type === `code` && token.lang === `plantuml`) {
        token.type = `plantuml`;
      }
    }
  };
}

// ../core/src/extensions/ruby.ts
init_esm_shims();
function markedRuby() {
  return {
    extensions: [
      {
        name: `ruby`,
        level: `inline`,
        start(src) {
          return src.match(/\[/)?.index;
        },
        tokenizer(src) {
          const rule1 = /^\[([^\]]+)\]\{([^}]+)\}/;
          let match = rule1.exec(src);
          if (match) {
            return {
              type: `ruby`,
              raw: match[0],
              text: match[1].trim(),
              ruby: match[2].trim(),
              format: `basic`
            };
          }
          const rule2 = /^\[([^\]]+)\]\^\(([^)]+)\)/;
          match = rule2.exec(src);
          if (match) {
            return {
              type: `ruby`,
              raw: match[0],
              text: match[1].trim(),
              ruby: match[2].trim(),
              format: `basic-hat`
            };
          }
          return void 0;
        },
        renderer(token) {
          const { text, ruby: ruby2, format: format2 } = token;
          const separatorRegex = /[-]/g;
          const hasSeparators = separatorRegex.test(ruby2);
          if (hasSeparators) {
            const rubyParts = ruby2.split(separatorRegex).filter((part) => part.trim() !== ``);
            const textChars = text.split(``);
            const result = [];
            if (textChars.length >= rubyParts.length) {
              let currentIndex = 0;
              for (let i = 0; i < rubyParts.length; i++) {
                const rubyPart = rubyParts[i];
                const remainingChars = textChars.length - currentIndex;
                const remainingParts = rubyParts.length - i;
                let charCount = 1;
                if (remainingParts === 1) {
                  charCount = remainingChars;
                }
                const currentText = textChars.slice(currentIndex, currentIndex + charCount).join(``);
                result.push(`<ruby data-text="${currentText}" data-ruby="${rubyPart}" data-format="${format2}">${currentText}<rp>(</rp><rt>${rubyPart}</rt><rp>)</rp></ruby>`);
                currentIndex += charCount;
              }
              if (currentIndex < textChars.length) {
                result.push(textChars.slice(currentIndex).join(``));
              }
            } else {
              for (let i = 0; i < textChars.length; i++) {
                const char = textChars[i];
                const rubyPart = rubyParts[i] || ``;
                if (rubyPart) {
                  result.push(`<ruby data-text="${char}" data-ruby="${rubyPart}" data-format="${format2}">${char}<rp>(</rp><rt>${rubyPart}</rt><rp>)</rp></ruby>`);
                } else {
                  result.push(char);
                }
              }
            }
            return result.join(``);
          }
          return `<ruby data-text="${text}" data-ruby="${ruby2}" data-format="${format2}">${text}<rp>(</rp><rt>${ruby2}</rt><rp>)</rp></ruby>`;
        }
      }
    ]
  };
}

// ../core/src/extensions/slider.ts
init_esm_shims();
function markedSlider(options = {}) {
  return {
    extensions: [
      {
        name: `horizontalSlider`,
        level: `block`,
        start(src) {
          return src.match(/^<!\[/)?.index;
        },
        tokenizer(src) {
          const rule = /^<(!\[.*?\]\(.*?\)(?:,!\[.*?\]\(.*?\))*)>/;
          const match = src.match(rule);
          if (match) {
            return {
              type: `horizontalSlider`,
              raw: match[0],
              text: match[1]
            };
          }
          return void 0;
        },
        renderer(token) {
          const { text } = token;
          const imageMatches = text.match(/!\[(.*?)\]\((.*?)\)/g) || [];
          if (imageMatches.length === 0) {
            return ``;
          }
          const images = imageMatches.map((img) => {
            const altMatch = img.match(/!\[(.*?)\]/) || [];
            const srcMatch = img.match(/\]\((.*?)\)/) || [];
            const alt = altMatch[1] || ``;
            const src = srcMatch[1] || ``;
            const { styles } = options;
            const imgStyles = styles ? getStyleString(styles.image) : ``;
            return { src, alt, imgStyles };
          });
          return `
            <section style="box-sizing: border-box; font-size: 16px;">
              <section data-role="outer" style="font-family: \u5FAE\u8F6F\u96C5\u9ED1; font-size: 16px;">
                <section data-role="paragraph" style="margin: 0px auto; box-sizing: border-box; width: 100%;">
                  <section style="margin: 0px auto; text-align: center;">
                    <section style="display: inline-block; width: 100%;">
                      <!-- \u5FAE\u4FE1\u516C\u4F17\u53F7\u652F\u6301\u7684\u6ED1\u52A8\u56FE\u7247\u5BB9\u5668 -->
                      <section style="overflow-x: scroll; -webkit-overflow-scrolling: touch; white-space: nowrap; width: 100%; text-align: center;">
                        ${images.map((img, _index) => `<section style="display: inline-block; width: 100%; margin-right: 0; vertical-align: top;">
                          <img src="${img.src}" alt="${img.alt}" title="${img.alt}" style="${img.imgStyles}; width: 100%; height: auto; border-radius: 4px; vertical-align: top;"/>
                          <p style="margin-top: 5px; font-size: 14px; color: #666; text-align: center; white-space: normal;">${img.alt}</p>
                        </section>`).join(``)}
                      </section>
                    </section>
                  </section>
                </section>
              </section>
              <p style="font-size: 14px; color: #999; text-align: center; margin-top: 5px;"><<< \u5DE6\u53F3\u6ED1\u52A8\u770B\u66F4\u591A >>></p>
            </section>
          `;
        }
      }
    ]
  };
}

// ../core/src/extensions/toc.ts
init_esm_shims();
function markedToc() {
  let headings = [];
  let firstToken = true;
  return {
    walkTokens(token) {
      if (firstToken) {
        headings = [];
        firstToken = false;
      }
      if (token.type === `heading`) {
        const text = token.text || ``;
        const depth = token.depth || 1;
        const index = headings.length;
        headings.push({ text, depth, index });
      }
    },
    extensions: [
      {
        name: `toc`,
        level: `block`,
        start(src) {
          const match = src.match(/^\s*\[TOC\]\s*$/m);
          return match ? match.index : void 0;
        },
        tokenizer(src) {
          const match = /^\[TOC\]/.exec(src);
          if (match) {
            return {
              type: `toc`,
              raw: match[0]
            };
          }
        },
        renderer() {
          if (!headings.length)
            return ``;
          let html = `<nav class="markdown-toc"><ul class="toc-ul toc-level-1 pl-4 border-l ml-2">`;
          let lastDepth = 1;
          headings.forEach(({ text, depth, index }) => {
            if (depth > lastDepth) {
              for (let i = lastDepth + 1; i <= depth; i++) {
                html += `<ul class="toc-ul toc-level-${i} pl-4 border-l ml-2">`;
              }
            } else if (depth < lastDepth) {
              for (let i = lastDepth; i > depth; i--) {
                html += `</ul>`;
              }
            }
            html += `<li class="toc-li toc-level-${depth} mb-1"><a class="text-gray-700 hover:text-blue-600 underline transition-colors" href="#${index}">${text}</a></li>`;
            lastDepth = depth;
          });
          for (let i = lastDepth; i > 1; i--) {
            html += `</ul>`;
          }
          html += `</ul></nav>`;
          firstToken = true;
          return html;
        }
      }
    ]
  };
}

// ../core/src/renderer/index.ts
init_esm_shims();

// ../core/src/renderer/renderer-impl.ts
init_esm_shims();
Object.entries(COMMON_LANGUAGES).forEach(([name, lang]) => {
  hljs.registerLanguage(name, lang);
});
marked.setOptions({
  breaks: true
});
marked.use(markedSlider());
function buildTheme({ theme: _theme, fonts, size, isUseIndent, isUseJustify }) {
  const theme = cloneDeep(_theme);
  const base = toMerged(theme.base, {
    "font-family": fonts,
    "font-size": size
  });
  if (isUseIndent) {
    theme.block.p = {
      "text-indent": `2em`,
      ...theme.block.p
    };
  }
  if (isUseJustify) {
    theme.block.p = {
      "text-align": `justify`,
      ...theme.block.p
    };
  }
  const mergeStyles = (styles) => Object.fromEntries(
    Object.entries(styles).map(([ele, style]) => [ele, toMerged(base, style)])
  );
  return {
    ...mergeStyles(theme.inline),
    ...mergeStyles(theme.block)
  };
}
function escapeHtml(text) {
  return text.replace(/&/g, `&amp;`).replace(/</g, `&lt;`).replace(/>/g, `&gt;`).replace(/"/g, `&quot;`).replace(/'/g, `&#39;`).replace(/`/g, `&#96;`);
}
function buildAddition() {
  return `
    <style>
      .preview-wrapper pre::before {
        position: absolute;
        top: 0;
        right: 0;
        color: #ccc;
        text-align: center;
        font-size: 0.8em;
        padding: 5px 10px 0;
        line-height: 15px;
        height: 15px;
        font-weight: 600;
      }
    </style>
  `;
}
function getStyles(styleMapping, tokenName, addition = ``) {
  const dict = styleMapping[tokenName];
  if (!dict) {
    return ``;
  }
  const styles = getStyleString(dict);
  return `style="${styles}${addition}"`;
}
function buildFootnoteArray(footnotes) {
  return footnotes.map(
    ([index, title, link]) => link === title ? `<code style="font-size: 90%; opacity: 0.6;">[${index}]</code>: <i style="word-break: break-all">${title}</i><br/>` : `<code style="font-size: 90%; opacity: 0.6;">[${index}]</code> ${title}: <i style="word-break: break-all">${link}</i><br/>`
  ).join(`
`);
}
function transform(legend, text, title) {
  const options = legend.split(`-`);
  for (const option of options) {
    if (option === `alt` && text) {
      return text;
    }
    if (option === `title` && title) {
      return title;
    }
  }
  return ``;
}
var macCodeSvg = `
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" width="45px" height="13px" viewBox="0 0 450 130">
    <ellipse cx="50" cy="65" rx="50" ry="52" stroke="rgb(220,60,54)" stroke-width="2" fill="rgb(237,108,96)" />
    <ellipse cx="225" cy="65" rx="50" ry="52" stroke="rgb(218,151,33)" stroke-width="2" fill="rgb(247,193,81)" />
    <ellipse cx="400" cy="65" rx="50" ry="52" stroke="rgb(27,161,37)" stroke-width="2" fill="rgb(100,200,86)" />
  </svg>
`.trim();
function parseFrontMatterAndContent(markdownText) {
  try {
    const parsed = frontMatter(markdownText);
    const yamlData = parsed.attributes;
    const markdownContent = parsed.body;
    const readingTimeResult = readingTime(markdownContent);
    return {
      yamlData,
      markdownContent,
      readingTime: readingTimeResult
    };
  } catch (error) {
    console.error(`Error parsing front-matter:`, error);
    return {
      yamlData: {},
      markdownContent: markdownText,
      readingTime: readingTime(markdownText)
    };
  }
}
function initRenderer(opts) {
  const footnotes = [];
  let footnoteIndex = 0;
  let styleMapping = buildTheme(opts);
  let codeIndex = 0;
  const listOrderedStack = [];
  const listCounters = [];
  function getOpts() {
    return opts;
  }
  function styles(tag, addition = ``) {
    return getStyles(styleMapping, tag, addition);
  }
  function styledContent(styleLabel, content, tagName) {
    const tag = tagName ?? styleLabel;
    return `<${tag} ${/^h\d$/.test(tag) ? `data-heading="true"` : ``} ${styles(styleLabel)}>${content}</${tag}>`;
  }
  function addFootnote(title, link) {
    const existingFootnote = footnotes.find(([, , existingLink]) => existingLink === link);
    if (existingFootnote) {
      return existingFootnote[0];
    }
    footnotes.push([++footnoteIndex, title, link]);
    return footnoteIndex;
  }
  function reset(newOpts) {
    footnotes.length = 0;
    footnoteIndex = 0;
    setOptions(newOpts);
  }
  function setOptions(newOpts) {
    opts = { ...opts, ...newOpts };
    const oldStyle = JSON.stringify(styleMapping);
    styleMapping = buildTheme(opts);
    const newStyle = JSON.stringify(styleMapping);
    if (oldStyle !== newStyle) {
      marked.use(markedAlert({ styles: styleMapping }));
      marked.use(
        MDKatex(
          { nonStandard: true },
          styles(`inline_katex`, `;line-height: 1;`),
          styles(`block_katex`, `;text-align: center;`)
        )
      );
      marked.use(markedMarkup({ styles: styleMapping }));
    }
  }
  function buildReadingTime(readingTime2) {
    if (!opts.countStatus) {
      return ``;
    }
    if (!readingTime2.words) {
      return ``;
    }
    return `
      <blockquote ${styles(`blockquote`)}>
        <p ${styles(`blockquote_p`)}>\u5B57\u6570 ${readingTime2?.words}\uFF0C\u9605\u8BFB\u5927\u7EA6\u9700 ${Math.ceil(readingTime2?.minutes)} \u5206\u949F</p>
      </blockquote>
    `;
  }
  const buildFootnotes = () => {
    if (!footnotes.length) {
      return ``;
    }
    return styledContent(`h4`, `\u5F15\u7528\u94FE\u63A5`) + styledContent(`footnotes`, buildFootnoteArray(footnotes), `p`);
  };
  const renderer = {
    heading({ tokens, depth }) {
      const text = this.parser.parseInline(tokens);
      const tag = `h${depth}`;
      return styledContent(tag, text);
    },
    paragraph({ tokens }) {
      const text = this.parser.parseInline(tokens);
      const isFigureImage = text.includes(`<figure`) && text.includes(`<img`);
      const isEmpty = text.trim() === ``;
      if (isFigureImage || isEmpty) {
        return text;
      }
      return styledContent(`p`, text);
    },
    blockquote({ tokens }) {
      let text = this.parser.parse(tokens);
      text = text.replace(/<p .*?>/g, `<p ${styles(`blockquote_p`)}>`);
      return styledContent(`blockquote`, text);
    },
    code({ text, lang = `` }) {
      if (lang.startsWith(`mermaid`)) {
        clearTimeout(codeIndex);
        codeIndex = setTimeout(async () => {
          if (typeof window !== `undefined` && window.mermaid) {
            const mermaid = window.mermaid;
            await mermaid.run();
          } else {
            const mermaid = await import('mermaid');
            await mermaid.default.run();
          }
        }, 0);
        return `<pre class="mermaid">${text}</pre>`;
      }
      const langText = lang.split(` `)[0];
      const isLanguageRegistered = hljs.getLanguage(langText);
      const language = isLanguageRegistered ? langText : `plaintext`;
      const highlighted = highlightAndFormatCode(text, language, hljs, !!opts.isShowLineNumber);
      const span = `<span class="mac-sign" style="padding: 10px 14px 0;">${macCodeSvg}</span>`;
      let pendingAttr = ``;
      if (!isLanguageRegistered && langText !== `plaintext`) {
        const escapedText = text.replace(/"/g, `&quot;`);
        pendingAttr = ` data-language-pending="${langText}" data-raw-code="${escapedText}" data-show-line-number="${opts.isShowLineNumber}"`;
      }
      const code = `<code class="language-${lang}"${pendingAttr} ${styles(`code`)}>${highlighted}</code>`;
      return `<pre class="hljs code__pre" ${styles(`code_pre`)}>${span}${code}</pre>`;
    },
    codespan({ text }) {
      const escapedText = escapeHtml(text);
      return styledContent(`codespan`, escapedText, `code`);
    },
    list({ ordered, items, start = 1 }) {
      listOrderedStack.push(ordered);
      listCounters.push(Number(start));
      const html = items.map((item) => this.listitem(item)).join(``);
      listOrderedStack.pop();
      listCounters.pop();
      return styledContent(
        ordered ? `ol` : `ul`,
        html
      );
    },
    // 2. listitem ordered + counter prefix 
    listitem(token) {
      const ordered = listOrderedStack[listOrderedStack.length - 1];
      const idx = listCounters[listCounters.length - 1];
      listCounters[listCounters.length - 1] = idx + 1;
      const prefix = ordered ? `${idx}. ` : `\u2022 `;
      let content;
      try {
        content = this.parser.parseInline(token.tokens);
      } catch {
        content = this.parser.parse(token.tokens).replace(/^<p(?:\s[^>]*)?>([\s\S]*?)<\/p>/, `$1`);
      }
      return styledContent(
        `listitem`,
        `${prefix}${content}`,
        `li`
      );
    },
    image({ href, title, text }) {
      const subText = styledContent(`figcaption`, transform(opts.legend, text, title));
      const figureStyles = styles(`figure`);
      const imgStyles = styles(`image`);
      return `<figure ${figureStyles}><img ${imgStyles} src="${href}" title="${title}" alt="${text}"/>${subText}</figure>`;
    },
    link({ href, title, text, tokens }) {
      const parsedText = this.parser.parseInline(tokens);
      if (/^https?:\/\/mp\.weixin\.qq\.com/.test(href)) {
        return `<a href="${href}" title="${title || text}" ${styles(`wx_link`)}>${parsedText}</a>`;
      }
      if (href === text) {
        return parsedText;
      }
      if (opts.citeStatus) {
        const ref = addFootnote(title || text, href);
        return `<span ${styles(`link`)}>${parsedText}<sup>[${ref}]</sup></span>`;
      }
      return styledContent(`link`, parsedText, `span`);
    },
    strong({ tokens }) {
      return styledContent(`strong`, this.parser.parseInline(tokens));
    },
    em({ tokens }) {
      return styledContent(`em`, this.parser.parseInline(tokens), `span`);
    },
    table({ header, rows }) {
      const headerRow = header.map((cell) => {
        const text = this.parser.parseInline(cell.tokens);
        return styledContent(`th`, text);
      }).join(``);
      const body = rows.map((row) => {
        const rowContent = row.map((cell) => this.tablecell(cell)).join(``);
        return styledContent(`tr`, rowContent);
      }).join(``);
      return `
        <section style="max-width: 100%; overflow: auto">
          <table class="preview-table" ${styles(`table`)}>
            <thead ${styles(`thead`)}>${headerRow}</thead>
            <tbody>${body}</tbody>
          </table>
        </section>
      `;
    },
    tablecell(token) {
      const text = this.parser.parseInline(token.tokens);
      return styledContent(`td`, text);
    },
    hr(_) {
      return styledContent(`hr`, ``);
    }
  };
  marked.use({ renderer });
  marked.use(markedMarkup({ styles: styleMapping }));
  marked.use(markedToc());
  marked.use(markedSlider({ styles: styleMapping }));
  marked.use(markedAlert({ styles: styleMapping }));
  marked.use(
    MDKatex(
      { nonStandard: true },
      styles(`inline_katex`, `;line-height: 1;`),
      styles(`block_katex`, `;text-align: center;`)
    )
  );
  marked.use(markedFootnotes());
  marked.use(markedPlantUML({
    inlineSvg: true
    // SVG
  }));
  marked.use(markedRuby());
  return {
    buildAddition,
    buildFootnotes,
    setOptions,
    reset,
    parseFrontMatterAndContent,
    buildReadingTime,
    createContainer(content) {
      return styledContent(`container`, content, `section`);
    },
    getOpts
  };
}

// ../shared/src/configs/index.ts
init_esm_shims();

// ../shared/src/configs/ai-service-options.ts
init_esm_shims();

// ../shared/src/constants/index.ts
init_esm_shims();

// ../shared/src/constants/ai-config.ts
init_esm_shims();

// ../shared/src/configs/api.ts
init_esm_shims();
({
  repoList: Array.from({ length: 20 }, (_, i) => `img${i}`)});
({
  repoList: Array.from({ length: 20 }, (_, i) => `img${i}`)});

// ../shared/src/configs/prefix.ts
init_esm_shims();

// ../shared/src/configs/shortcut-key.ts
init_esm_shims();

// ../shared/src/configs/store.ts
init_esm_shims();

// ../shared/src/configs/style.ts
init_esm_shims();

// ../shared/src/configs/theme.ts
init_esm_shims();
var defaultTheme = {
  base: {
    "--md-primary-color": `#000000`,
    "text-align": `left`,
    "line-height": `1.75`
  },
  block: {
    container: {},
    // 
    h1: {
      "display": `table`,
      "padding": `0 1em`,
      "border-bottom": `2px solid var(--md-primary-color)`,
      "margin": `2em auto 1em`,
      "color": `hsl(var(--foreground))`,
      "font-size": `1.2em`,
      "font-weight": `bold`,
      "text-align": `center`
    },
    // 
    h2: {
      "display": `table`,
      "padding": `0 0.2em`,
      "margin": `4em auto 2em`,
      "color": `#fff`,
      "background": `var(--md-primary-color)`,
      "font-size": `1.2em`,
      "font-weight": `bold`,
      "text-align": `center`
    },
    // 
    h3: {
      "padding-left": `8px`,
      "border-left": `3px solid var(--md-primary-color)`,
      "margin": `2em 8px 0.75em 0`,
      "color": `hsl(var(--foreground))`,
      "font-size": `1.1em`,
      "font-weight": `bold`,
      "line-height": `1.2`
    },
    // 
    h4: {
      "margin": `2em 8px 0.5em`,
      "color": `var(--md-primary-color)`,
      "font-size": `1em`,
      "font-weight": `bold`
    },
    // 
    h5: {
      "margin": `1.5em 8px 0.5em`,
      "color": `var(--md-primary-color)`,
      "font-size": `1em`,
      "font-weight": `bold`
    },
    // 
    h6: {
      "margin": `1.5em 8px 0.5em`,
      "font-size": `1em`,
      "color": `var(--md-primary-color)`
    },
    // 
    p: {
      "margin": `1.5em 8px`,
      "letter-spacing": `0.1em`,
      "color": `hsl(var(--foreground))`
    },
    // 
    blockquote: {
      "font-style": `normal`,
      "padding": `1em`,
      "border-left": `4px solid var(--md-primary-color)`,
      "border-radius": `6px`,
      "color": `rgba(0,0,0,0.5)`,
      "background": `var(--blockquote-background)`,
      "margin-bottom": `1em`
    },
    // 
    blockquote_p: {
      "display": `block`,
      "font-size": `1em`,
      "letter-spacing": `0.1em`,
      "color": `hsl(var(--foreground))`
    },
    blockquote_note: {},
    blockquote_tip: {},
    blockquote_info: {},
    blockquote_important: {},
    blockquote_warning: {},
    blockquote_caution: {},
    // GFM 
    blockquote_title: {
      "display": `flex`,
      "align-items": `center`,
      "gap": `0.5em`,
      "margin-bottom": `0.5em`
    },
    blockquote_title_note: {
      color: `#478be6`
    },
    blockquote_title_tip: {
      color: `#57ab5a`
    },
    blockquote_title_info: {
      color: `#93c5fd`
    },
    blockquote_title_important: {
      color: `#986ee2`
    },
    blockquote_title_warning: {
      color: `#c69026`
    },
    blockquote_title_caution: {
      color: `#e5534b`
    },
    blockquote_p_note: {},
    blockquote_p_tip: {},
    blockquote_p_info: {},
    blockquote_p_important: {},
    blockquote_p_warning: {},
    blockquote_p_caution: {},
    // 
    code_pre: {
      "font-size": `90%`,
      "overflow-x": `auto`,
      "border-radius": `8px`,
      "padding": `1em`,
      "line-height": `1.5`,
      "margin": `10px 8px`
    },
    // 
    code: {
      "margin": 0,
      "white-space": `nowrap`,
      "font-size": `90%`,
      "font-family": `Menlo, Operator Mono, Consolas, Monaco, monospace`
    },
    // 
    image: {
      "display": `block`,
      "max-width": `100%`,
      "margin": `0.1em auto 0.5em`,
      "border-radius": `4px`
    },
    // 
    ol: {
      "padding-left": `1em`,
      "margin-left": `0`,
      "color": `hsl(var(--foreground))`
    },
    // 
    ul: {
      "list-style": `circle`,
      "padding-left": `1em`,
      "margin-left": `0`,
      "color": `hsl(var(--foreground))`
    },
    footnotes: {
      "margin": `0.5em 8px`,
      "font-size": `80%`,
      "color": `hsl(var(--foreground))`
    },
    figure: {
      margin: `1.5em 8px`,
      color: `hsl(var(--foreground))`
    },
    hr: {
      "border-style": `solid`,
      "border-width": `2px 0 0`,
      "border-color": `rgba(0,0,0,0.1)`,
      "-webkit-transform-origin": `0 0`,
      "-webkit-transform": `scale(1, 0.5)`,
      "transform-origin": `0 0`,
      "transform": `scale(1, 0.5)`,
      "height": `0.4em`,
      "margin": `1.5em 0`
    },
    block_katex: {
      "max-width": `100%`,
      "overflow-x": `auto`,
      "-webkit-overflow-scrolling": `touch`,
      "padding": `0.5em 0`
    }
  },
  inline: {
    listitem: {
      display: `block`,
      margin: `0.2em 8px`,
      color: `hsl(var(--foreground))`
    },
    codespan: {
      "font-size": `90%`,
      "color": `#d14`,
      "background": `rgba(27,31,35,.05)`,
      "padding": `3px 5px`,
      "border-radius": `4px`
      // 'word-break': `break-all`,
    },
    em: {
      "font-style": `italic`,
      "font-size": `inherit`
    },
    link: {
      color: `#576b95`
    },
    wx_link: {
      "color": `#576b95`,
      "text-decoration": `none`
    },
    // 
    strong: {
      "color": `var(--md-primary-color)`,
      "font-weight": `bold`,
      "font-size": `inherit`
    },
    table: {
      color: `hsl(var(--foreground))`
    },
    thead: {
      "font-weight": `bold`,
      "color": `hsl(var(--foreground))`
    },
    th: {
      "border": `1px solid #dfdfdf`,
      "padding": `0.25em 0.5em`,
      "color": `hsl(var(--foreground))`,
      "word-break": `keep-all`,
      "background": `rgba(0, 0, 0, 0.05)`
    },
    td: {
      "border": `1px solid #dfdfdf`,
      "padding": `0.25em 0.5em`,
      "color": `hsl(var(--foreground))`,
      "word-break": `keep-all`
    },
    footnote: {
      "font-size": `12px`,
      "color": `hsl(var(--foreground))`
    },
    figcaption: {
      "text-align": `center`,
      "color": `#888`,
      "font-size": `0.8em`
    },
    inline_katex: {
      "max-width": `100%`,
      "overflow-x": `auto`
    },
    markup_highlight: {
      "background-color": `var(--md-primary-color)`,
      "padding": `2px 4px`,
      "border-radius": `2px`,
      "color": `#fff`
    },
    markup_underline: {
      "text-decoration": `underline`,
      "text-decoration-color": `var(--md-primary-color)`
    },
    markup_wavyline: {
      "text-decoration": `underline wavy`,
      "text-decoration-color": `var(--md-primary-color)`,
      "text-decoration-thickness": `2px`
    }
  }
};
toMerged(defaultTheme, {
  base: {},
  block: {
    "container": {},
    "h1": {
      "padding": `0.5em 1em`,
      "border-bottom": `2px solid var(--md-primary-color)`,
      "font-size": `1.4em`,
      "text-shadow": `2px 2px 4px rgba(0,0,0,0.1)`
    },
    "h2": {
      "padding": `0.3em 1em`,
      "border-radius": `8px`,
      "font-size": `1.3em`,
      "box-shadow": `0 4px 6px rgba(0,0,0,0.1)`
    },
    "h3": {
      "padding-left": `12px`,
      "font-size": `1.2em`,
      "border-left": `4px solid var(--md-primary-color)`,
      "border-bottom": `1px dashed var(--md-primary-color)`
    },
    "h4": {
      "font-size": `1.1em`
    },
    "h5": {
      "font-size": `1em`
    },
    "h6": {
      "font-size": `1em`
    },
    "p": {},
    "blockquote": {
      "font-style": `italic`,
      "padding": `1em 1em 1em 2em`,
      "border-left": `4px solid var(--md-primary-color)`,
      "border-radius": `6px`,
      "color": `rgba(0,0,0,0.6)`,
      "box-shadow": `0 4px 6px rgba(0,0,0,0.05)`,
      "margin-bottom": `1em`
    },
    "blockquote_p": {},
    "markdown-alert": {
      "font-style": `italic`
    },
    "code_pre": {
      "box-shadow": `inset 0 0 10px rgba(0,0,0,0.05)`
    },
    "code": {
      "font-family": `'Fira Code', Menlo, Operator Mono, Consolas, Monaco, monospace`
    },
    "image": {
      "border-radius": `8px`,
      "box-shadow": `0 4px 8px rgba(0,0,0,0.1)`
    },
    "ol": {
      "padding-left": `1.5em`
    },
    "ul": {
      "list-style": `none`,
      "padding-left": `1.5em`
    },
    "footnotes": {},
    "figure": {},
    "hr": {
      height: `1px`,
      border: `none`,
      margin: `2em 0`,
      background: `linear-gradient(to right, rgba(0,0,0,0), rgba(0,0,0,0.1), rgba(0,0,0,0))`
    }
  },
  inline: {
    listitem: {
      margin: `0.5em 8px`
    },
    codespan: {},
    em: {},
    link: {},
    wx_link: {},
    strong: {},
    table: {
      "border-collapse": `separate`,
      "border-spacing": `0`,
      "border-radius": `8px`,
      "margin": `1em 8px`,
      "color": `hsl(var(--foreground))`,
      "box-shadow": `0 4px 6px rgba(0,0,0,0.1)`,
      "overflow": `hidden`
    },
    thead: {
      color: `#fff`
    },
    td: {
      padding: `0.5em 1em`
    },
    footnote: {
      color: `rgba(0,0,0,0.5)`
    },
    figcaption: {}
  }
});
toMerged(defaultTheme, {
  base: {},
  block: {
    container: {},
    h1: {
      "padding": `0.5em 1em`,
      "font-size": `1.4em`,
      "text-shadow": `1px 1px 3px rgba(0,0,0,0.05)`
    },
    h2: {
      "padding": `0.3em 1.2em`,
      "font-size": `1.3em`,
      "border-radius": `8px 24px 8px 24px`,
      "box-shadow": `0 2px 6px rgba(0,0,0,0.06)`
    },
    h3: {
      "padding-left": `12px`,
      "font-size": `1.2em`,
      "border-radius": `6px`,
      "line-height": `2.4em`,
      "border-left": `4px solid var(--md-primary-color)`,
      "border-right": `1px solid color-mix(in srgb, var(--md-primary-color) 10%, transparent)`,
      "border-bottom": `1px solid color-mix(in srgb, var(--md-primary-color) 10%, transparent)`,
      "border-top": `1px solid color-mix(in srgb, var(--md-primary-color) 10%, transparent)`,
      "background": `color-mix(in srgb, var(--md-primary-color) 8%, transparent)`
    },
    h4: {
      "font-size": `1.1em`,
      "border-radius": `6px`
    },
    h5: {
      "border-radius": `6px`
    },
    h6: {
      "border-radius": `6px`
    },
    blockquote: {
      "font-style": `italic`,
      "padding": `1em 1em 1em 2em`,
      "color": `rgba(0,0,0,0.6)`,
      "border-bottom": `0.2px solid rgba(0, 0, 0, 0.04)`,
      "border-top": `0.2px solid rgba(0, 0, 0, 0.04)`,
      "border-right": `0.2px solid rgba(0, 0, 0, 0.04)`
    },
    blockquote_note: {
      "font-style": `italic`
    },
    blockquote_tip: {
      "font-style": `italic`
    },
    blockquote_info: {
      "font-style": `italic`
    },
    blockquote_important: {
      "font-style": `italic`
    },
    blockquote_warning: {
      "font-style": `italic`
    },
    blockquote_caution: {
      "font-style": `italic`
    },
    blockquote_title: {},
    blockquote_title_note: {},
    blockquote_title_tip: {},
    blockquote_title_info: {},
    blockquote_title_important: {},
    blockquote_title_warning: {},
    blockquote_title_caution: {},
    blockquote_p_note: {},
    blockquote_p_tip: {},
    blockquote_p_info: {},
    blockquote_p_important: {},
    blockquote_p_warning: {},
    blockquote_p_caution: {},
    code_pre: {
      border: `1px solid rgba(0, 0, 0, 0.04)`
    },
    code: {
      "font-family": `'Fira Code', Menlo, Operator Mono, Consolas, Monaco, monospace`
    },
    image: {
      "border-radius": `8px`,
      "border": `1px solid rgba(0, 0, 0, 0.04)`
    },
    ol: {
      "padding-left": `1.5em`
    },
    ul: {
      "list-style": `none`,
      "padding-left": `1.5em`
    },
    hr: {
      height: `1px`,
      border: `none`,
      margin: `2em 0`,
      background: `linear-gradient(to right, rgba(0,0,0,0), rgba(0,0,0,0.1), rgba(0,0,0,0))`
    }
  },
  inline: {
    listitem: {
      margin: `0.5em 8px`
    }
  }
});
var themeMap = {
  default: defaultTheme};
var codeBlockUrlPrefix = `https://cdn-doocs.oss-cn-shenzhen.aliyuncs.com/npm/highlightjs/11.11.1/styles/`;
var codeBlockThemeList = [
  `1c-light`,
  `a11y-dark`,
  `a11y-light`,
  `agate`,
  `an-old-hope`,
  `androidstudio`,
  `arduino-light`,
  `arta`,
  `ascetic`,
  `atom-one-dark-reasonable`,
  `atom-one-dark`,
  `atom-one-light`,
  `brown-paper`,
  `codepen-embed`,
  `color-brewer`,
  `dark`,
  `default`,
  `devibeans`,
  `docco`,
  `far`,
  `felipec`,
  `foundation`,
  `github-dark-dimmed`,
  `github-dark`,
  `github`,
  `gml`,
  `googlecode`,
  `gradient-dark`,
  `gradient-light`,
  `grayscale`,
  `hybrid`,
  `idea`,
  `intellij-light`,
  `ir-black`,
  `isbl-editor-dark`,
  `isbl-editor-light`,
  `kimbie-dark`,
  `kimbie-light`,
  `lightfair`,
  `lioshi`,
  `magula`,
  `mono-blue`,
  `monokai-sublime`,
  `monokai`,
  `night-owl`,
  `nnfx-dark`,
  `nnfx-light`,
  `nord`,
  `obsidian`,
  `panda-syntax-dark`,
  `panda-syntax-light`,
  `paraiso-dark`,
  `paraiso-light`,
  `pojoaque`,
  `purebasic`,
  `qtcreator-dark`,
  `qtcreator-light`,
  `rainbow`,
  `routeros`,
  `school-book`,
  `shades-of-purple`,
  `srcery`,
  `stackoverflow-dark`,
  `stackoverflow-light`,
  `sunburst`,
  `tokyo-night-dark`,
  `tokyo-night-light`,
  `tomorrow-night-blue`,
  `tomorrow-night-bright`,
  `vs`,
  `vs2015`,
  `xcode`,
  `xt256`
];
var codeBlockThemeOptions = codeBlockThemeList.map((codeBlockTheme) => ({
  label: codeBlockTheme,
  value: `${codeBlockUrlPrefix}${codeBlockTheme}.min.css`,
  desc: ``
}));
({
  codeBlockTheme: codeBlockThemeOptions[23].value});

// ../shared/src/utils/index.ts
init_esm_shims();

// ../shared/src/utils/basicHelpers.ts
init_esm_shims();
function css2json(css2) {
  css2 = css2.replace(/\/\*[\s\S]*?\*\//g, ``);
  const json2 = {};
  const toObject = (array) => array.reduce((obj, item) => {
    const [property, ...value] = item.split(`:`).map((part) => part.trim());
    if (property)
      obj[property] = value.join(`:`);
    return obj;
  }, {});
  while (css2.includes(`{`) && css2.includes(`}`)) {
    const lbracket = css2.indexOf(`{`);
    const rbracket = css2.indexOf(`}`);
    const declarations = css2.substring(lbracket + 1, rbracket).split(`;`).map((e) => e.trim()).filter(Boolean);
    const selectors = css2.substring(0, lbracket).split(`,`).map((selector) => selector.trim());
    const declarationObj = toObject(declarations);
    selectors.forEach((selector) => {
      json2[selector] = { ...json2[selector] || {}, ...declarationObj };
    });
    css2 = css2.slice(rbracket + 1).trim();
  }
  return json2;
}

// ../shared/src/utils/fetch.ts
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/index.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/axios.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/utils.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/bind.js
init_esm_shims();
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
};
var isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/Axios.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/buildURL.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/toFormData.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/AxiosError.js
init_esm_shims();
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  const msg = error && error.message ? error.message : "Error";
  const errCode = code == null && error ? error.code : code;
  AxiosError.call(axiosError, msg, errCode, config, request, response);
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
  }
  axiosError.name = error && error.name || "Error";
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/platform/node/classes/FormData.js
init_esm_shims();
var import_form_data = __toESM(require_form_data());
var FormData_default = import_form_data.default;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/InterceptorManager.js
init_esm_shims();
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/dispatchRequest.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/transformData.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/defaults/index.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/defaults/transitional.js
init_esm_shims();
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/toURLEncodedForm.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/platform/index.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/platform/node/index.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/platform/node/classes/URLSearchParams.js
init_esm_shims();
var URLSearchParams_default = url.URLSearchParams;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/platform/node/index.js
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  crypto.randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }
  return str;
};
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
init_esm_shims();
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...node_default
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path2, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/formDataToJSON.js
init_esm_shims();
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/AxiosHeaders.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/parseHeaders.js
init_esm_shims();
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform2(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/cancel/isCancel.js
init_esm_shims();
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/cancel/CanceledError.js
init_esm_shims();
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/adapters/adapters.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/adapters/http.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/settle.js
init_esm_shims();
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/buildFullPath.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/isAbsoluteURL.js
init_esm_shims();
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/combineURLs.js
init_esm_shims();
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env());
var import_follow_redirects = __toESM(require_follow_redirects());

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/env/data.js
init_esm_shims();
var VERSION = "1.12.2";

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/fromDataURI.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/parseProtocol.js
init_esm_shims();
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/AxiosTransformStream.js
init_esm_shims();
var kInternals = Symbol("internals");
var AxiosTransformStream = class extends stream3.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
};
var AxiosTransformStream_default = AxiosTransformStream;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/formDataToStream.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/readBlob.js
init_esm_shims();
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
var readBlob_default = readBlob;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util.TextEncoder();
var CRLF = "\r\n";
var CRLF_BYTES = textEncoder.encode(CRLF);
var CRLF_BYTES_COUNT = 2;
var FormDataPart = class {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
};
var formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable.from((async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  })());
};
var formDataToStream_default = formDataToStream;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
init_esm_shims();
var ZlibHeaderTransformStream = class extends stream3.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
};
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/callbackify.js
init_esm_shims();
var callbackify = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
var callbackify_default = callbackify;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/progressEventReducer.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/speedometer.js
init_esm_shims();
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/throttle.js
init_esm_shims();
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js
init_esm_shims();
function estimateDataURLDecodedBytes(url2) {
  if (!url2 || typeof url2 !== "string") return 0;
  if (!url2.startsWith("data:")) return 0;
  const comma = url2.indexOf(",");
  if (comma < 0) return 0;
  const meta = url2.slice(5, comma);
  const body = url2.slice(comma + 1);
  const isBase64 = /;base64/i.test(meta);
  if (isBase64) {
    let effectiveLen = body.length;
    const len = body.length;
    for (let i = 0; i < len; i++) {
      if (body.charCodeAt(i) === 37 && i + 2 < len) {
        const a = body.charCodeAt(i + 1);
        const b = body.charCodeAt(i + 2);
        const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
        if (isHex) {
          effectiveLen -= 2;
          i += 2;
        }
      }
    }
    let pad = 0;
    let idx = len - 1;
    const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && // '%'
    body.charCodeAt(j - 1) === 51 && // '3'
    (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
    if (idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
        idx--;
      } else if (tailIsPct3D(idx)) {
        pad++;
        idx -= 3;
      }
    }
    if (pad === 1 && idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
      } else if (tailIsPct3D(idx)) {
        pad++;
      }
    }
    const groups = Math.floor(effectiveLen / 4);
    const bytes = groups * 3 - (pad || 0);
    return bytes > 0 ? bytes : 0;
  }
  return Buffer.byteLength(body, "utf8");
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(zlib.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = platform_default.protocols.map((protocol) => {
  return protocol + ":";
});
var flushOnFinish = (stream4, [throttled, flush]) => {
  stream4.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var resolveFamily = ({ address, family }) => {
  if (!utils_default.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
var buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
var http_default = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter();
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : void 0);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      if (config.maxContentLength > -1) {
        const dataUrl = String(config.url || fullPath || "");
        const estimated = estimateDataURLDecodedBytes(dataUrl);
        if (estimated > config.maxContentLength) {
          return reject(new AxiosError_default(
            "maxContentLength size of " + config.maxContentLength + " exceeded",
            AxiosError_default.ERR_BAD_RESPONSE,
            config
          ));
        }
      }
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = stream3.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default(
        "Unsupported protocol " + protocol,
        AxiosError_default.ERR_BAD_REQUEST,
        config
      ));
    }
    const headers = AxiosHeaders_default.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const { onUploadProgress, onDownloadProgress } = config;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils_default.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = stream3.Readable.from(readBlob_default(data));
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) ; else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
      headers.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError_default(
          "Request body larger than maxBodyLength limit",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = stream3.Readable.from(data, { objectMode: false });
      }
      data = stream3.pipeline([data, new AxiosTransformStream_default({
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }
    let auth = void 0;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path2;
    try {
      path2 = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path2,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils_default.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https : http;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream_default({
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          /*eslint default-case:0*/
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default());
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(zlib.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? stream3.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = stream3.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError_default.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default(
            "stream has been aborted",
            AxiosError_default.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError_default.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError_default.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError_default(
          "error trying to parse `config.timeout` to int",
          AxiosError_default.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitional_default;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/adapters/xhr.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/resolveConfig.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/isURLSameOrigin.js
init_esm_shims();
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
  url2 = new URL(url2, platform_default.origin);
  return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/cookies.js
init_esm_shims();
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path2) && cookie.push("path=" + path2);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/mergeConfig.js
init_esm_shims();
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils_default.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config, request);
      err.event = event || null;
      reject(err);
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/adapters/fetch.js
init_esm_shims();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/composeSignals.js
init_esm_shims();
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/trackStream.js
init_esm_shims();
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream4) {
  if (stream4[Symbol.asyncIterator]) {
    yield* stream4;
    return;
  }
  const reader = stream4.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream4, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream4, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction: isFunction2 } = utils_default;
var globalFetchAPI = (({ Request, Response }) => ({
  Request,
  Response
}))(utils_default.global);
var {
  ReadableStream: ReadableStream2,
  TextEncoder: TextEncoder2
} = utils_default.global;
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var factory = (env) => {
  env = utils_default.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const { fetch: envFetch, Request, Response } = env;
  const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction2(Request);
  const isResponseSupported = isFunction2(Response);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
  const encodeText = isFetchSupported && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder2()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform_default.origin, {
      body: new ReadableStream2(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = (res, config) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils_default.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config) => {
    let {
      url: url2,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url2, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request = isRequestSupported && new Request(url2, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url2, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config, request);
    }
  };
};
var seedCache = /* @__PURE__ */ new Map();
var getFetch = (config) => {
  let env = config ? config.env : {};
  const { fetch: fetch2, Request, Response } = env;
  const seeds = [
    Request,
    Response,
    fetch2
  ];
  let len = seeds.length, i = len, seed, target, map = seedCache;
  while (i--) {
    seed = seeds[i];
    target = map.get(seed);
    target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env));
    map = target;
  }
  return target;
};
getFetch();

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default,
  fetch: {
    get: getFetch
  }
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
var adapters_default = {
  getAdapter: (adapters, config) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter2;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter2 = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter2 === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config)))) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter2;
    }
    if (!adapter2) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter2;
  },
  adapters: knownAdapters
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config.adapter || defaults_default.adapter, config);
  return adapter2(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/validator.js
init_esm_shims();
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) ; else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/cancel/CancelToken.js
init_esm_shims();
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/spread.js
init_esm_shims();
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/isAxiosError.js
init_esm_shims();
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/helpers/HttpStatusCode.js
init_esm_shims();
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// ../../node_modules/.pnpm/axios@1.12.2/node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// ../shared/src/utils/fetch.ts
var service = axios_default.create({
  baseURL: ``,
  timeout: 30 * 1e3
  // 
});
service.interceptors.request.use(
  (config) => {
    if (/^(?:post|put|delete)$/i.test(`${config.method}`)) {
      if (config.data && config.data.upload) {
        config.headers[`Content-Type`] = `multipart/form-data`;
      }
    }
    return config;
  },
  (error) => {
    Promise.reject(error);
  }
);
service.interceptors.response.use(
  (res) => {
    return res.data ? res.data : Promise.reject(res);
  },
  (error) => Promise.reject(error)
);

// ../shared/src/utils/fileHelpers.ts
init_esm_shims();
__toESM(require_parser_babel());
__toESM(require_parser_markdown());
__toESM(require_parser_postcss());
__toESM(require_standalone());

// ../shared/src/utils/tokenTools.ts
init_esm_shims();

// src/converter.ts
var MarkdownConverter = class {
  constructor() {
    this.renderer = null;
    /**  HTML  */
    this.output = ``;
    /**  */
    this.readingTime = {
      chars: 0,
      words: 0,
      minutes: 0
    };
    /**  */
    this.titleList = [];
  }
  /**
   * 
   * @param options 
   * @returns 
   */
  init(options = {}) {
    const {
      cssContent = ``,
      theme = themeMap.default,
      fonts = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif`,
      size = `16px`,
      primaryColor = `#3f51b5`,
      isUseIndent = false,
      isUseJustify = false,
      isMacCodeBlock = false,
      isShowLineNumber = true
    } = options;
    const fontSize = Number(size.replace(`px`, ``));
    const themeConfig = cssContent ? customCssWithTemplate(
      css2json(cssContent),
      primaryColor,
      customizeTheme(theme, { fontSize, color: primaryColor })
    ) : customizeTheme(theme, { fontSize, color: primaryColor });
    this.renderer = initRenderer({
      theme: themeConfig,
      fonts,
      size,
      isUseIndent,
      isUseJustify,
      isMacCodeBlock,
      isShowLineNumber
    });
    return this;
  }
  /**
   *  Markdown  HTML
   * @param content Markdown 
   * @param options 
   * @returns  HTML 
   */
  render(content, options = {}) {
    if (!this.renderer) {
      throw new Error(`\u6E32\u67D3\u5668\u672A\u521D\u59CB\u5316\uFF0C\u8BF7\u5148\u8C03\u7528 init() \u65B9\u6CD5`);
    }
    const renderOptions = {
      citeStatus: options.isCiteStatus ?? false,
      legend: options.legend ?? `alt`,
      isUseIndent: options.isUseIndent ?? false,
      isUseJustify: options.isUseJustify ?? false,
      countStatus: options.isCountStatus ?? true,
      isMacCodeBlock: options.isMacCodeBlock ?? false,
      isShowLineNumber: options.isShowLineNumber ?? true
    };
    this.renderer.reset(renderOptions);
    const { html: baseHtml, readingTime: readingTimeResult } = renderMarkdown(content, this.renderer);
    this.readingTime.chars = content.length;
    this.readingTime.words = readingTimeResult.words;
    this.readingTime.minutes = Math.ceil(readingTimeResult.minutes);
    this.output = postProcessHtml(baseHtml, readingTimeResult, this.renderer);
    this.extractTitles();
    return this.output;
  }
  /**
   * 
   * @private
   */
  extractTitles() {
    if (typeof document === `undefined`) {
      this.titleList = [];
      return;
    }
    const div = document.createElement(`div`);
    div.innerHTML = this.output;
    const list = div.querySelectorAll(`[data-heading]`);
    this.titleList = [];
    let i = 0;
    for (const item of list) {
      item.setAttribute(`id`, `${i}`);
      this.titleList.push({
        url: `#${i}`,
        title: `${item.textContent}`,
        level: Number(item.tagName.slice(1))
      });
      i++;
    }
    this.output = div.innerHTML;
  }
  /**
   * 
   * @param options 
   */
  updateTheme(options) {
    if (!this.renderer) {
      console.warn(`\u6E32\u67D3\u5668\u672A\u521D\u59CB\u5316`);
      return;
    }
    const {
      cssContent = ``,
      theme = themeMap.default,
      fonts = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif`,
      size = `16px`,
      primaryColor = `#3f51b5`
    } = options;
    const fontSize = Number(size.replace(`px`, ``));
    const newTheme = cssContent ? customCssWithTemplate(
      css2json(cssContent),
      primaryColor,
      customizeTheme(theme, { fontSize, color: primaryColor })
    ) : customizeTheme(theme, { fontSize, color: primaryColor });
    this.renderer.setOptions({
      theme: newTheme,
      fonts,
      size
    });
  }
  /**
   * 
   * @returns  API
   */
  getRenderer() {
    return this.renderer;
  }
  /**
   * 
   */
  reset() {
    this.output = ``;
    this.readingTime = {
      chars: 0,
      words: 0,
      minutes: 0
    };
    this.titleList = [];
  }
  /**
   * 
   * @returns  HTML
   */
  getResult() {
    return {
      html: this.output,
      readingTime: this.readingTime,
      titleList: this.titleList
    };
  }
};
function convertMarkdownToHtml(content, options = {}) {
  const converter = new MarkdownConverter();
  const initOptions = {
    cssContent: options.cssContent,
    theme: options.theme,
    fonts: options.fonts,
    size: options.size,
    primaryColor: options.primaryColor,
    isUseIndent: options.isUseIndent,
    isUseJustify: options.isUseJustify,
    isMacCodeBlock: options.isMacCodeBlock,
    isShowLineNumber: options.isShowLineNumber
  };
  const renderOptions = {
    isCiteStatus: options.isCiteStatus,
    legend: options.legend,
    isUseIndent: options.isUseIndent,
    isUseJustify: options.isUseJustify,
    isCountStatus: options.isCountStatus,
    isMacCodeBlock: options.isMacCodeBlock,
    isShowLineNumber: options.isShowLineNumber
  };
  converter.init(initOptions);
  converter.render(content, renderOptions);
  return converter.getResult();
}
var converter_default = MarkdownConverter;
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/

export { MarkdownConverter, convertMarkdownToHtml, converter_default as default };
//# sourceMappingURL=converter.js.map
//# sourceMappingURL=converter.js.map